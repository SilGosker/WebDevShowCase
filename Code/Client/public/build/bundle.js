
(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(self.document);
var app = (function () {
    'use strict';

    function noop$1() { }
    function assign(tar, src) {
        // @ts-ignore
        for (const k in src)
            tar[k] = src[k];
        return tar;
    }
    function add_location(element, file, line, column, char) {
        element.__svelte_meta = {
            loc: { file, line, column, char }
        };
    }
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    let src_url_equal_anchor;
    function src_url_equal(element_src, url) {
        if (!src_url_equal_anchor) {
            src_url_equal_anchor = document.createElement('a');
        }
        src_url_equal_anchor.href = url;
        return element_src === src_url_equal_anchor.href;
    }
    function is_empty(obj) {
        return Object.keys(obj).length === 0;
    }
    function subscribe(store, ...callbacks) {
        if (store == null) {
            return noop$1;
        }
        const unsub = store.subscribe(...callbacks);
        return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
    }
    function create_slot(definition, ctx, $$scope, fn) {
        if (definition) {
            const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
            return definition[0](slot_ctx);
        }
    }
    function get_slot_context(definition, ctx, $$scope, fn) {
        return definition[1] && fn
            ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))
            : $$scope.ctx;
    }
    function get_slot_changes(definition, $$scope, dirty, fn) {
        if (definition[2] && fn) {
            const lets = definition[2](fn(dirty));
            if ($$scope.dirty === undefined) {
                return lets;
            }
            if (typeof lets === 'object') {
                const merged = [];
                const len = Math.max($$scope.dirty.length, lets.length);
                for (let i = 0; i < len; i += 1) {
                    merged[i] = $$scope.dirty[i] | lets[i];
                }
                return merged;
            }
            return $$scope.dirty | lets;
        }
        return $$scope.dirty;
    }
    function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
        if (slot_changes) {
            const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
            slot.p(slot_context, slot_changes);
        }
    }
    function get_all_dirty_from_scope($$scope) {
        if ($$scope.ctx.length > 32) {
            const dirty = [];
            const length = $$scope.ctx.length / 32;
            for (let i = 0; i < length; i++) {
                dirty[i] = -1;
            }
            return dirty;
        }
        return -1;
    }

    const globals = (typeof window !== 'undefined'
        ? window
        : typeof globalThis !== 'undefined'
            ? globalThis
            : global);
    function append(target, node) {
        target.appendChild(node);
    }
    function insert(target, node, anchor) {
        target.insertBefore(node, anchor || null);
    }
    function detach(node) {
        if (node.parentNode) {
            node.parentNode.removeChild(node);
        }
    }
    function destroy_each(iterations, detaching) {
        for (let i = 0; i < iterations.length; i += 1) {
            if (iterations[i])
                iterations[i].d(detaching);
        }
    }
    function element(name) {
        return document.createElement(name);
    }
    function svg_element(name) {
        return document.createElementNS('http://www.w3.org/2000/svg', name);
    }
    function text(data) {
        return document.createTextNode(data);
    }
    function space() {
        return text(' ');
    }
    function empty() {
        return text('');
    }
    function listen(node, event, handler, options) {
        node.addEventListener(event, handler, options);
        return () => node.removeEventListener(event, handler, options);
    }
    function attr(node, attribute, value) {
        if (value == null)
            node.removeAttribute(attribute);
        else if (node.getAttribute(attribute) !== value)
            node.setAttribute(attribute, value);
    }
    function children(element) {
        return Array.from(element.childNodes);
    }
    function set_style(node, key, value, important) {
        if (value == null) {
            node.style.removeProperty(key);
        }
        else {
            node.style.setProperty(key, value, important ? 'important' : '');
        }
    }
    function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
        const e = document.createEvent('CustomEvent');
        e.initCustomEvent(type, bubbles, cancelable, detail);
        return e;
    }

    let current_component;
    function set_current_component(component) {
        current_component = component;
    }
    function get_current_component() {
        if (!current_component)
            throw new Error('Function called outside component initialization');
        return current_component;
    }
    /**
     * The `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM.
     * It must be called during the component's initialisation (but doesn't need to live *inside* the component;
     * it can be called from an external module).
     *
     * `onMount` does not run inside a [server-side component](/docs#run-time-server-side-component-api).
     *
     * https://svelte.dev/docs#run-time-svelte-onmount
     */
    function onMount(fn) {
        get_current_component().$$.on_mount.push(fn);
    }
    /**
     * Schedules a callback to run immediately after the component has been updated.
     *
     * The first time the callback runs will be after the initial `onMount`
     */
    function afterUpdate(fn) {
        get_current_component().$$.after_update.push(fn);
    }
    /**
     * Schedules a callback to run immediately before the component is unmounted.
     *
     * Out of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the
     * only one that runs inside a server-side component.
     *
     * https://svelte.dev/docs#run-time-svelte-ondestroy
     */
    function onDestroy(fn) {
        get_current_component().$$.on_destroy.push(fn);
    }
    /**
     * Creates an event dispatcher that can be used to dispatch [component events](/docs#template-syntax-component-directives-on-eventname).
     * Event dispatchers are functions that can take two arguments: `name` and `detail`.
     *
     * Component events created with `createEventDispatcher` create a
     * [CustomEvent](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent).
     * These events do not [bubble](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture).
     * The `detail` argument corresponds to the [CustomEvent.detail](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/detail)
     * property and can contain any type of data.
     *
     * https://svelte.dev/docs#run-time-svelte-createeventdispatcher
     */
    function createEventDispatcher() {
        const component = get_current_component();
        return (type, detail, { cancelable = false } = {}) => {
            const callbacks = component.$$.callbacks[type];
            if (callbacks) {
                // TODO are there situations where events could be dispatched
                // in a server (non-DOM) environment?
                const event = custom_event(type, detail, { cancelable });
                callbacks.slice().forEach(fn => {
                    fn.call(component, event);
                });
                return !event.defaultPrevented;
            }
            return true;
        };
    }
    // TODO figure out if we still want to support
    // shorthand events, or if we want to implement
    // a real bubbling mechanism
    function bubble(component, event) {
        const callbacks = component.$$.callbacks[event.type];
        if (callbacks) {
            // @ts-ignore
            callbacks.slice().forEach(fn => fn.call(this, event));
        }
    }

    const dirty_components = [];
    const binding_callbacks = [];
    let render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = /* @__PURE__ */ Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
        }
    }
    function tick() {
        schedule_update();
        return resolved_promise;
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    // flush() calls callbacks in this order:
    // 1. All beforeUpdate callbacks, in order: parents before children
    // 2. All bind:this callbacks, in reverse order: children before parents.
    // 3. All afterUpdate callbacks, in order: parents before children. EXCEPT
    //    for afterUpdates called during the initial onMount, which are called in
    //    reverse order: children before parents.
    // Since callbacks might update component values, which could trigger another
    // call to flush(), the following steps guard against this:
    // 1. During beforeUpdate, any updated components will be added to the
    //    dirty_components array and will cause a reentrant call to flush(). Because
    //    the flush index is kept outside the function, the reentrant call will pick
    //    up where the earlier call left off and go through all dirty components. The
    //    current_component value is saved and restored so that the reentrant call will
    //    not interfere with the "parent" flush() call.
    // 2. bind:this callbacks cannot trigger new flush() calls.
    // 3. During afterUpdate, any updated components will NOT have their afterUpdate
    //    callback called a second time; the seen_callbacks set, outside the flush()
    //    function, guarantees this behavior.
    const seen_callbacks = new Set();
    let flushidx = 0; // Do *not* move this inside the flush() function
    function flush() {
        // Do not reenter flush while dirty components are updated, as this can
        // result in an infinite loop. Instead, let the inner flush handle it.
        // Reentrancy is ok afterwards for bindings etc.
        if (flushidx !== 0) {
            return;
        }
        const saved_component = current_component;
        do {
            // first, call beforeUpdate functions
            // and update components
            try {
                while (flushidx < dirty_components.length) {
                    const component = dirty_components[flushidx];
                    flushidx++;
                    set_current_component(component);
                    update(component.$$);
                }
            }
            catch (e) {
                // reset dirty state to not end up in a deadlocked state and then rethrow
                dirty_components.length = 0;
                flushidx = 0;
                throw e;
            }
            set_current_component(null);
            dirty_components.length = 0;
            flushidx = 0;
            while (binding_callbacks.length)
                binding_callbacks.pop()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (let i = 0; i < render_callbacks.length; i += 1) {
                const callback = render_callbacks[i];
                if (!seen_callbacks.has(callback)) {
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                    callback();
                }
            }
            render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
        seen_callbacks.clear();
        set_current_component(saved_component);
    }
    function update($$) {
        if ($$.fragment !== null) {
            $$.update();
            run_all($$.before_update);
            const dirty = $$.dirty;
            $$.dirty = [-1];
            $$.fragment && $$.fragment.p($$.ctx, dirty);
            $$.after_update.forEach(add_render_callback);
        }
    }
    /**
     * Useful for example to execute remaining `afterUpdate` callbacks before executing `destroy`.
     */
    function flush_render_callbacks(fns) {
        const filtered = [];
        const targets = [];
        render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));
        targets.forEach((c) => c());
        render_callbacks = filtered;
    }
    const outroing = new Set();
    let outros;
    function group_outros() {
        outros = {
            r: 0,
            c: [],
            p: outros // parent group
        };
    }
    function check_outros() {
        if (!outros.r) {
            run_all(outros.c);
        }
        outros = outros.p;
    }
    function transition_in(block, local) {
        if (block && block.i) {
            outroing.delete(block);
            block.i(local);
        }
    }
    function transition_out(block, local, detach, callback) {
        if (block && block.o) {
            if (outroing.has(block))
                return;
            outroing.add(block);
            outros.c.push(() => {
                outroing.delete(block);
                if (callback) {
                    if (detach)
                        block.d(1);
                    callback();
                }
            });
            block.o(local);
        }
        else if (callback) {
            callback();
        }
    }

    function get_spread_update(levels, updates) {
        const update = {};
        const to_null_out = {};
        const accounted_for = { $$scope: 1 };
        let i = levels.length;
        while (i--) {
            const o = levels[i];
            const n = updates[i];
            if (n) {
                for (const key in o) {
                    if (!(key in n))
                        to_null_out[key] = 1;
                }
                for (const key in n) {
                    if (!accounted_for[key]) {
                        update[key] = n[key];
                        accounted_for[key] = 1;
                    }
                }
                levels[i] = n;
            }
            else {
                for (const key in o) {
                    accounted_for[key] = 1;
                }
            }
        }
        for (const key in to_null_out) {
            if (!(key in update))
                update[key] = undefined;
        }
        return update;
    }
    function get_spread_object(spread_props) {
        return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};
    }
    function create_component(block) {
        block && block.c();
    }
    function mount_component(component, target, anchor, customElement) {
        const { fragment, after_update } = component.$$;
        fragment && fragment.m(target, anchor);
        if (!customElement) {
            // onMount happens before the initial afterUpdate
            add_render_callback(() => {
                const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
                // if the component was destroyed immediately
                // it will update the `$$.on_destroy` reference to `null`.
                // the destructured on_destroy may still reference to the old array
                if (component.$$.on_destroy) {
                    component.$$.on_destroy.push(...new_on_destroy);
                }
                else {
                    // Edge case - component was destroyed immediately,
                    // most likely as a result of a binding initialising
                    run_all(new_on_destroy);
                }
                component.$$.on_mount = [];
            });
        }
        after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
        const $$ = component.$$;
        if ($$.fragment !== null) {
            flush_render_callbacks($$.after_update);
            run_all($$.on_destroy);
            $$.fragment && $$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            $$.on_destroy = $$.fragment = null;
            $$.ctx = [];
        }
    }
    function make_dirty(component, i) {
        if (component.$$.dirty[0] === -1) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty.fill(0);
        }
        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
    }
    function init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {
        const parent_component = current_component;
        set_current_component(component);
        const $$ = component.$$ = {
            fragment: null,
            ctx: [],
            // state
            props,
            update: noop$1,
            not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            on_disconnect: [],
            before_update: [],
            after_update: [],
            context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
            // everything else
            callbacks: blank_object(),
            dirty,
            skip_bound: false,
            root: options.target || parent_component.$$.root
        };
        append_styles && append_styles($$.root);
        let ready = false;
        $$.ctx = instance
            ? instance(component, options.props || {}, (i, ret, ...rest) => {
                const value = rest.length ? rest[0] : ret;
                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                    if (!$$.skip_bound && $$.bound[i])
                        $$.bound[i](value);
                    if (ready)
                        make_dirty(component, i);
                }
                return ret;
            })
            : [];
        $$.update();
        ready = true;
        run_all($$.before_update);
        // `false` as a special case of no DOM component
        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
        if (options.target) {
            if (options.hydrate) {
                const nodes = children(options.target);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.l(nodes);
                nodes.forEach(detach);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.c();
            }
            if (options.intro)
                transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor, options.customElement);
            flush();
        }
        set_current_component(parent_component);
    }
    /**
     * Base class for Svelte components. Used when dev=false.
     */
    class SvelteComponent {
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop$1;
        }
        $on(type, callback) {
            if (!is_function(callback)) {
                return noop$1;
            }
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set($$props) {
            if (this.$$set && !is_empty($$props)) {
                this.$$.skip_bound = true;
                this.$$set($$props);
                this.$$.skip_bound = false;
            }
        }
    }

    function dispatch_dev(type, detail) {
        document.dispatchEvent(custom_event(type, Object.assign({ version: '3.59.2' }, detail), { bubbles: true }));
    }
    function append_dev(target, node) {
        dispatch_dev('SvelteDOMInsert', { target, node });
        append(target, node);
    }
    function insert_dev(target, node, anchor) {
        dispatch_dev('SvelteDOMInsert', { target, node, anchor });
        insert(target, node, anchor);
    }
    function detach_dev(node) {
        dispatch_dev('SvelteDOMRemove', { node });
        detach(node);
    }
    function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation, has_stop_immediate_propagation) {
        const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];
        if (has_prevent_default)
            modifiers.push('preventDefault');
        if (has_stop_propagation)
            modifiers.push('stopPropagation');
        if (has_stop_immediate_propagation)
            modifiers.push('stopImmediatePropagation');
        dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });
        const dispose = listen(node, event, handler, options);
        return () => {
            dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });
            dispose();
        };
    }
    function attr_dev(node, attribute, value) {
        attr(node, attribute, value);
        if (value == null)
            dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });
        else
            dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });
    }
    function prop_dev(node, property, value) {
        node[property] = value;
        dispatch_dev('SvelteDOMSetProperty', { node, property, value });
    }
    function set_data_dev(text, data) {
        data = '' + data;
        if (text.data === data)
            return;
        dispatch_dev('SvelteDOMSetData', { node: text, data });
        text.data = data;
    }
    function validate_each_argument(arg) {
        if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {
            let msg = '{#each} only iterates over array-like objects.';
            if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
                msg += ' You can use a spread to convert this iterable into an array.';
            }
            throw new Error(msg);
        }
    }
    function validate_slots(name, slot, keys) {
        for (const slot_key of Object.keys(slot)) {
            if (!~keys.indexOf(slot_key)) {
                console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
            }
        }
    }
    function construct_svelte_component_dev(component, props) {
        const error_message = 'this={...} of <svelte:component> should specify a Svelte component.';
        try {
            const instance = new component(props);
            if (!instance.$$ || !instance.$set || !instance.$on || !instance.$destroy) {
                throw new Error(error_message);
            }
            return instance;
        }
        catch (err) {
            const { message } = err;
            if (typeof message === 'string' && message.indexOf('is not a constructor') !== -1) {
                throw new Error(error_message);
            }
            else {
                throw err;
            }
        }
    }
    /**
     * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.
     */
    class SvelteComponentDev extends SvelteComponent {
        constructor(options) {
            if (!options || (!options.target && !options.$$inline)) {
                throw new Error("'target' is a required option");
            }
            super();
        }
        $destroy() {
            super.$destroy();
            this.$destroy = () => {
                console.warn('Component was already destroyed'); // eslint-disable-line no-console
            };
        }
        $capture_state() { }
        $inject_state() { }
    }

    /******************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise, SuppressedError, Symbol, Iterator */


    function __classPrivateFieldGet(receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    }

    typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
        var e = new Error(message);
        return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    };

    var _a, _UserContext_handlers;
    class UserContext {
        static addEventListener(event, handler) {
            __classPrivateFieldGet(UserContext, _a, "f", _UserContext_handlers).push(handler);
        }
        static authChanged(loggedIn) {
            __classPrivateFieldGet(UserContext, _a, "f", _UserContext_handlers).forEach(x => x(loggedIn));
        }
        constructor() {
            this._token = localStorage.getItem("token");
            const credentials = JSON.parse(localStorage.getItem("credentials"));
            if (credentials) {
                this._name = credentials.name;
                this._role = credentials.role;
                UserContext.authChanged(true);
            }
        }
        setAuth(credentials) {
            this._token = credentials.token;
            this._name = credentials.name;
            this._role = credentials.role;
            localStorage.setItem("token", this._token);
            localStorage.setItem("credentials", JSON.stringify({
                name: credentials.name,
                role: credentials.role
            }));
            UserContext.authChanged(true);
        }
        clear() {
            localStorage.removeItem("token");
            localStorage.removeItem("credentials");
            this._token = null;
            this._name = '';
            this._role = '';
            UserContext.authChanged(false);
        }
        isAuth() {
            return !!(this._name && this._token && this._role);
        }
        name() {
            return this._name;
        }
        token() {
            return this._token;
        }
        role() {
            return this._role;
        }
        isAdmin() {
            return this._role === "Admin";
        }
    }
    _a = UserContext;
    _UserContext_handlers = { value: [] };

    /* src\Components\Navigation\Navigation.svelte generated by Svelte v3.59.2 */
    const file$n = "src\\Components\\Navigation\\Navigation.svelte";

    // (54:16) {:else}
    function create_else_block$6(ctx) {
    	let a;

    	const block = {
    		c: function create() {
    			a = element("a");
    			a.textContent = "Inloggen";
    			attr_dev(a, "href", "/#/account/login");
    			attr_dev(a, "class", "text-xl md:text-base font-normal text-gray-500 list-none hover:text-gray-900");
    			add_location(a, file$n, 54, 20, 2061);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    		},
    		p: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$6.name,
    		type: "else",
    		source: "(54:16) {:else}",
    		ctx
    	});

    	return block;
    }

    // (40:16) {#if isLoggedIn}
    function create_if_block$8(ctx) {
    	let a0;
    	let t1;
    	let a1;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			a0 = element("a");
    			a0.textContent = "Uw planten";
    			t1 = space();
    			a1 = element("a");
    			a1.textContent = "Uitloggen";
    			attr_dev(a0, "href", "/#/plants/");
    			attr_dev(a0, "class", "text-xl md:text-base font-normal text-gray-500 list-none hover:text-gray-900");
    			add_location(a0, file$n, 40, 20, 1479);
    			attr_dev(a1, "href", "/");
    			attr_dev(a1, "class", "text-xl md:text-base font-normal text-gray-500 list-none hover:text-gray-900");
    			add_location(a1, file$n, 46, 20, 1741);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, a1, anchor);

    			if (!mounted) {
    				dispose = listen_dev(a1, "click", /*logOut*/ ctx[1], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(a1);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$8.name,
    		type: "if",
    		source: "(40:16) {#if isLoggedIn}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$p(ctx) {
    	let div3;
    	let div2;
    	let nav;
    	let div0;
    	let a0;
    	let img;
    	let img_src_value;
    	let t0;
    	let div1;
    	let a1;
    	let t2;
    	let a2;
    	let t4;

    	function select_block_type(ctx, dirty) {
    		if (/*isLoggedIn*/ ctx[0]) return create_if_block$8;
    		return create_else_block$6;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div2 = element("div");
    			nav = element("nav");
    			div0 = element("div");
    			a0 = element("a");
    			img = element("img");
    			t0 = space();
    			div1 = element("div");
    			a1 = element("a");
    			a1.textContent = "Over mij";
    			t2 = space();
    			a2 = element("a");
    			a2.textContent = "Contact";
    			t4 = space();
    			if_block.c();
    			attr_dev(img, "alt", "AI gegenereerd logo voor Sil Gosker");
    			attr_dev(img, "class", "w-auto h-8 md:h-16");
    			if (!src_url_equal(img.src, img_src_value = "/images/logo_original.webp")) attr_dev(img, "src", img_src_value);
    			add_location(img, file$n, 19, 20, 622);
    			attr_dev(a0, "href", "/");
    			add_location(a0, file$n, 18, 16, 588);
    			attr_dev(div0, "class", "mr-6 flex items-center self-start");
    			add_location(div0, file$n, 17, 12, 523);
    			attr_dev(a1, "href", "/");
    			attr_dev(a1, "class", "text-xl md:text-base font-normal text-gray-500 list-none hover:text-gray-900");
    			add_location(a1, file$n, 27, 16, 979);
    			attr_dev(a2, "href", "/#/contact");
    			attr_dev(a2, "class", "text-xl md:text-base font-normal text-gray-500 list-none hover:text-gray-900");
    			add_location(a2, file$n, 33, 16, 1206);
    			attr_dev(div1, "class", "md:px-24 flex flex-wrap justify-around md:justify-between w-full");
    			add_location(div1, file$n, 26, 12, 883);
    			attr_dev(nav, "class", "relative flex items-center content-center justify-between");
    			attr_dev(nav, "aria-label", "Global");
    			add_location(nav, file$n, 13, 8, 382);
    			attr_dev(div2, "class", "relative pt-6 pb-8");
    			add_location(div2, file$n, 12, 4, 340);
    			attr_dev(div3, "class", "px-4 mx-auto sm:px-6");
    			add_location(div3, file$n, 11, 0, 300);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div2);
    			append_dev(div2, nav);
    			append_dev(nav, div0);
    			append_dev(div0, a0);
    			append_dev(a0, img);
    			append_dev(nav, t0);
    			append_dev(nav, div1);
    			append_dev(div1, a1);
    			append_dev(div1, t2);
    			append_dev(div1, a2);
    			append_dev(div1, t4);
    			if_block.m(div1, null);
    		},
    		p: function update(ctx, [dirty]) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div1, null);
    				}
    			}
    		},
    		i: noop$1,
    		o: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$p.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$p($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Navigation', slots, []);
    	let isLoggedIn = false;

    	UserContext.addEventListener("authChanged", loggedIn => {
    		$$invalidate(0, isLoggedIn = loggedIn);
    	});

    	const userContext = new UserContext();

    	function logOut() {
    		userContext.clear();
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Navigation> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		UserContext,
    		isLoggedIn,
    		userContext,
    		logOut
    	});

    	$$self.$inject_state = $$props => {
    		if ('isLoggedIn' in $$props) $$invalidate(0, isLoggedIn = $$props.isLoggedIn);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [isLoggedIn, logOut];
    }

    class Navigation extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$p, create_fragment$p, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Navigation",
    			options,
    			id: create_fragment$p.name
    		});
    	}
    }

    const subscriber_queue = [];
    /**
     * Creates a `Readable` store that allows reading by subscription.
     * @param value initial value
     * @param {StartStopNotifier} [start]
     */
    function readable(value, start) {
        return {
            subscribe: writable(value, start).subscribe
        };
    }
    /**
     * Create a `Writable` store that allows both updating and reading by subscription.
     * @param {*=}value initial value
     * @param {StartStopNotifier=} start
     */
    function writable(value, start = noop$1) {
        let stop;
        const subscribers = new Set();
        function set(new_value) {
            if (safe_not_equal(value, new_value)) {
                value = new_value;
                if (stop) { // store is ready
                    const run_queue = !subscriber_queue.length;
                    for (const subscriber of subscribers) {
                        subscriber[1]();
                        subscriber_queue.push(subscriber, value);
                    }
                    if (run_queue) {
                        for (let i = 0; i < subscriber_queue.length; i += 2) {
                            subscriber_queue[i][0](subscriber_queue[i + 1]);
                        }
                        subscriber_queue.length = 0;
                    }
                }
            }
        }
        function update(fn) {
            set(fn(value));
        }
        function subscribe(run, invalidate = noop$1) {
            const subscriber = [run, invalidate];
            subscribers.add(subscriber);
            if (subscribers.size === 1) {
                stop = start(set) || noop$1;
            }
            run(value);
            return () => {
                subscribers.delete(subscriber);
                if (subscribers.size === 0 && stop) {
                    stop();
                    stop = null;
                }
            };
        }
        return { set, update, subscribe };
    }
    function derived(stores, fn, initial_value) {
        const single = !Array.isArray(stores);
        const stores_array = single
            ? [stores]
            : stores;
        const auto = fn.length < 2;
        return readable(initial_value, (set) => {
            let started = false;
            const values = [];
            let pending = 0;
            let cleanup = noop$1;
            const sync = () => {
                if (pending) {
                    return;
                }
                cleanup();
                const result = fn(single ? values[0] : values, set);
                if (auto) {
                    set(result);
                }
                else {
                    cleanup = is_function(result) ? result : noop$1;
                }
            };
            const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {
                values[i] = value;
                pending &= ~(1 << i);
                if (started) {
                    sync();
                }
            }, () => {
                pending |= (1 << i);
            }));
            started = true;
            sync();
            return function stop() {
                run_all(unsubscribers);
                cleanup();
                // We need to set this to false because callbacks can still happen despite having unsubscribed:
                // Callbacks might already be placed in the queue which doesn't know it should no longer
                // invoke this derived store.
                started = false;
            };
        });
    }

    function parse$1(str, loose) {
    	if (str instanceof RegExp) return { keys:false, pattern:str };
    	var c, o, tmp, ext, keys=[], pattern='', arr = str.split('/');
    	arr[0] || arr.shift();

    	while (tmp = arr.shift()) {
    		c = tmp[0];
    		if (c === '*') {
    			keys.push('wild');
    			pattern += '/(.*)';
    		} else if (c === ':') {
    			o = tmp.indexOf('?', 1);
    			ext = tmp.indexOf('.', 1);
    			keys.push( tmp.substring(1, !!~o ? o : !!~ext ? ext : tmp.length) );
    			pattern += !!~o && !~ext ? '(?:/([^/]+?))?' : '/([^/]+?)';
    			if (!!~ext) pattern += (!!~o ? '?' : '') + '\\' + tmp.substring(ext);
    		} else {
    			pattern += '/' + tmp;
    		}
    	}

    	return {
    		keys: keys,
    		pattern: new RegExp('^' + pattern + (loose ? '(?=$|\/)' : '\/?$'), 'i')
    	};
    }

    /* node_modules\svelte-spa-router\Router.svelte generated by Svelte v3.59.2 */

    const { Error: Error_1, Object: Object_1$1, console: console_1$1 } = globals;

    // (246:0) {:else}
    function create_else_block$5(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	const switch_instance_spread_levels = [/*props*/ ctx[2]];
    	var switch_value = /*component*/ ctx[0];

    	function switch_props(ctx) {
    		let switch_instance_props = {};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props());
    		switch_instance.$on("routeEvent", /*routeEvent_handler_1*/ ctx[7]);
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = (dirty & /*props*/ 4)
    			? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*props*/ ctx[2])])
    			: {};

    			if (dirty & /*component*/ 1 && switch_value !== (switch_value = /*component*/ ctx[0])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props());
    					switch_instance.$on("routeEvent", /*routeEvent_handler_1*/ ctx[7]);
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$5.name,
    		type: "else",
    		source: "(246:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (239:0) {#if componentParams}
    function create_if_block$7(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	const switch_instance_spread_levels = [{ params: /*componentParams*/ ctx[1] }, /*props*/ ctx[2]];
    	var switch_value = /*component*/ ctx[0];

    	function switch_props(ctx) {
    		let switch_instance_props = {};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props());
    		switch_instance.$on("routeEvent", /*routeEvent_handler*/ ctx[6]);
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = (dirty & /*componentParams, props*/ 6)
    			? get_spread_update(switch_instance_spread_levels, [
    					dirty & /*componentParams*/ 2 && { params: /*componentParams*/ ctx[1] },
    					dirty & /*props*/ 4 && get_spread_object(/*props*/ ctx[2])
    				])
    			: {};

    			if (dirty & /*component*/ 1 && switch_value !== (switch_value = /*component*/ ctx[0])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props());
    					switch_instance.$on("routeEvent", /*routeEvent_handler*/ ctx[6]);
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$7.name,
    		type: "if",
    		source: "(239:0) {#if componentParams}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$o(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$7, create_else_block$5];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*componentParams*/ ctx[1]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error_1("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$o.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function getLocation() {
    	const hashPosition = window.location.href.indexOf('#/');

    	let location = hashPosition > -1
    	? window.location.href.substr(hashPosition + 1)
    	: '/';

    	// Check if there's a querystring
    	const qsPosition = location.indexOf('?');

    	let querystring = '';

    	if (qsPosition > -1) {
    		querystring = location.substr(qsPosition + 1);
    		location = location.substr(0, qsPosition);
    	}

    	return { location, querystring };
    }

    const loc = readable(null, // eslint-disable-next-line prefer-arrow-callback
    function start(set) {
    	set(getLocation());

    	const update = () => {
    		set(getLocation());
    	};

    	window.addEventListener('hashchange', update, false);

    	return function stop() {
    		window.removeEventListener('hashchange', update, false);
    	};
    });

    const location$1 = derived(loc, _loc => _loc.location);
    const querystring = derived(loc, _loc => _loc.querystring);
    const params = writable(undefined);

    async function push(location) {
    	if (!location || location.length < 1 || location.charAt(0) != '/' && location.indexOf('#/') !== 0) {
    		throw Error('Invalid parameter location');
    	}

    	// Execute this code when the current call stack is complete
    	await tick();

    	// Note: this will include scroll state in history even when restoreScrollState is false
    	history.replaceState(
    		{
    			...history.state,
    			__svelte_spa_router_scrollX: window.scrollX,
    			__svelte_spa_router_scrollY: window.scrollY
    		},
    		undefined
    	);

    	window.location.hash = (location.charAt(0) == '#' ? '' : '#') + location;
    }

    async function pop() {
    	// Execute this code when the current call stack is complete
    	await tick();

    	window.history.back();
    }

    async function replace(location) {
    	if (!location || location.length < 1 || location.charAt(0) != '/' && location.indexOf('#/') !== 0) {
    		throw Error('Invalid parameter location');
    	}

    	// Execute this code when the current call stack is complete
    	await tick();

    	const dest = (location.charAt(0) == '#' ? '' : '#') + location;

    	try {
    		const newState = { ...history.state };
    		delete newState['__svelte_spa_router_scrollX'];
    		delete newState['__svelte_spa_router_scrollY'];
    		window.history.replaceState(newState, undefined, dest);
    	} catch(e) {
    		// eslint-disable-next-line no-console
    		console.warn('Caught exception while replacing the current page. If you\'re running this in the Svelte REPL, please note that the `replace` method might not work in this environment.');
    	}

    	// The method above doesn't trigger the hashchange event, so let's do that manually
    	window.dispatchEvent(new Event('hashchange'));
    }

    function link(node, opts) {
    	opts = linkOpts(opts);

    	// Only apply to <a> tags
    	if (!node || !node.tagName || node.tagName.toLowerCase() != 'a') {
    		throw Error('Action "link" can only be used with <a> tags');
    	}

    	updateLink(node, opts);

    	return {
    		update(updated) {
    			updated = linkOpts(updated);
    			updateLink(node, updated);
    		}
    	};
    }

    function restoreScroll(state) {
    	// If this exists, then this is a back navigation: restore the scroll position
    	if (state) {
    		window.scrollTo(state.__svelte_spa_router_scrollX, state.__svelte_spa_router_scrollY);
    	} else {
    		// Otherwise this is a forward navigation: scroll to top
    		window.scrollTo(0, 0);
    	}
    }

    // Internal function used by the link function
    function updateLink(node, opts) {
    	let href = opts.href || node.getAttribute('href');

    	// Destination must start with '/' or '#/'
    	if (href && href.charAt(0) == '/') {
    		// Add # to the href attribute
    		href = '#' + href;
    	} else if (!href || href.length < 2 || href.slice(0, 2) != '#/') {
    		throw Error('Invalid value for "href" attribute: ' + href);
    	}

    	node.setAttribute('href', href);

    	node.addEventListener('click', event => {
    		// Prevent default anchor onclick behaviour
    		event.preventDefault();

    		if (!opts.disabled) {
    			scrollstateHistoryHandler(event.currentTarget.getAttribute('href'));
    		}
    	});
    }

    // Internal function that ensures the argument of the link action is always an object
    function linkOpts(val) {
    	if (val && typeof val == 'string') {
    		return { href: val };
    	} else {
    		return val || {};
    	}
    }

    /**
     * The handler attached to an anchor tag responsible for updating the
     * current history state with the current scroll state
     *
     * @param {string} href - Destination
     */
    function scrollstateHistoryHandler(href) {
    	// Setting the url (3rd arg) to href will break clicking for reasons, so don't try to do that
    	history.replaceState(
    		{
    			...history.state,
    			__svelte_spa_router_scrollX: window.scrollX,
    			__svelte_spa_router_scrollY: window.scrollY
    		},
    		undefined
    	);

    	// This will force an update as desired, but this time our scroll state will be attached
    	window.location.hash = href;
    }

    function instance$o($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Router', slots, []);
    	let { routes = {} } = $$props;
    	let { prefix = '' } = $$props;
    	let { restoreScrollState = false } = $$props;

    	/**
     * Container for a route: path, component
     */
    	class RouteItem {
    		/**
     * Initializes the object and creates a regular expression from the path, using regexparam.
     *
     * @param {string} path - Path to the route (must start with '/' or '*')
     * @param {SvelteComponent|WrappedComponent} component - Svelte component for the route, optionally wrapped
     */
    		constructor(path, component) {
    			if (!component || typeof component != 'function' && (typeof component != 'object' || component._sveltesparouter !== true)) {
    				throw Error('Invalid component object');
    			}

    			// Path must be a regular or expression, or a string starting with '/' or '*'
    			if (!path || typeof path == 'string' && (path.length < 1 || path.charAt(0) != '/' && path.charAt(0) != '*') || typeof path == 'object' && !(path instanceof RegExp)) {
    				throw Error('Invalid value for "path" argument - strings must start with / or *');
    			}

    			const { pattern, keys } = parse$1(path);
    			this.path = path;

    			// Check if the component is wrapped and we have conditions
    			if (typeof component == 'object' && component._sveltesparouter === true) {
    				this.component = component.component;
    				this.conditions = component.conditions || [];
    				this.userData = component.userData;
    				this.props = component.props || {};
    			} else {
    				// Convert the component to a function that returns a Promise, to normalize it
    				this.component = () => Promise.resolve(component);

    				this.conditions = [];
    				this.props = {};
    			}

    			this._pattern = pattern;
    			this._keys = keys;
    		}

    		/**
     * Checks if `path` matches the current route.
     * If there's a match, will return the list of parameters from the URL (if any).
     * In case of no match, the method will return `null`.
     *
     * @param {string} path - Path to test
     * @returns {null|Object.<string, string>} List of paramters from the URL if there's a match, or `null` otherwise.
     */
    		match(path) {
    			// If there's a prefix, check if it matches the start of the path.
    			// If not, bail early, else remove it before we run the matching.
    			if (prefix) {
    				if (typeof prefix == 'string') {
    					if (path.startsWith(prefix)) {
    						path = path.substr(prefix.length) || '/';
    					} else {
    						return null;
    					}
    				} else if (prefix instanceof RegExp) {
    					const match = path.match(prefix);

    					if (match && match[0]) {
    						path = path.substr(match[0].length) || '/';
    					} else {
    						return null;
    					}
    				}
    			}

    			// Check if the pattern matches
    			const matches = this._pattern.exec(path);

    			if (matches === null) {
    				return null;
    			}

    			// If the input was a regular expression, this._keys would be false, so return matches as is
    			if (this._keys === false) {
    				return matches;
    			}

    			const out = {};
    			let i = 0;

    			while (i < this._keys.length) {
    				// In the match parameters, URL-decode all values
    				try {
    					out[this._keys[i]] = decodeURIComponent(matches[i + 1] || '') || null;
    				} catch(e) {
    					out[this._keys[i]] = null;
    				}

    				i++;
    			}

    			return out;
    		}

    		/**
     * Dictionary with route details passed to the pre-conditions functions, as well as the `routeLoading`, `routeLoaded` and `conditionsFailed` events
     * @typedef {Object} RouteDetail
     * @property {string|RegExp} route - Route matched as defined in the route definition (could be a string or a reguar expression object)
     * @property {string} location - Location path
     * @property {string} querystring - Querystring from the hash
     * @property {object} [userData] - Custom data passed by the user
     * @property {SvelteComponent} [component] - Svelte component (only in `routeLoaded` events)
     * @property {string} [name] - Name of the Svelte component (only in `routeLoaded` events)
     */
    		/**
     * Executes all conditions (if any) to control whether the route can be shown. Conditions are executed in the order they are defined, and if a condition fails, the following ones aren't executed.
     * 
     * @param {RouteDetail} detail - Route detail
     * @returns {boolean} Returns true if all the conditions succeeded
     */
    		async checkConditions(detail) {
    			for (let i = 0; i < this.conditions.length; i++) {
    				if (!await this.conditions[i](detail)) {
    					return false;
    				}
    			}

    			return true;
    		}
    	}

    	// Set up all routes
    	const routesList = [];

    	if (routes instanceof Map) {
    		// If it's a map, iterate on it right away
    		routes.forEach((route, path) => {
    			routesList.push(new RouteItem(path, route));
    		});
    	} else {
    		// We have an object, so iterate on its own properties
    		Object.keys(routes).forEach(path => {
    			routesList.push(new RouteItem(path, routes[path]));
    		});
    	}

    	// Props for the component to render
    	let component = null;

    	let componentParams = null;
    	let props = {};

    	// Event dispatcher from Svelte
    	const dispatch = createEventDispatcher();

    	// Just like dispatch, but executes on the next iteration of the event loop
    	async function dispatchNextTick(name, detail) {
    		// Execute this code when the current call stack is complete
    		await tick();

    		dispatch(name, detail);
    	}

    	// If this is set, then that means we have popped into this var the state of our last scroll position
    	let previousScrollState = null;

    	let popStateChanged = null;

    	if (restoreScrollState) {
    		popStateChanged = event => {
    			// If this event was from our history.replaceState, event.state will contain
    			// our scroll history. Otherwise, event.state will be null (like on forward
    			// navigation)
    			if (event.state && (event.state.__svelte_spa_router_scrollY || event.state.__svelte_spa_router_scrollX)) {
    				previousScrollState = event.state;
    			} else {
    				previousScrollState = null;
    			}
    		};

    		// This is removed in the destroy() invocation below
    		window.addEventListener('popstate', popStateChanged);

    		afterUpdate(() => {
    			restoreScroll(previousScrollState);
    		});
    	}

    	// Always have the latest value of loc
    	let lastLoc = null;

    	// Current object of the component loaded
    	let componentObj = null;

    	// Handle hash change events
    	// Listen to changes in the $loc store and update the page
    	// Do not use the $: syntax because it gets triggered by too many things
    	const unsubscribeLoc = loc.subscribe(async newLoc => {
    		lastLoc = newLoc;

    		// Find a route matching the location
    		let i = 0;

    		while (i < routesList.length) {
    			const match = routesList[i].match(newLoc.location);

    			if (!match) {
    				i++;
    				continue;
    			}

    			const detail = {
    				route: routesList[i].path,
    				location: newLoc.location,
    				querystring: newLoc.querystring,
    				userData: routesList[i].userData,
    				params: match && typeof match == 'object' && Object.keys(match).length
    				? match
    				: null
    			};

    			// Check if the route can be loaded - if all conditions succeed
    			if (!await routesList[i].checkConditions(detail)) {
    				// Don't display anything
    				$$invalidate(0, component = null);

    				componentObj = null;

    				// Trigger an event to notify the user, then exit
    				dispatchNextTick('conditionsFailed', detail);

    				return;
    			}

    			// Trigger an event to alert that we're loading the route
    			// We need to clone the object on every event invocation so we don't risk the object to be modified in the next tick
    			dispatchNextTick('routeLoading', Object.assign({}, detail));

    			// If there's a component to show while we're loading the route, display it
    			const obj = routesList[i].component;

    			// Do not replace the component if we're loading the same one as before, to avoid the route being unmounted and re-mounted
    			if (componentObj != obj) {
    				if (obj.loading) {
    					$$invalidate(0, component = obj.loading);
    					componentObj = obj;
    					$$invalidate(1, componentParams = obj.loadingParams);
    					$$invalidate(2, props = {});

    					// Trigger the routeLoaded event for the loading component
    					// Create a copy of detail so we don't modify the object for the dynamic route (and the dynamic route doesn't modify our object too)
    					dispatchNextTick('routeLoaded', Object.assign({}, detail, {
    						component,
    						name: component.name,
    						params: componentParams
    					}));
    				} else {
    					$$invalidate(0, component = null);
    					componentObj = null;
    				}

    				// Invoke the Promise
    				const loaded = await obj();

    				// Now that we're here, after the promise resolved, check if we still want this component, as the user might have navigated to another page in the meanwhile
    				if (newLoc != lastLoc) {
    					// Don't update the component, just exit
    					return;
    				}

    				// If there is a "default" property, which is used by async routes, then pick that
    				$$invalidate(0, component = loaded && loaded.default || loaded);

    				componentObj = obj;
    			}

    			// Set componentParams only if we have a match, to avoid a warning similar to `<Component> was created with unknown prop 'params'`
    			// Of course, this assumes that developers always add a "params" prop when they are expecting parameters
    			if (match && typeof match == 'object' && Object.keys(match).length) {
    				$$invalidate(1, componentParams = match);
    			} else {
    				$$invalidate(1, componentParams = null);
    			}

    			// Set static props, if any
    			$$invalidate(2, props = routesList[i].props);

    			// Dispatch the routeLoaded event then exit
    			// We need to clone the object on every event invocation so we don't risk the object to be modified in the next tick
    			dispatchNextTick('routeLoaded', Object.assign({}, detail, {
    				component,
    				name: component.name,
    				params: componentParams
    			})).then(() => {
    				params.set(componentParams);
    			});

    			return;
    		}

    		// If we're still here, there was no match, so show the empty component
    		$$invalidate(0, component = null);

    		componentObj = null;
    		params.set(undefined);
    	});

    	onDestroy(() => {
    		unsubscribeLoc();
    		popStateChanged && window.removeEventListener('popstate', popStateChanged);
    	});

    	const writable_props = ['routes', 'prefix', 'restoreScrollState'];

    	Object_1$1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$1.warn(`<Router> was created with unknown prop '${key}'`);
    	});

    	function routeEvent_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function routeEvent_handler_1(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$props => {
    		if ('routes' in $$props) $$invalidate(3, routes = $$props.routes);
    		if ('prefix' in $$props) $$invalidate(4, prefix = $$props.prefix);
    		if ('restoreScrollState' in $$props) $$invalidate(5, restoreScrollState = $$props.restoreScrollState);
    	};

    	$$self.$capture_state = () => ({
    		readable,
    		writable,
    		derived,
    		tick,
    		getLocation,
    		loc,
    		location: location$1,
    		querystring,
    		params,
    		push,
    		pop,
    		replace,
    		link,
    		restoreScroll,
    		updateLink,
    		linkOpts,
    		scrollstateHistoryHandler,
    		onDestroy,
    		createEventDispatcher,
    		afterUpdate,
    		parse: parse$1,
    		routes,
    		prefix,
    		restoreScrollState,
    		RouteItem,
    		routesList,
    		component,
    		componentParams,
    		props,
    		dispatch,
    		dispatchNextTick,
    		previousScrollState,
    		popStateChanged,
    		lastLoc,
    		componentObj,
    		unsubscribeLoc
    	});

    	$$self.$inject_state = $$props => {
    		if ('routes' in $$props) $$invalidate(3, routes = $$props.routes);
    		if ('prefix' in $$props) $$invalidate(4, prefix = $$props.prefix);
    		if ('restoreScrollState' in $$props) $$invalidate(5, restoreScrollState = $$props.restoreScrollState);
    		if ('component' in $$props) $$invalidate(0, component = $$props.component);
    		if ('componentParams' in $$props) $$invalidate(1, componentParams = $$props.componentParams);
    		if ('props' in $$props) $$invalidate(2, props = $$props.props);
    		if ('previousScrollState' in $$props) previousScrollState = $$props.previousScrollState;
    		if ('popStateChanged' in $$props) popStateChanged = $$props.popStateChanged;
    		if ('lastLoc' in $$props) lastLoc = $$props.lastLoc;
    		if ('componentObj' in $$props) componentObj = $$props.componentObj;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*restoreScrollState*/ 32) {
    			// Update history.scrollRestoration depending on restoreScrollState
    			history.scrollRestoration = restoreScrollState ? 'manual' : 'auto';
    		}
    	};

    	return [
    		component,
    		componentParams,
    		props,
    		routes,
    		prefix,
    		restoreScrollState,
    		routeEvent_handler,
    		routeEvent_handler_1
    	];
    }

    class Router extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$o, create_fragment$o, safe_not_equal, {
    			routes: 3,
    			prefix: 4,
    			restoreScrollState: 5
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Router",
    			options,
    			id: create_fragment$o.name
    		});
    	}

    	get routes() {
    		throw new Error_1("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set routes(value) {
    		throw new Error_1("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get prefix() {
    		throw new Error_1("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set prefix(value) {
    		throw new Error_1("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get restoreScrollState() {
    		throw new Error_1("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set restoreScrollState(value) {
    		throw new Error_1("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\Pages\NotFound.svelte generated by Svelte v3.59.2 */

    const file$m = "src\\Pages\\NotFound.svelte";

    function create_fragment$n(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "Pagina niet gevonden";
    			add_location(p, file$m, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		p: noop$1,
    		i: noop$1,
    		o: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$n.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$n($$self, $$props) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('NotFound', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<NotFound> was created with unknown prop '${key}'`);
    	});

    	return [];
    }

    class NotFound extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$n, create_fragment$n, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "NotFound",
    			options,
    			id: create_fragment$n.name
    		});
    	}
    }

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function getDefaultExportFromCjs (x) {
    	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
    }

    var sweetalert2_all = {exports: {}};

    /*!
    * sweetalert2 v11.16.0
    * Released under the MIT License.
    */

    (function (module, exports) {
    	(function (global, factory) {
    	  module.exports = factory() ;
    	})(commonjsGlobal, (function () {
    	  function _assertClassBrand(e, t, n) {
    	    if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;
    	    throw new TypeError("Private element is not present on this object");
    	  }
    	  function _checkPrivateRedeclaration(e, t) {
    	    if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object");
    	  }
    	  function _classPrivateFieldGet2(s, a) {
    	    return s.get(_assertClassBrand(s, a));
    	  }
    	  function _classPrivateFieldInitSpec(e, t, a) {
    	    _checkPrivateRedeclaration(e, t), t.set(e, a);
    	  }
    	  function _classPrivateFieldSet2(s, a, r) {
    	    return s.set(_assertClassBrand(s, a), r), r;
    	  }

    	  const RESTORE_FOCUS_TIMEOUT = 100;

    	  /** @type {GlobalState} */
    	  const globalState = {};
    	  const focusPreviousActiveElement = () => {
    	    if (globalState.previousActiveElement instanceof HTMLElement) {
    	      globalState.previousActiveElement.focus();
    	      globalState.previousActiveElement = null;
    	    } else if (document.body) {
    	      document.body.focus();
    	    }
    	  };

    	  /**
    	   * Restore previous active (focused) element
    	   *
    	   * @param {boolean} returnFocus
    	   * @returns {Promise<void>}
    	   */
    	  const restoreActiveElement = returnFocus => {
    	    return new Promise(resolve => {
    	      if (!returnFocus) {
    	        return resolve();
    	      }
    	      const x = window.scrollX;
    	      const y = window.scrollY;
    	      globalState.restoreFocusTimeout = setTimeout(() => {
    	        focusPreviousActiveElement();
    	        resolve();
    	      }, RESTORE_FOCUS_TIMEOUT); // issues/900

    	      window.scrollTo(x, y);
    	    });
    	  };

    	  const swalPrefix = 'swal2-';

    	  /**
    	   * @typedef {Record<SwalClass, string>} SwalClasses
    	   */

    	  /**
    	   * @typedef {'success' | 'warning' | 'info' | 'question' | 'error'} SwalIcon
    	   * @typedef {Record<SwalIcon, string>} SwalIcons
    	   */

    	  /** @type {SwalClass[]} */
    	  const classNames = ['container', 'shown', 'height-auto', 'iosfix', 'popup', 'modal', 'no-backdrop', 'no-transition', 'toast', 'toast-shown', 'show', 'hide', 'close', 'title', 'html-container', 'actions', 'confirm', 'deny', 'cancel', 'default-outline', 'footer', 'icon', 'icon-content', 'image', 'input', 'file', 'range', 'select', 'radio', 'checkbox', 'label', 'textarea', 'inputerror', 'input-label', 'validation-message', 'progress-steps', 'active-progress-step', 'progress-step', 'progress-step-line', 'loader', 'loading', 'styled', 'top', 'top-start', 'top-end', 'top-left', 'top-right', 'center', 'center-start', 'center-end', 'center-left', 'center-right', 'bottom', 'bottom-start', 'bottom-end', 'bottom-left', 'bottom-right', 'grow-row', 'grow-column', 'grow-fullscreen', 'rtl', 'timer-progress-bar', 'timer-progress-bar-container', 'scrollbar-measure', 'icon-success', 'icon-warning', 'icon-info', 'icon-question', 'icon-error', 'draggable', 'dragging'];
    	  const swalClasses = classNames.reduce((acc, className) => {
    	    acc[className] = swalPrefix + className;
    	    return acc;
    	  }, /** @type {SwalClasses} */{});

    	  /** @type {SwalIcon[]} */
    	  const icons = ['success', 'warning', 'info', 'question', 'error'];
    	  const iconTypes = icons.reduce((acc, icon) => {
    	    acc[icon] = swalPrefix + icon;
    	    return acc;
    	  }, /** @type {SwalIcons} */{});

    	  const consolePrefix = 'SweetAlert2:';

    	  /**
    	   * Capitalize the first letter of a string
    	   *
    	   * @param {string} str
    	   * @returns {string}
    	   */
    	  const capitalizeFirstLetter = str => str.charAt(0).toUpperCase() + str.slice(1);

    	  /**
    	   * Standardize console warnings
    	   *
    	   * @param {string | string[]} message
    	   */
    	  const warn = message => {
    	    console.warn(`${consolePrefix} ${typeof message === 'object' ? message.join(' ') : message}`);
    	  };

    	  /**
    	   * Standardize console errors
    	   *
    	   * @param {string} message
    	   */
    	  const error = message => {
    	    console.error(`${consolePrefix} ${message}`);
    	  };

    	  /**
    	   * Private global state for `warnOnce`
    	   *
    	   * @type {string[]}
    	   * @private
    	   */
    	  const previousWarnOnceMessages = [];

    	  /**
    	   * Show a console warning, but only if it hasn't already been shown
    	   *
    	   * @param {string} message
    	   */
    	  const warnOnce = message => {
    	    if (!previousWarnOnceMessages.includes(message)) {
    	      previousWarnOnceMessages.push(message);
    	      warn(message);
    	    }
    	  };

    	  /**
    	   * Show a one-time console warning about deprecated params/methods
    	   *
    	   * @param {string} deprecatedParam
    	   * @param {string?} useInstead
    	   */
    	  const warnAboutDeprecation = function (deprecatedParam) {
    	    let useInstead = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    	    warnOnce(`"${deprecatedParam}" is deprecated and will be removed in the next major release.${useInstead ? ` Use "${useInstead}" instead.` : ''}`);
    	  };

    	  /**
    	   * If `arg` is a function, call it (with no arguments or context) and return the result.
    	   * Otherwise, just pass the value through
    	   *
    	   * @param {Function | any} arg
    	   * @returns {any}
    	   */
    	  const callIfFunction = arg => typeof arg === 'function' ? arg() : arg;

    	  /**
    	   * @param {any} arg
    	   * @returns {boolean}
    	   */
    	  const hasToPromiseFn = arg => arg && typeof arg.toPromise === 'function';

    	  /**
    	   * @param {any} arg
    	   * @returns {Promise<any>}
    	   */
    	  const asPromise = arg => hasToPromiseFn(arg) ? arg.toPromise() : Promise.resolve(arg);

    	  /**
    	   * @param {any} arg
    	   * @returns {boolean}
    	   */
    	  const isPromise = arg => arg && Promise.resolve(arg) === arg;

    	  /**
    	   * Gets the popup container which contains the backdrop and the popup itself.
    	   *
    	   * @returns {HTMLElement | null}
    	   */
    	  const getContainer = () => document.body.querySelector(`.${swalClasses.container}`);

    	  /**
    	   * @param {string} selectorString
    	   * @returns {HTMLElement | null}
    	   */
    	  const elementBySelector = selectorString => {
    	    const container = getContainer();
    	    return container ? container.querySelector(selectorString) : null;
    	  };

    	  /**
    	   * @param {string} className
    	   * @returns {HTMLElement | null}
    	   */
    	  const elementByClass = className => {
    	    return elementBySelector(`.${className}`);
    	  };

    	  /**
    	   * @returns {HTMLElement | null}
    	   */
    	  const getPopup = () => elementByClass(swalClasses.popup);

    	  /**
    	   * @returns {HTMLElement | null}
    	   */
    	  const getIcon = () => elementByClass(swalClasses.icon);

    	  /**
    	   * @returns {HTMLElement | null}
    	   */
    	  const getIconContent = () => elementByClass(swalClasses['icon-content']);

    	  /**
    	   * @returns {HTMLElement | null}
    	   */
    	  const getTitle = () => elementByClass(swalClasses.title);

    	  /**
    	   * @returns {HTMLElement | null}
    	   */
    	  const getHtmlContainer = () => elementByClass(swalClasses['html-container']);

    	  /**
    	   * @returns {HTMLElement | null}
    	   */
    	  const getImage = () => elementByClass(swalClasses.image);

    	  /**
    	   * @returns {HTMLElement | null}
    	   */
    	  const getProgressSteps = () => elementByClass(swalClasses['progress-steps']);

    	  /**
    	   * @returns {HTMLElement | null}
    	   */
    	  const getValidationMessage = () => elementByClass(swalClasses['validation-message']);

    	  /**
    	   * @returns {HTMLButtonElement | null}
    	   */
    	  const getConfirmButton = () => (/** @type {HTMLButtonElement} */elementBySelector(`.${swalClasses.actions} .${swalClasses.confirm}`));

    	  /**
    	   * @returns {HTMLButtonElement | null}
    	   */
    	  const getCancelButton = () => (/** @type {HTMLButtonElement} */elementBySelector(`.${swalClasses.actions} .${swalClasses.cancel}`));

    	  /**
    	   * @returns {HTMLButtonElement | null}
    	   */
    	  const getDenyButton = () => (/** @type {HTMLButtonElement} */elementBySelector(`.${swalClasses.actions} .${swalClasses.deny}`));

    	  /**
    	   * @returns {HTMLElement | null}
    	   */
    	  const getInputLabel = () => elementByClass(swalClasses['input-label']);

    	  /**
    	   * @returns {HTMLElement | null}
    	   */
    	  const getLoader = () => elementBySelector(`.${swalClasses.loader}`);

    	  /**
    	   * @returns {HTMLElement | null}
    	   */
    	  const getActions = () => elementByClass(swalClasses.actions);

    	  /**
    	   * @returns {HTMLElement | null}
    	   */
    	  const getFooter = () => elementByClass(swalClasses.footer);

    	  /**
    	   * @returns {HTMLElement | null}
    	   */
    	  const getTimerProgressBar = () => elementByClass(swalClasses['timer-progress-bar']);

    	  /**
    	   * @returns {HTMLElement | null}
    	   */
    	  const getCloseButton = () => elementByClass(swalClasses.close);

    	  // https://github.com/jkup/focusable/blob/master/index.js
    	  const focusable = `
  a[href],
  area[href],
  input:not([disabled]),
  select:not([disabled]),
  textarea:not([disabled]),
  button:not([disabled]),
  iframe,
  object,
  embed,
  [tabindex="0"],
  [contenteditable],
  audio[controls],
  video[controls],
  summary
`;
    	  /**
    	   * @returns {HTMLElement[]}
    	   */
    	  const getFocusableElements = () => {
    	    const popup = getPopup();
    	    if (!popup) {
    	      return [];
    	    }
    	    /** @type {NodeListOf<HTMLElement>} */
    	    const focusableElementsWithTabindex = popup.querySelectorAll('[tabindex]:not([tabindex="-1"]):not([tabindex="0"])');
    	    const focusableElementsWithTabindexSorted = Array.from(focusableElementsWithTabindex)
    	    // sort according to tabindex
    	    .sort((a, b) => {
    	      const tabindexA = parseInt(a.getAttribute('tabindex') || '0');
    	      const tabindexB = parseInt(b.getAttribute('tabindex') || '0');
    	      if (tabindexA > tabindexB) {
    	        return 1;
    	      } else if (tabindexA < tabindexB) {
    	        return -1;
    	      }
    	      return 0;
    	    });

    	    /** @type {NodeListOf<HTMLElement>} */
    	    const otherFocusableElements = popup.querySelectorAll(focusable);
    	    const otherFocusableElementsFiltered = Array.from(otherFocusableElements).filter(el => el.getAttribute('tabindex') !== '-1');
    	    return [...new Set(focusableElementsWithTabindexSorted.concat(otherFocusableElementsFiltered))].filter(el => isVisible$1(el));
    	  };

    	  /**
    	   * @returns {boolean}
    	   */
    	  const isModal = () => {
    	    return hasClass(document.body, swalClasses.shown) && !hasClass(document.body, swalClasses['toast-shown']) && !hasClass(document.body, swalClasses['no-backdrop']);
    	  };

    	  /**
    	   * @returns {boolean}
    	   */
    	  const isToast = () => {
    	    const popup = getPopup();
    	    if (!popup) {
    	      return false;
    	    }
    	    return hasClass(popup, swalClasses.toast);
    	  };

    	  /**
    	   * @returns {boolean}
    	   */
    	  const isLoading = () => {
    	    const popup = getPopup();
    	    if (!popup) {
    	      return false;
    	    }
    	    return popup.hasAttribute('data-loading');
    	  };

    	  /**
    	   * Securely set innerHTML of an element
    	   * https://github.com/sweetalert2/sweetalert2/issues/1926
    	   *
    	   * @param {HTMLElement} elem
    	   * @param {string} html
    	   */
    	  const setInnerHtml = (elem, html) => {
    	    elem.textContent = '';
    	    if (html) {
    	      const parser = new DOMParser();
    	      const parsed = parser.parseFromString(html, `text/html`);
    	      const head = parsed.querySelector('head');
    	      if (head) {
    	        Array.from(head.childNodes).forEach(child => {
    	          elem.appendChild(child);
    	        });
    	      }
    	      const body = parsed.querySelector('body');
    	      if (body) {
    	        Array.from(body.childNodes).forEach(child => {
    	          if (child instanceof HTMLVideoElement || child instanceof HTMLAudioElement) {
    	            elem.appendChild(child.cloneNode(true)); // https://github.com/sweetalert2/sweetalert2/issues/2507
    	          } else {
    	            elem.appendChild(child);
    	          }
    	        });
    	      }
    	    }
    	  };

    	  /**
    	   * @param {HTMLElement} elem
    	   * @param {string} className
    	   * @returns {boolean}
    	   */
    	  const hasClass = (elem, className) => {
    	    if (!className) {
    	      return false;
    	    }
    	    const classList = className.split(/\s+/);
    	    for (let i = 0; i < classList.length; i++) {
    	      if (!elem.classList.contains(classList[i])) {
    	        return false;
    	      }
    	    }
    	    return true;
    	  };

    	  /**
    	   * @param {HTMLElement} elem
    	   * @param {SweetAlertOptions} params
    	   */
    	  const removeCustomClasses = (elem, params) => {
    	    Array.from(elem.classList).forEach(className => {
    	      if (!Object.values(swalClasses).includes(className) && !Object.values(iconTypes).includes(className) && !Object.values(params.showClass || {}).includes(className)) {
    	        elem.classList.remove(className);
    	      }
    	    });
    	  };

    	  /**
    	   * @param {HTMLElement} elem
    	   * @param {SweetAlertOptions} params
    	   * @param {string} className
    	   */
    	  const applyCustomClass = (elem, params, className) => {
    	    removeCustomClasses(elem, params);
    	    if (!params.customClass) {
    	      return;
    	    }
    	    const customClass = params.customClass[(/** @type {keyof SweetAlertCustomClass} */className)];
    	    if (!customClass) {
    	      return;
    	    }
    	    if (typeof customClass !== 'string' && !customClass.forEach) {
    	      warn(`Invalid type of customClass.${className}! Expected string or iterable object, got "${typeof customClass}"`);
    	      return;
    	    }
    	    addClass(elem, customClass);
    	  };

    	  /**
    	   * @param {HTMLElement} popup
    	   * @param {import('./renderers/renderInput').InputClass | SweetAlertInput} inputClass
    	   * @returns {HTMLInputElement | null}
    	   */
    	  const getInput$1 = (popup, inputClass) => {
    	    if (!inputClass) {
    	      return null;
    	    }
    	    switch (inputClass) {
    	      case 'select':
    	      case 'textarea':
    	      case 'file':
    	        return popup.querySelector(`.${swalClasses.popup} > .${swalClasses[inputClass]}`);
    	      case 'checkbox':
    	        return popup.querySelector(`.${swalClasses.popup} > .${swalClasses.checkbox} input`);
    	      case 'radio':
    	        return popup.querySelector(`.${swalClasses.popup} > .${swalClasses.radio} input:checked`) || popup.querySelector(`.${swalClasses.popup} > .${swalClasses.radio} input:first-child`);
    	      case 'range':
    	        return popup.querySelector(`.${swalClasses.popup} > .${swalClasses.range} input`);
    	      default:
    	        return popup.querySelector(`.${swalClasses.popup} > .${swalClasses.input}`);
    	    }
    	  };

    	  /**
    	   * @param {HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement} input
    	   */
    	  const focusInput = input => {
    	    input.focus();

    	    // place cursor at end of text in text input
    	    if (input.type !== 'file') {
    	      // http://stackoverflow.com/a/2345915
    	      const val = input.value;
    	      input.value = '';
    	      input.value = val;
    	    }
    	  };

    	  /**
    	   * @param {HTMLElement | HTMLElement[] | null} target
    	   * @param {string | string[] | readonly string[] | undefined} classList
    	   * @param {boolean} condition
    	   */
    	  const toggleClass = (target, classList, condition) => {
    	    if (!target || !classList) {
    	      return;
    	    }
    	    if (typeof classList === 'string') {
    	      classList = classList.split(/\s+/).filter(Boolean);
    	    }
    	    classList.forEach(className => {
    	      if (Array.isArray(target)) {
    	        target.forEach(elem => {
    	          if (condition) {
    	            elem.classList.add(className);
    	          } else {
    	            elem.classList.remove(className);
    	          }
    	        });
    	      } else {
    	        if (condition) {
    	          target.classList.add(className);
    	        } else {
    	          target.classList.remove(className);
    	        }
    	      }
    	    });
    	  };

    	  /**
    	   * @param {HTMLElement | HTMLElement[] | null} target
    	   * @param {string | string[] | readonly string[] | undefined} classList
    	   */
    	  const addClass = (target, classList) => {
    	    toggleClass(target, classList, true);
    	  };

    	  /**
    	   * @param {HTMLElement | HTMLElement[] | null} target
    	   * @param {string | string[] | readonly string[] | undefined} classList
    	   */
    	  const removeClass = (target, classList) => {
    	    toggleClass(target, classList, false);
    	  };

    	  /**
    	   * Get direct child of an element by class name
    	   *
    	   * @param {HTMLElement} elem
    	   * @param {string} className
    	   * @returns {HTMLElement | undefined}
    	   */
    	  const getDirectChildByClass = (elem, className) => {
    	    const children = Array.from(elem.children);
    	    for (let i = 0; i < children.length; i++) {
    	      const child = children[i];
    	      if (child instanceof HTMLElement && hasClass(child, className)) {
    	        return child;
    	      }
    	    }
    	  };

    	  /**
    	   * @param {HTMLElement} elem
    	   * @param {string} property
    	   * @param {*} value
    	   */
    	  const applyNumericalStyle = (elem, property, value) => {
    	    if (value === `${parseInt(value)}`) {
    	      value = parseInt(value);
    	    }
    	    if (value || parseInt(value) === 0) {
    	      elem.style.setProperty(property, typeof value === 'number' ? `${value}px` : value);
    	    } else {
    	      elem.style.removeProperty(property);
    	    }
    	  };

    	  /**
    	   * @param {HTMLElement | null} elem
    	   * @param {string} display
    	   */
    	  const show = function (elem) {
    	    let display = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'flex';
    	    if (!elem) {
    	      return;
    	    }
    	    elem.style.display = display;
    	  };

    	  /**
    	   * @param {HTMLElement | null} elem
    	   */
    	  const hide = elem => {
    	    if (!elem) {
    	      return;
    	    }
    	    elem.style.display = 'none';
    	  };

    	  /**
    	   * @param {HTMLElement | null} elem
    	   * @param {string} display
    	   */
    	  const showWhenInnerHtmlPresent = function (elem) {
    	    let display = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'block';
    	    if (!elem) {
    	      return;
    	    }
    	    new MutationObserver(() => {
    	      toggle(elem, elem.innerHTML, display);
    	    }).observe(elem, {
    	      childList: true,
    	      subtree: true
    	    });
    	  };

    	  /**
    	   * @param {HTMLElement} parent
    	   * @param {string} selector
    	   * @param {string} property
    	   * @param {string} value
    	   */
    	  const setStyle = (parent, selector, property, value) => {
    	    /** @type {HTMLElement | null} */
    	    const el = parent.querySelector(selector);
    	    if (el) {
    	      el.style.setProperty(property, value);
    	    }
    	  };

    	  /**
    	   * @param {HTMLElement} elem
    	   * @param {any} condition
    	   * @param {string} display
    	   */
    	  const toggle = function (elem, condition) {
    	    let display = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'flex';
    	    if (condition) {
    	      show(elem, display);
    	    } else {
    	      hide(elem);
    	    }
    	  };

    	  /**
    	   * borrowed from jquery $(elem).is(':visible') implementation
    	   *
    	   * @param {HTMLElement | null} elem
    	   * @returns {boolean}
    	   */
    	  const isVisible$1 = elem => !!(elem && (elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length));

    	  /**
    	   * @returns {boolean}
    	   */
    	  const allButtonsAreHidden = () => !isVisible$1(getConfirmButton()) && !isVisible$1(getDenyButton()) && !isVisible$1(getCancelButton());

    	  /**
    	   * @param {HTMLElement} elem
    	   * @returns {boolean}
    	   */
    	  const isScrollable = elem => !!(elem.scrollHeight > elem.clientHeight);

    	  /**
    	   * borrowed from https://stackoverflow.com/a/46352119
    	   *
    	   * @param {HTMLElement} elem
    	   * @returns {boolean}
    	   */
    	  const hasCssAnimation = elem => {
    	    const style = window.getComputedStyle(elem);
    	    const animDuration = parseFloat(style.getPropertyValue('animation-duration') || '0');
    	    const transDuration = parseFloat(style.getPropertyValue('transition-duration') || '0');
    	    return animDuration > 0 || transDuration > 0;
    	  };

    	  /**
    	   * @param {number} timer
    	   * @param {boolean} reset
    	   */
    	  const animateTimerProgressBar = function (timer) {
    	    let reset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    	    const timerProgressBar = getTimerProgressBar();
    	    if (!timerProgressBar) {
    	      return;
    	    }
    	    if (isVisible$1(timerProgressBar)) {
    	      if (reset) {
    	        timerProgressBar.style.transition = 'none';
    	        timerProgressBar.style.width = '100%';
    	      }
    	      setTimeout(() => {
    	        timerProgressBar.style.transition = `width ${timer / 1000}s linear`;
    	        timerProgressBar.style.width = '0%';
    	      }, 10);
    	    }
    	  };
    	  const stopTimerProgressBar = () => {
    	    const timerProgressBar = getTimerProgressBar();
    	    if (!timerProgressBar) {
    	      return;
    	    }
    	    const timerProgressBarWidth = parseInt(window.getComputedStyle(timerProgressBar).width);
    	    timerProgressBar.style.removeProperty('transition');
    	    timerProgressBar.style.width = '100%';
    	    const timerProgressBarFullWidth = parseInt(window.getComputedStyle(timerProgressBar).width);
    	    const timerProgressBarPercent = timerProgressBarWidth / timerProgressBarFullWidth * 100;
    	    timerProgressBar.style.width = `${timerProgressBarPercent}%`;
    	  };

    	  /**
    	   * Detect Node env
    	   *
    	   * @returns {boolean}
    	   */
    	  const isNodeEnv = () => typeof window === 'undefined' || typeof document === 'undefined';

    	  const sweetHTML = `
 <div aria-labelledby="${swalClasses.title}" aria-describedby="${swalClasses['html-container']}" class="${swalClasses.popup}" tabindex="-1">
   <button type="button" class="${swalClasses.close}"></button>
   <ul class="${swalClasses['progress-steps']}"></ul>
   <div class="${swalClasses.icon}"></div>
   <img class="${swalClasses.image}" />
   <h2 class="${swalClasses.title}" id="${swalClasses.title}"></h2>
   <div class="${swalClasses['html-container']}" id="${swalClasses['html-container']}"></div>
   <input class="${swalClasses.input}" id="${swalClasses.input}" />
   <input type="file" class="${swalClasses.file}" />
   <div class="${swalClasses.range}">
     <input type="range" />
     <output></output>
   </div>
   <select class="${swalClasses.select}" id="${swalClasses.select}"></select>
   <div class="${swalClasses.radio}"></div>
   <label class="${swalClasses.checkbox}">
     <input type="checkbox" id="${swalClasses.checkbox}" />
     <span class="${swalClasses.label}"></span>
   </label>
   <textarea class="${swalClasses.textarea}" id="${swalClasses.textarea}"></textarea>
   <div class="${swalClasses['validation-message']}" id="${swalClasses['validation-message']}"></div>
   <div class="${swalClasses.actions}">
     <div class="${swalClasses.loader}"></div>
     <button type="button" class="${swalClasses.confirm}"></button>
     <button type="button" class="${swalClasses.deny}"></button>
     <button type="button" class="${swalClasses.cancel}"></button>
   </div>
   <div class="${swalClasses.footer}"></div>
   <div class="${swalClasses['timer-progress-bar-container']}">
     <div class="${swalClasses['timer-progress-bar']}"></div>
   </div>
 </div>
`.replace(/(^|\n)\s*/g, '');

    	  /**
    	   * @returns {boolean}
    	   */
    	  const resetOldContainer = () => {
    	    const oldContainer = getContainer();
    	    if (!oldContainer) {
    	      return false;
    	    }
    	    oldContainer.remove();
    	    removeClass([document.documentElement, document.body], [swalClasses['no-backdrop'], swalClasses['toast-shown'], swalClasses['has-column']]);
    	    return true;
    	  };
    	  const resetValidationMessage$1 = () => {
    	    globalState.currentInstance.resetValidationMessage();
    	  };
    	  const addInputChangeListeners = () => {
    	    const popup = getPopup();
    	    const input = getDirectChildByClass(popup, swalClasses.input);
    	    const file = getDirectChildByClass(popup, swalClasses.file);
    	    /** @type {HTMLInputElement} */
    	    const range = popup.querySelector(`.${swalClasses.range} input`);
    	    /** @type {HTMLOutputElement} */
    	    const rangeOutput = popup.querySelector(`.${swalClasses.range} output`);
    	    const select = getDirectChildByClass(popup, swalClasses.select);
    	    /** @type {HTMLInputElement} */
    	    const checkbox = popup.querySelector(`.${swalClasses.checkbox} input`);
    	    const textarea = getDirectChildByClass(popup, swalClasses.textarea);
    	    input.oninput = resetValidationMessage$1;
    	    file.onchange = resetValidationMessage$1;
    	    select.onchange = resetValidationMessage$1;
    	    checkbox.onchange = resetValidationMessage$1;
    	    textarea.oninput = resetValidationMessage$1;
    	    range.oninput = () => {
    	      resetValidationMessage$1();
    	      rangeOutput.value = range.value;
    	    };
    	    range.onchange = () => {
    	      resetValidationMessage$1();
    	      rangeOutput.value = range.value;
    	    };
    	  };

    	  /**
    	   * @param {string | HTMLElement} target
    	   * @returns {HTMLElement}
    	   */
    	  const getTarget = target => typeof target === 'string' ? document.querySelector(target) : target;

    	  /**
    	   * @param {SweetAlertOptions} params
    	   */
    	  const setupAccessibility = params => {
    	    const popup = getPopup();
    	    popup.setAttribute('role', params.toast ? 'alert' : 'dialog');
    	    popup.setAttribute('aria-live', params.toast ? 'polite' : 'assertive');
    	    if (!params.toast) {
    	      popup.setAttribute('aria-modal', 'true');
    	    }
    	  };

    	  /**
    	   * @param {HTMLElement} targetElement
    	   */
    	  const setupRTL = targetElement => {
    	    if (window.getComputedStyle(targetElement).direction === 'rtl') {
    	      addClass(getContainer(), swalClasses.rtl);
    	    }
    	  };

    	  /**
    	   * Add modal + backdrop + no-war message for Russians to DOM
    	   *
    	   * @param {SweetAlertOptions} params
    	   */
    	  const init = params => {
    	    // Clean up the old popup container if it exists
    	    const oldContainerExisted = resetOldContainer();
    	    if (isNodeEnv()) {
    	      error('SweetAlert2 requires document to initialize');
    	      return;
    	    }
    	    const container = document.createElement('div');
    	    container.className = swalClasses.container;
    	    if (oldContainerExisted) {
    	      addClass(container, swalClasses['no-transition']);
    	    }
    	    setInnerHtml(container, sweetHTML);
    	    container.dataset['swal2Theme'] = params.theme;
    	    const targetElement = getTarget(params.target);
    	    targetElement.appendChild(container);
    	    setupAccessibility(params);
    	    setupRTL(targetElement);
    	    addInputChangeListeners();
    	  };

    	  /**
    	   * @param {HTMLElement | object | string} param
    	   * @param {HTMLElement} target
    	   */
    	  const parseHtmlToContainer = (param, target) => {
    	    // DOM element
    	    if (param instanceof HTMLElement) {
    	      target.appendChild(param);
    	    }

    	    // Object
    	    else if (typeof param === 'object') {
    	      handleObject(param, target);
    	    }

    	    // Plain string
    	    else if (param) {
    	      setInnerHtml(target, param);
    	    }
    	  };

    	  /**
    	   * @param {any} param
    	   * @param {HTMLElement} target
    	   */
    	  const handleObject = (param, target) => {
    	    // JQuery element(s)
    	    if (param.jquery) {
    	      handleJqueryElem(target, param);
    	    }

    	    // For other objects use their string representation
    	    else {
    	      setInnerHtml(target, param.toString());
    	    }
    	  };

    	  /**
    	   * @param {HTMLElement} target
    	   * @param {any} elem
    	   */
    	  const handleJqueryElem = (target, elem) => {
    	    target.textContent = '';
    	    if (0 in elem) {
    	      for (let i = 0; i in elem; i++) {
    	        target.appendChild(elem[i].cloneNode(true));
    	      }
    	    } else {
    	      target.appendChild(elem.cloneNode(true));
    	    }
    	  };

    	  /**
    	   * @param {SweetAlert} instance
    	   * @param {SweetAlertOptions} params
    	   */
    	  const renderActions = (instance, params) => {
    	    const actions = getActions();
    	    const loader = getLoader();
    	    if (!actions || !loader) {
    	      return;
    	    }

    	    // Actions (buttons) wrapper
    	    if (!params.showConfirmButton && !params.showDenyButton && !params.showCancelButton) {
    	      hide(actions);
    	    } else {
    	      show(actions);
    	    }

    	    // Custom class
    	    applyCustomClass(actions, params, 'actions');

    	    // Render all the buttons
    	    renderButtons(actions, loader, params);

    	    // Loader
    	    setInnerHtml(loader, params.loaderHtml || '');
    	    applyCustomClass(loader, params, 'loader');
    	  };

    	  /**
    	   * @param {HTMLElement} actions
    	   * @param {HTMLElement} loader
    	   * @param {SweetAlertOptions} params
    	   */
    	  function renderButtons(actions, loader, params) {
    	    const confirmButton = getConfirmButton();
    	    const denyButton = getDenyButton();
    	    const cancelButton = getCancelButton();
    	    if (!confirmButton || !denyButton || !cancelButton) {
    	      return;
    	    }

    	    // Render buttons
    	    renderButton(confirmButton, 'confirm', params);
    	    renderButton(denyButton, 'deny', params);
    	    renderButton(cancelButton, 'cancel', params);
    	    handleButtonsStyling(confirmButton, denyButton, cancelButton, params);
    	    if (params.reverseButtons) {
    	      if (params.toast) {
    	        actions.insertBefore(cancelButton, confirmButton);
    	        actions.insertBefore(denyButton, confirmButton);
    	      } else {
    	        actions.insertBefore(cancelButton, loader);
    	        actions.insertBefore(denyButton, loader);
    	        actions.insertBefore(confirmButton, loader);
    	      }
    	    }
    	  }

    	  /**
    	   * @param {HTMLElement} confirmButton
    	   * @param {HTMLElement} denyButton
    	   * @param {HTMLElement} cancelButton
    	   * @param {SweetAlertOptions} params
    	   */
    	  function handleButtonsStyling(confirmButton, denyButton, cancelButton, params) {
    	    if (!params.buttonsStyling) {
    	      removeClass([confirmButton, denyButton, cancelButton], swalClasses.styled);
    	      return;
    	    }
    	    addClass([confirmButton, denyButton, cancelButton], swalClasses.styled);

    	    // Buttons background colors
    	    if (params.confirmButtonColor) {
    	      confirmButton.style.backgroundColor = params.confirmButtonColor;
    	      addClass(confirmButton, swalClasses['default-outline']);
    	    }
    	    if (params.denyButtonColor) {
    	      denyButton.style.backgroundColor = params.denyButtonColor;
    	      addClass(denyButton, swalClasses['default-outline']);
    	    }
    	    if (params.cancelButtonColor) {
    	      cancelButton.style.backgroundColor = params.cancelButtonColor;
    	      addClass(cancelButton, swalClasses['default-outline']);
    	    }
    	  }

    	  /**
    	   * @param {HTMLElement} button
    	   * @param {'confirm' | 'deny' | 'cancel'} buttonType
    	   * @param {SweetAlertOptions} params
    	   */
    	  function renderButton(button, buttonType, params) {
    	    const buttonName = /** @type {'Confirm' | 'Deny' | 'Cancel'} */capitalizeFirstLetter(buttonType);
    	    toggle(button, params[`show${buttonName}Button`], 'inline-block');
    	    setInnerHtml(button, params[`${buttonType}ButtonText`] || ''); // Set caption text
    	    button.setAttribute('aria-label', params[`${buttonType}ButtonAriaLabel`] || ''); // ARIA label

    	    // Add buttons custom classes
    	    button.className = swalClasses[buttonType];
    	    applyCustomClass(button, params, `${buttonType}Button`);
    	  }

    	  /**
    	   * @param {SweetAlert} instance
    	   * @param {SweetAlertOptions} params
    	   */
    	  const renderCloseButton = (instance, params) => {
    	    const closeButton = getCloseButton();
    	    if (!closeButton) {
    	      return;
    	    }
    	    setInnerHtml(closeButton, params.closeButtonHtml || '');

    	    // Custom class
    	    applyCustomClass(closeButton, params, 'closeButton');
    	    toggle(closeButton, params.showCloseButton);
    	    closeButton.setAttribute('aria-label', params.closeButtonAriaLabel || '');
    	  };

    	  /**
    	   * @param {SweetAlert} instance
    	   * @param {SweetAlertOptions} params
    	   */
    	  const renderContainer = (instance, params) => {
    	    const container = getContainer();
    	    if (!container) {
    	      return;
    	    }
    	    handleBackdropParam(container, params.backdrop);
    	    handlePositionParam(container, params.position);
    	    handleGrowParam(container, params.grow);

    	    // Custom class
    	    applyCustomClass(container, params, 'container');
    	  };

    	  /**
    	   * @param {HTMLElement} container
    	   * @param {SweetAlertOptions['backdrop']} backdrop
    	   */
    	  function handleBackdropParam(container, backdrop) {
    	    if (typeof backdrop === 'string') {
    	      container.style.background = backdrop;
    	    } else if (!backdrop) {
    	      addClass([document.documentElement, document.body], swalClasses['no-backdrop']);
    	    }
    	  }

    	  /**
    	   * @param {HTMLElement} container
    	   * @param {SweetAlertOptions['position']} position
    	   */
    	  function handlePositionParam(container, position) {
    	    if (!position) {
    	      return;
    	    }
    	    if (position in swalClasses) {
    	      addClass(container, swalClasses[position]);
    	    } else {
    	      warn('The "position" parameter is not valid, defaulting to "center"');
    	      addClass(container, swalClasses.center);
    	    }
    	  }

    	  /**
    	   * @param {HTMLElement} container
    	   * @param {SweetAlertOptions['grow']} grow
    	   */
    	  function handleGrowParam(container, grow) {
    	    if (!grow) {
    	      return;
    	    }
    	    addClass(container, swalClasses[`grow-${grow}`]);
    	  }

    	  /**
    	   * This module contains `WeakMap`s for each effectively-"private  property" that a `Swal` has.
    	   * For example, to set the private property "foo" of `this` to "bar", you can `privateProps.foo.set(this, 'bar')`
    	   * This is the approach that Babel will probably take to implement private methods/fields
    	   *   https://github.com/tc39/proposal-private-methods
    	   *   https://github.com/babel/babel/pull/7555
    	   * Once we have the changes from that PR in Babel, and our core class fits reasonable in *one module*
    	   *   then we can use that language feature.
    	   */

    	  var privateProps = {
    	    innerParams: new WeakMap(),
    	    domCache: new WeakMap()
    	  };

    	  /// <reference path="../../../../sweetalert2.d.ts"/>


    	  /** @type {InputClass[]} */
    	  const inputClasses = ['input', 'file', 'range', 'select', 'radio', 'checkbox', 'textarea'];

    	  /**
    	   * @param {SweetAlert} instance
    	   * @param {SweetAlertOptions} params
    	   */
    	  const renderInput = (instance, params) => {
    	    const popup = getPopup();
    	    if (!popup) {
    	      return;
    	    }
    	    const innerParams = privateProps.innerParams.get(instance);
    	    const rerender = !innerParams || params.input !== innerParams.input;
    	    inputClasses.forEach(inputClass => {
    	      const inputContainer = getDirectChildByClass(popup, swalClasses[inputClass]);
    	      if (!inputContainer) {
    	        return;
    	      }

    	      // set attributes
    	      setAttributes(inputClass, params.inputAttributes);

    	      // set class
    	      inputContainer.className = swalClasses[inputClass];
    	      if (rerender) {
    	        hide(inputContainer);
    	      }
    	    });
    	    if (params.input) {
    	      if (rerender) {
    	        showInput(params);
    	      }
    	      // set custom class
    	      setCustomClass(params);
    	    }
    	  };

    	  /**
    	   * @param {SweetAlertOptions} params
    	   */
    	  const showInput = params => {
    	    if (!params.input) {
    	      return;
    	    }
    	    if (!renderInputType[params.input]) {
    	      error(`Unexpected type of input! Expected ${Object.keys(renderInputType).join(' | ')}, got "${params.input}"`);
    	      return;
    	    }
    	    const inputContainer = getInputContainer(params.input);
    	    if (!inputContainer) {
    	      return;
    	    }
    	    const input = renderInputType[params.input](inputContainer, params);
    	    show(inputContainer);

    	    // input autofocus
    	    if (params.inputAutoFocus) {
    	      setTimeout(() => {
    	        focusInput(input);
    	      });
    	    }
    	  };

    	  /**
    	   * @param {HTMLInputElement} input
    	   */
    	  const removeAttributes = input => {
    	    for (let i = 0; i < input.attributes.length; i++) {
    	      const attrName = input.attributes[i].name;
    	      if (!['id', 'type', 'value', 'style'].includes(attrName)) {
    	        input.removeAttribute(attrName);
    	      }
    	    }
    	  };

    	  /**
    	   * @param {InputClass} inputClass
    	   * @param {SweetAlertOptions['inputAttributes']} inputAttributes
    	   */
    	  const setAttributes = (inputClass, inputAttributes) => {
    	    const popup = getPopup();
    	    if (!popup) {
    	      return;
    	    }
    	    const input = getInput$1(popup, inputClass);
    	    if (!input) {
    	      return;
    	    }
    	    removeAttributes(input);
    	    for (const attr in inputAttributes) {
    	      input.setAttribute(attr, inputAttributes[attr]);
    	    }
    	  };

    	  /**
    	   * @param {SweetAlertOptions} params
    	   */
    	  const setCustomClass = params => {
    	    if (!params.input) {
    	      return;
    	    }
    	    const inputContainer = getInputContainer(params.input);
    	    if (inputContainer) {
    	      applyCustomClass(inputContainer, params, 'input');
    	    }
    	  };

    	  /**
    	   * @param {HTMLInputElement | HTMLTextAreaElement} input
    	   * @param {SweetAlertOptions} params
    	   */
    	  const setInputPlaceholder = (input, params) => {
    	    if (!input.placeholder && params.inputPlaceholder) {
    	      input.placeholder = params.inputPlaceholder;
    	    }
    	  };

    	  /**
    	   * @param {Input} input
    	   * @param {Input} prependTo
    	   * @param {SweetAlertOptions} params
    	   */
    	  const setInputLabel = (input, prependTo, params) => {
    	    if (params.inputLabel) {
    	      const label = document.createElement('label');
    	      const labelClass = swalClasses['input-label'];
    	      label.setAttribute('for', input.id);
    	      label.className = labelClass;
    	      if (typeof params.customClass === 'object') {
    	        addClass(label, params.customClass.inputLabel);
    	      }
    	      label.innerText = params.inputLabel;
    	      prependTo.insertAdjacentElement('beforebegin', label);
    	    }
    	  };

    	  /**
    	   * @param {SweetAlertInput} inputType
    	   * @returns {HTMLElement | undefined}
    	   */
    	  const getInputContainer = inputType => {
    	    const popup = getPopup();
    	    if (!popup) {
    	      return;
    	    }
    	    return getDirectChildByClass(popup, swalClasses[(/** @type {SwalClass} */inputType)] || swalClasses.input);
    	  };

    	  /**
    	   * @param {HTMLInputElement | HTMLOutputElement | HTMLTextAreaElement} input
    	   * @param {SweetAlertOptions['inputValue']} inputValue
    	   */
    	  const checkAndSetInputValue = (input, inputValue) => {
    	    if (['string', 'number'].includes(typeof inputValue)) {
    	      input.value = `${inputValue}`;
    	    } else if (!isPromise(inputValue)) {
    	      warn(`Unexpected type of inputValue! Expected "string", "number" or "Promise", got "${typeof inputValue}"`);
    	    }
    	  };

    	  /** @type {Record<SweetAlertInput, (input: Input | HTMLElement, params: SweetAlertOptions) => Input>} */
    	  const renderInputType = {};

    	  /**
    	   * @param {HTMLInputElement} input
    	   * @param {SweetAlertOptions} params
    	   * @returns {HTMLInputElement}
    	   */
    	  renderInputType.text = renderInputType.email = renderInputType.password = renderInputType.number = renderInputType.tel = renderInputType.url = renderInputType.search = renderInputType.date = renderInputType['datetime-local'] = renderInputType.time = renderInputType.week = renderInputType.month = /** @type {(input: Input | HTMLElement, params: SweetAlertOptions) => Input} */
    	  (input, params) => {
    	    checkAndSetInputValue(input, params.inputValue);
    	    setInputLabel(input, input, params);
    	    setInputPlaceholder(input, params);
    	    input.type = params.input;
    	    return input;
    	  };

    	  /**
    	   * @param {HTMLInputElement} input
    	   * @param {SweetAlertOptions} params
    	   * @returns {HTMLInputElement}
    	   */
    	  renderInputType.file = (input, params) => {
    	    setInputLabel(input, input, params);
    	    setInputPlaceholder(input, params);
    	    return input;
    	  };

    	  /**
    	   * @param {HTMLInputElement} range
    	   * @param {SweetAlertOptions} params
    	   * @returns {HTMLInputElement}
    	   */
    	  renderInputType.range = (range, params) => {
    	    const rangeInput = range.querySelector('input');
    	    const rangeOutput = range.querySelector('output');
    	    checkAndSetInputValue(rangeInput, params.inputValue);
    	    rangeInput.type = params.input;
    	    checkAndSetInputValue(rangeOutput, params.inputValue);
    	    setInputLabel(rangeInput, range, params);
    	    return range;
    	  };

    	  /**
    	   * @param {HTMLSelectElement} select
    	   * @param {SweetAlertOptions} params
    	   * @returns {HTMLSelectElement}
    	   */
    	  renderInputType.select = (select, params) => {
    	    select.textContent = '';
    	    if (params.inputPlaceholder) {
    	      const placeholder = document.createElement('option');
    	      setInnerHtml(placeholder, params.inputPlaceholder);
    	      placeholder.value = '';
    	      placeholder.disabled = true;
    	      placeholder.selected = true;
    	      select.appendChild(placeholder);
    	    }
    	    setInputLabel(select, select, params);
    	    return select;
    	  };

    	  /**
    	   * @param {HTMLInputElement} radio
    	   * @returns {HTMLInputElement}
    	   */
    	  renderInputType.radio = radio => {
    	    radio.textContent = '';
    	    return radio;
    	  };

    	  /**
    	   * @param {HTMLLabelElement} checkboxContainer
    	   * @param {SweetAlertOptions} params
    	   * @returns {HTMLInputElement}
    	   */
    	  renderInputType.checkbox = (checkboxContainer, params) => {
    	    const checkbox = getInput$1(getPopup(), 'checkbox');
    	    checkbox.value = '1';
    	    checkbox.checked = Boolean(params.inputValue);
    	    const label = checkboxContainer.querySelector('span');
    	    setInnerHtml(label, params.inputPlaceholder || params.inputLabel);
    	    return checkbox;
    	  };

    	  /**
    	   * @param {HTMLTextAreaElement} textarea
    	   * @param {SweetAlertOptions} params
    	   * @returns {HTMLTextAreaElement}
    	   */
    	  renderInputType.textarea = (textarea, params) => {
    	    checkAndSetInputValue(textarea, params.inputValue);
    	    setInputPlaceholder(textarea, params);
    	    setInputLabel(textarea, textarea, params);

    	    /**
    	     * @param {HTMLElement} el
    	     * @returns {number}
    	     */
    	    const getMargin = el => parseInt(window.getComputedStyle(el).marginLeft) + parseInt(window.getComputedStyle(el).marginRight);

    	    // https://github.com/sweetalert2/sweetalert2/issues/2291
    	    setTimeout(() => {
    	      // https://github.com/sweetalert2/sweetalert2/issues/1699
    	      if ('MutationObserver' in window) {
    	        const initialPopupWidth = parseInt(window.getComputedStyle(getPopup()).width);
    	        const textareaResizeHandler = () => {
    	          // check if texarea is still in document (i.e. popup wasn't closed in the meantime)
    	          if (!document.body.contains(textarea)) {
    	            return;
    	          }
    	          const textareaWidth = textarea.offsetWidth + getMargin(textarea);
    	          if (textareaWidth > initialPopupWidth) {
    	            getPopup().style.width = `${textareaWidth}px`;
    	          } else {
    	            applyNumericalStyle(getPopup(), 'width', params.width);
    	          }
    	        };
    	        new MutationObserver(textareaResizeHandler).observe(textarea, {
    	          attributes: true,
    	          attributeFilter: ['style']
    	        });
    	      }
    	    });
    	    return textarea;
    	  };

    	  /**
    	   * @param {SweetAlert} instance
    	   * @param {SweetAlertOptions} params
    	   */
    	  const renderContent = (instance, params) => {
    	    const htmlContainer = getHtmlContainer();
    	    if (!htmlContainer) {
    	      return;
    	    }
    	    showWhenInnerHtmlPresent(htmlContainer);
    	    applyCustomClass(htmlContainer, params, 'htmlContainer');

    	    // Content as HTML
    	    if (params.html) {
    	      parseHtmlToContainer(params.html, htmlContainer);
    	      show(htmlContainer, 'block');
    	    }

    	    // Content as plain text
    	    else if (params.text) {
    	      htmlContainer.textContent = params.text;
    	      show(htmlContainer, 'block');
    	    }

    	    // No content
    	    else {
    	      hide(htmlContainer);
    	    }
    	    renderInput(instance, params);
    	  };

    	  /**
    	   * @param {SweetAlert} instance
    	   * @param {SweetAlertOptions} params
    	   */
    	  const renderFooter = (instance, params) => {
    	    const footer = getFooter();
    	    if (!footer) {
    	      return;
    	    }
    	    showWhenInnerHtmlPresent(footer);
    	    toggle(footer, params.footer, 'block');
    	    if (params.footer) {
    	      parseHtmlToContainer(params.footer, footer);
    	    }

    	    // Custom class
    	    applyCustomClass(footer, params, 'footer');
    	  };

    	  /**
    	   * @param {SweetAlert} instance
    	   * @param {SweetAlertOptions} params
    	   */
    	  const renderIcon = (instance, params) => {
    	    const innerParams = privateProps.innerParams.get(instance);
    	    const icon = getIcon();
    	    if (!icon) {
    	      return;
    	    }

    	    // if the given icon already rendered, apply the styling without re-rendering the icon
    	    if (innerParams && params.icon === innerParams.icon) {
    	      // Custom or default content
    	      setContent(icon, params);
    	      applyStyles(icon, params);
    	      return;
    	    }
    	    if (!params.icon && !params.iconHtml) {
    	      hide(icon);
    	      return;
    	    }
    	    if (params.icon && Object.keys(iconTypes).indexOf(params.icon) === -1) {
    	      error(`Unknown icon! Expected "success", "error", "warning", "info" or "question", got "${params.icon}"`);
    	      hide(icon);
    	      return;
    	    }
    	    show(icon);

    	    // Custom or default content
    	    setContent(icon, params);
    	    applyStyles(icon, params);

    	    // Animate icon
    	    addClass(icon, params.showClass && params.showClass.icon);

    	    // Re-adjust the success icon on system theme change
    	    const colorSchemeQueryList = window.matchMedia('(prefers-color-scheme: dark)');
    	    colorSchemeQueryList.addEventListener('change', adjustSuccessIconBackgroundColor);
    	  };

    	  /**
    	   * @param {HTMLElement} icon
    	   * @param {SweetAlertOptions} params
    	   */
    	  const applyStyles = (icon, params) => {
    	    for (const [iconType, iconClassName] of Object.entries(iconTypes)) {
    	      if (params.icon !== iconType) {
    	        removeClass(icon, iconClassName);
    	      }
    	    }
    	    addClass(icon, params.icon && iconTypes[params.icon]);

    	    // Icon color
    	    setColor(icon, params);

    	    // Success icon background color
    	    adjustSuccessIconBackgroundColor();

    	    // Custom class
    	    applyCustomClass(icon, params, 'icon');
    	  };

    	  // Adjust success icon background color to match the popup background color
    	  const adjustSuccessIconBackgroundColor = () => {
    	    const popup = getPopup();
    	    if (!popup) {
    	      return;
    	    }
    	    const popupBackgroundColor = window.getComputedStyle(popup).getPropertyValue('background-color');
    	    /** @type {NodeListOf<HTMLElement>} */
    	    const successIconParts = popup.querySelectorAll('[class^=swal2-success-circular-line], .swal2-success-fix');
    	    for (let i = 0; i < successIconParts.length; i++) {
    	      successIconParts[i].style.backgroundColor = popupBackgroundColor;
    	    }
    	  };
    	  const successIconHtml = `
  <div class="swal2-success-circular-line-left"></div>
  <span class="swal2-success-line-tip"></span> <span class="swal2-success-line-long"></span>
  <div class="swal2-success-ring"></div> <div class="swal2-success-fix"></div>
  <div class="swal2-success-circular-line-right"></div>
`;
    	  const errorIconHtml = `
  <span class="swal2-x-mark">
    <span class="swal2-x-mark-line-left"></span>
    <span class="swal2-x-mark-line-right"></span>
  </span>
`;

    	  /**
    	   * @param {HTMLElement} icon
    	   * @param {SweetAlertOptions} params
    	   */
    	  const setContent = (icon, params) => {
    	    if (!params.icon && !params.iconHtml) {
    	      return;
    	    }
    	    let oldContent = icon.innerHTML;
    	    let newContent = '';
    	    if (params.iconHtml) {
    	      newContent = iconContent(params.iconHtml);
    	    } else if (params.icon === 'success') {
    	      newContent = successIconHtml;
    	      oldContent = oldContent.replace(/ style=".*?"/g, ''); // undo adjustSuccessIconBackgroundColor()
    	    } else if (params.icon === 'error') {
    	      newContent = errorIconHtml;
    	    } else if (params.icon) {
    	      const defaultIconHtml = {
    	        question: '?',
    	        warning: '!',
    	        info: 'i'
    	      };
    	      newContent = iconContent(defaultIconHtml[params.icon]);
    	    }
    	    if (oldContent.trim() !== newContent.trim()) {
    	      setInnerHtml(icon, newContent);
    	    }
    	  };

    	  /**
    	   * @param {HTMLElement} icon
    	   * @param {SweetAlertOptions} params
    	   */
    	  const setColor = (icon, params) => {
    	    if (!params.iconColor) {
    	      return;
    	    }
    	    icon.style.color = params.iconColor;
    	    icon.style.borderColor = params.iconColor;
    	    for (const sel of ['.swal2-success-line-tip', '.swal2-success-line-long', '.swal2-x-mark-line-left', '.swal2-x-mark-line-right']) {
    	      setStyle(icon, sel, 'background-color', params.iconColor);
    	    }
    	    setStyle(icon, '.swal2-success-ring', 'border-color', params.iconColor);
    	  };

    	  /**
    	   * @param {string} content
    	   * @returns {string}
    	   */
    	  const iconContent = content => `<div class="${swalClasses['icon-content']}">${content}</div>`;

    	  /**
    	   * @param {SweetAlert} instance
    	   * @param {SweetAlertOptions} params
    	   */
    	  const renderImage = (instance, params) => {
    	    const image = getImage();
    	    if (!image) {
    	      return;
    	    }
    	    if (!params.imageUrl) {
    	      hide(image);
    	      return;
    	    }
    	    show(image, '');

    	    // Src, alt
    	    image.setAttribute('src', params.imageUrl);
    	    image.setAttribute('alt', params.imageAlt || '');

    	    // Width, height
    	    applyNumericalStyle(image, 'width', params.imageWidth);
    	    applyNumericalStyle(image, 'height', params.imageHeight);

    	    // Class
    	    image.className = swalClasses.image;
    	    applyCustomClass(image, params, 'image');
    	  };

    	  let dragging = false;
    	  let mousedownX = 0;
    	  let mousedownY = 0;
    	  let initialX = 0;
    	  let initialY = 0;

    	  /**
    	   * @param {HTMLElement} popup
    	   */
    	  const addDraggableListeners = popup => {
    	    popup.addEventListener('mousedown', down);
    	    document.body.addEventListener('mousemove', move);
    	    popup.addEventListener('mouseup', up);
    	    popup.addEventListener('touchstart', down);
    	    document.body.addEventListener('touchmove', move);
    	    popup.addEventListener('touchend', up);
    	  };

    	  /**
    	   * @param {HTMLElement} popup
    	   */
    	  const removeDraggableListeners = popup => {
    	    popup.removeEventListener('mousedown', down);
    	    document.body.removeEventListener('mousemove', move);
    	    popup.removeEventListener('mouseup', up);
    	    popup.removeEventListener('touchstart', down);
    	    document.body.removeEventListener('touchmove', move);
    	    popup.removeEventListener('touchend', up);
    	  };

    	  /**
    	   * @param {MouseEvent | TouchEvent} event
    	   */
    	  const down = event => {
    	    const popup = getPopup();
    	    if (event.target === popup || getIcon().contains(/** @type {HTMLElement} */event.target)) {
    	      dragging = true;
    	      const clientXY = getClientXY(event);
    	      mousedownX = clientXY.clientX;
    	      mousedownY = clientXY.clientY;
    	      initialX = parseInt(popup.style.insetInlineStart) || 0;
    	      initialY = parseInt(popup.style.insetBlockStart) || 0;
    	      addClass(popup, 'swal2-dragging');
    	    }
    	  };

    	  /**
    	   * @param {MouseEvent | TouchEvent} event
    	   */
    	  const move = event => {
    	    const popup = getPopup();
    	    if (dragging) {
    	      let {
    	        clientX,
    	        clientY
    	      } = getClientXY(event);
    	      popup.style.insetInlineStart = `${initialX + (clientX - mousedownX)}px`;
    	      popup.style.insetBlockStart = `${initialY + (clientY - mousedownY)}px`;
    	    }
    	  };
    	  const up = () => {
    	    const popup = getPopup();
    	    dragging = false;
    	    removeClass(popup, 'swal2-dragging');
    	  };

    	  /**
    	   * @param {MouseEvent | TouchEvent} event
    	   * @returns {{ clientX: number, clientY: number }}
    	   */
    	  const getClientXY = event => {
    	    let clientX = 0,
    	      clientY = 0;
    	    if (event.type.startsWith('mouse')) {
    	      clientX = /** @type {MouseEvent} */event.clientX;
    	      clientY = /** @type {MouseEvent} */event.clientY;
    	    } else if (event.type.startsWith('touch')) {
    	      clientX = /** @type {TouchEvent} */event.touches[0].clientX;
    	      clientY = /** @type {TouchEvent} */event.touches[0].clientY;
    	    }
    	    return {
    	      clientX,
    	      clientY
    	    };
    	  };

    	  /**
    	   * @param {SweetAlert} instance
    	   * @param {SweetAlertOptions} params
    	   */
    	  const renderPopup = (instance, params) => {
    	    const container = getContainer();
    	    const popup = getPopup();
    	    if (!container || !popup) {
    	      return;
    	    }

    	    // Width
    	    // https://github.com/sweetalert2/sweetalert2/issues/2170
    	    if (params.toast) {
    	      applyNumericalStyle(container, 'width', params.width);
    	      popup.style.width = '100%';
    	      const loader = getLoader();
    	      if (loader) {
    	        popup.insertBefore(loader, getIcon());
    	      }
    	    } else {
    	      applyNumericalStyle(popup, 'width', params.width);
    	    }

    	    // Padding
    	    applyNumericalStyle(popup, 'padding', params.padding);

    	    // Color
    	    if (params.color) {
    	      popup.style.color = params.color;
    	    }

    	    // Background
    	    if (params.background) {
    	      popup.style.background = params.background;
    	    }
    	    hide(getValidationMessage());

    	    // Classes
    	    addClasses$1(popup, params);
    	    if (params.draggable && !params.toast) {
    	      addClass(popup, swalClasses.draggable);
    	      addDraggableListeners(popup);
    	    } else {
    	      removeClass(popup, swalClasses.draggable);
    	      removeDraggableListeners(popup);
    	    }
    	  };

    	  /**
    	   * @param {HTMLElement} popup
    	   * @param {SweetAlertOptions} params
    	   */
    	  const addClasses$1 = (popup, params) => {
    	    const showClass = params.showClass || {};
    	    // Default Class + showClass when updating Swal.update({})
    	    popup.className = `${swalClasses.popup} ${isVisible$1(popup) ? showClass.popup : ''}`;
    	    if (params.toast) {
    	      addClass([document.documentElement, document.body], swalClasses['toast-shown']);
    	      addClass(popup, swalClasses.toast);
    	    } else {
    	      addClass(popup, swalClasses.modal);
    	    }

    	    // Custom class
    	    applyCustomClass(popup, params, 'popup');
    	    // TODO: remove in the next major
    	    if (typeof params.customClass === 'string') {
    	      addClass(popup, params.customClass);
    	    }

    	    // Icon class (#1842)
    	    if (params.icon) {
    	      addClass(popup, swalClasses[`icon-${params.icon}`]);
    	    }
    	  };

    	  /**
    	   * @param {SweetAlert} instance
    	   * @param {SweetAlertOptions} params
    	   */
    	  const renderProgressSteps = (instance, params) => {
    	    const progressStepsContainer = getProgressSteps();
    	    if (!progressStepsContainer) {
    	      return;
    	    }
    	    const {
    	      progressSteps,
    	      currentProgressStep
    	    } = params;
    	    if (!progressSteps || progressSteps.length === 0 || currentProgressStep === undefined) {
    	      hide(progressStepsContainer);
    	      return;
    	    }
    	    show(progressStepsContainer);
    	    progressStepsContainer.textContent = '';
    	    if (currentProgressStep >= progressSteps.length) {
    	      warn('Invalid currentProgressStep parameter, it should be less than progressSteps.length ' + '(currentProgressStep like JS arrays starts from 0)');
    	    }
    	    progressSteps.forEach((step, index) => {
    	      const stepEl = createStepElement(step);
    	      progressStepsContainer.appendChild(stepEl);
    	      if (index === currentProgressStep) {
    	        addClass(stepEl, swalClasses['active-progress-step']);
    	      }
    	      if (index !== progressSteps.length - 1) {
    	        const lineEl = createLineElement(params);
    	        progressStepsContainer.appendChild(lineEl);
    	      }
    	    });
    	  };

    	  /**
    	   * @param {string} step
    	   * @returns {HTMLLIElement}
    	   */
    	  const createStepElement = step => {
    	    const stepEl = document.createElement('li');
    	    addClass(stepEl, swalClasses['progress-step']);
    	    setInnerHtml(stepEl, step);
    	    return stepEl;
    	  };

    	  /**
    	   * @param {SweetAlertOptions} params
    	   * @returns {HTMLLIElement}
    	   */
    	  const createLineElement = params => {
    	    const lineEl = document.createElement('li');
    	    addClass(lineEl, swalClasses['progress-step-line']);
    	    if (params.progressStepsDistance) {
    	      applyNumericalStyle(lineEl, 'width', params.progressStepsDistance);
    	    }
    	    return lineEl;
    	  };

    	  /**
    	   * @param {SweetAlert} instance
    	   * @param {SweetAlertOptions} params
    	   */
    	  const renderTitle = (instance, params) => {
    	    const title = getTitle();
    	    if (!title) {
    	      return;
    	    }
    	    showWhenInnerHtmlPresent(title);
    	    toggle(title, params.title || params.titleText, 'block');
    	    if (params.title) {
    	      parseHtmlToContainer(params.title, title);
    	    }
    	    if (params.titleText) {
    	      title.innerText = params.titleText;
    	    }

    	    // Custom class
    	    applyCustomClass(title, params, 'title');
    	  };

    	  /**
    	   * @param {SweetAlert} instance
    	   * @param {SweetAlertOptions} params
    	   */
    	  const render = (instance, params) => {
    	    renderPopup(instance, params);
    	    renderContainer(instance, params);
    	    renderProgressSteps(instance, params);
    	    renderIcon(instance, params);
    	    renderImage(instance, params);
    	    renderTitle(instance, params);
    	    renderCloseButton(instance, params);
    	    renderContent(instance, params);
    	    renderActions(instance, params);
    	    renderFooter(instance, params);
    	    const popup = getPopup();
    	    if (typeof params.didRender === 'function' && popup) {
    	      params.didRender(popup);
    	    }
    	    globalState.eventEmitter.emit('didRender', popup);
    	  };

    	  /*
    	   * Global function to determine if SweetAlert2 popup is shown
    	   */
    	  const isVisible = () => {
    	    return isVisible$1(getPopup());
    	  };

    	  /*
    	   * Global function to click 'Confirm' button
    	   */
    	  const clickConfirm = () => {
    	    var _dom$getConfirmButton;
    	    return (_dom$getConfirmButton = getConfirmButton()) === null || _dom$getConfirmButton === undefined ? undefined : _dom$getConfirmButton.click();
    	  };

    	  /*
    	   * Global function to click 'Deny' button
    	   */
    	  const clickDeny = () => {
    	    var _dom$getDenyButton;
    	    return (_dom$getDenyButton = getDenyButton()) === null || _dom$getDenyButton === undefined ? undefined : _dom$getDenyButton.click();
    	  };

    	  /*
    	   * Global function to click 'Cancel' button
    	   */
    	  const clickCancel = () => {
    	    var _dom$getCancelButton;
    	    return (_dom$getCancelButton = getCancelButton()) === null || _dom$getCancelButton === undefined ? undefined : _dom$getCancelButton.click();
    	  };

    	  /** @typedef {'cancel' | 'backdrop' | 'close' | 'esc' | 'timer'} DismissReason */

    	  /** @type {Record<DismissReason, DismissReason>} */
    	  const DismissReason = Object.freeze({
    	    cancel: 'cancel',
    	    backdrop: 'backdrop',
    	    close: 'close',
    	    esc: 'esc',
    	    timer: 'timer'
    	  });

    	  /**
    	   * @param {GlobalState} globalState
    	   */
    	  const removeKeydownHandler = globalState => {
    	    if (globalState.keydownTarget && globalState.keydownHandlerAdded) {
    	      globalState.keydownTarget.removeEventListener('keydown', globalState.keydownHandler, {
    	        capture: globalState.keydownListenerCapture
    	      });
    	      globalState.keydownHandlerAdded = false;
    	    }
    	  };

    	  /**
    	   * @param {GlobalState} globalState
    	   * @param {SweetAlertOptions} innerParams
    	   * @param {*} dismissWith
    	   */
    	  const addKeydownHandler = (globalState, innerParams, dismissWith) => {
    	    removeKeydownHandler(globalState);
    	    if (!innerParams.toast) {
    	      globalState.keydownHandler = e => keydownHandler(innerParams, e, dismissWith);
    	      globalState.keydownTarget = innerParams.keydownListenerCapture ? window : getPopup();
    	      globalState.keydownListenerCapture = innerParams.keydownListenerCapture;
    	      globalState.keydownTarget.addEventListener('keydown', globalState.keydownHandler, {
    	        capture: globalState.keydownListenerCapture
    	      });
    	      globalState.keydownHandlerAdded = true;
    	    }
    	  };

    	  /**
    	   * @param {number} index
    	   * @param {number} increment
    	   */
    	  const setFocus = (index, increment) => {
    	    var _dom$getPopup;
    	    const focusableElements = getFocusableElements();
    	    // search for visible elements and select the next possible match
    	    if (focusableElements.length) {
    	      index = index + increment;

    	      // rollover to first item
    	      if (index === focusableElements.length) {
    	        index = 0;

    	        // go to last item
    	      } else if (index === -1) {
    	        index = focusableElements.length - 1;
    	      }
    	      focusableElements[index].focus();
    	      return;
    	    }
    	    // no visible focusable elements, focus the popup
    	    (_dom$getPopup = getPopup()) === null || _dom$getPopup === undefined || _dom$getPopup.focus();
    	  };
    	  const arrowKeysNextButton = ['ArrowRight', 'ArrowDown'];
    	  const arrowKeysPreviousButton = ['ArrowLeft', 'ArrowUp'];

    	  /**
    	   * @param {SweetAlertOptions} innerParams
    	   * @param {KeyboardEvent} event
    	   * @param {Function} dismissWith
    	   */
    	  const keydownHandler = (innerParams, event, dismissWith) => {
    	    if (!innerParams) {
    	      return; // This instance has already been destroyed
    	    }

    	    // Ignore keydown during IME composition
    	    // https://developer.mozilla.org/en-US/docs/Web/API/Document/keydown_event#ignoring_keydown_during_ime_composition
    	    // https://github.com/sweetalert2/sweetalert2/issues/720
    	    // https://github.com/sweetalert2/sweetalert2/issues/2406
    	    if (event.isComposing || event.keyCode === 229) {
    	      return;
    	    }
    	    if (innerParams.stopKeydownPropagation) {
    	      event.stopPropagation();
    	    }

    	    // ENTER
    	    if (event.key === 'Enter') {
    	      handleEnter(event, innerParams);
    	    }

    	    // TAB
    	    else if (event.key === 'Tab') {
    	      handleTab(event);
    	    }

    	    // ARROWS - switch focus between buttons
    	    else if ([...arrowKeysNextButton, ...arrowKeysPreviousButton].includes(event.key)) {
    	      handleArrows(event.key);
    	    }

    	    // ESC
    	    else if (event.key === 'Escape') {
    	      handleEsc(event, innerParams, dismissWith);
    	    }
    	  };

    	  /**
    	   * @param {KeyboardEvent} event
    	   * @param {SweetAlertOptions} innerParams
    	   */
    	  const handleEnter = (event, innerParams) => {
    	    // https://github.com/sweetalert2/sweetalert2/issues/2386
    	    if (!callIfFunction(innerParams.allowEnterKey)) {
    	      return;
    	    }
    	    const input = getInput$1(getPopup(), innerParams.input);
    	    if (event.target && input && event.target instanceof HTMLElement && event.target.outerHTML === input.outerHTML) {
    	      if (['textarea', 'file'].includes(innerParams.input)) {
    	        return; // do not submit
    	      }
    	      clickConfirm();
    	      event.preventDefault();
    	    }
    	  };

    	  /**
    	   * @param {KeyboardEvent} event
    	   */
    	  const handleTab = event => {
    	    const targetElement = event.target;
    	    const focusableElements = getFocusableElements();
    	    let btnIndex = -1;
    	    for (let i = 0; i < focusableElements.length; i++) {
    	      if (targetElement === focusableElements[i]) {
    	        btnIndex = i;
    	        break;
    	      }
    	    }

    	    // Cycle to the next button
    	    if (!event.shiftKey) {
    	      setFocus(btnIndex, 1);
    	    }

    	    // Cycle to the prev button
    	    else {
    	      setFocus(btnIndex, -1);
    	    }
    	    event.stopPropagation();
    	    event.preventDefault();
    	  };

    	  /**
    	   * @param {string} key
    	   */
    	  const handleArrows = key => {
    	    const actions = getActions();
    	    const confirmButton = getConfirmButton();
    	    const denyButton = getDenyButton();
    	    const cancelButton = getCancelButton();
    	    if (!actions || !confirmButton || !denyButton || !cancelButton) {
    	      return;
    	    }
    	    /** @type HTMLElement[] */
    	    const buttons = [confirmButton, denyButton, cancelButton];
    	    if (document.activeElement instanceof HTMLElement && !buttons.includes(document.activeElement)) {
    	      return;
    	    }
    	    const sibling = arrowKeysNextButton.includes(key) ? 'nextElementSibling' : 'previousElementSibling';
    	    let buttonToFocus = document.activeElement;
    	    if (!buttonToFocus) {
    	      return;
    	    }
    	    for (let i = 0; i < actions.children.length; i++) {
    	      buttonToFocus = buttonToFocus[sibling];
    	      if (!buttonToFocus) {
    	        return;
    	      }
    	      if (buttonToFocus instanceof HTMLButtonElement && isVisible$1(buttonToFocus)) {
    	        break;
    	      }
    	    }
    	    if (buttonToFocus instanceof HTMLButtonElement) {
    	      buttonToFocus.focus();
    	    }
    	  };

    	  /**
    	   * @param {KeyboardEvent} event
    	   * @param {SweetAlertOptions} innerParams
    	   * @param {Function} dismissWith
    	   */
    	  const handleEsc = (event, innerParams, dismissWith) => {
    	    if (callIfFunction(innerParams.allowEscapeKey)) {
    	      event.preventDefault();
    	      dismissWith(DismissReason.esc);
    	    }
    	  };

    	  /**
    	   * This module contains `WeakMap`s for each effectively-"private  property" that a `Swal` has.
    	   * For example, to set the private property "foo" of `this` to "bar", you can `privateProps.foo.set(this, 'bar')`
    	   * This is the approach that Babel will probably take to implement private methods/fields
    	   *   https://github.com/tc39/proposal-private-methods
    	   *   https://github.com/babel/babel/pull/7555
    	   * Once we have the changes from that PR in Babel, and our core class fits reasonable in *one module*
    	   *   then we can use that language feature.
    	   */

    	  var privateMethods = {
    	    swalPromiseResolve: new WeakMap(),
    	    swalPromiseReject: new WeakMap()
    	  };

    	  // From https://developer.paciellogroup.com/blog/2018/06/the-current-state-of-modal-dialog-accessibility/
    	  // Adding aria-hidden="true" to elements outside of the active modal dialog ensures that
    	  // elements not within the active modal dialog will not be surfaced if a user opens a screen
    	  // readers list of elements (headings, form controls, landmarks, etc.) in the document.

    	  const setAriaHidden = () => {
    	    const container = getContainer();
    	    const bodyChildren = Array.from(document.body.children);
    	    bodyChildren.forEach(el => {
    	      if (el.contains(container)) {
    	        return;
    	      }
    	      if (el.hasAttribute('aria-hidden')) {
    	        el.setAttribute('data-previous-aria-hidden', el.getAttribute('aria-hidden') || '');
    	      }
    	      el.setAttribute('aria-hidden', 'true');
    	    });
    	  };
    	  const unsetAriaHidden = () => {
    	    const bodyChildren = Array.from(document.body.children);
    	    bodyChildren.forEach(el => {
    	      if (el.hasAttribute('data-previous-aria-hidden')) {
    	        el.setAttribute('aria-hidden', el.getAttribute('data-previous-aria-hidden') || '');
    	        el.removeAttribute('data-previous-aria-hidden');
    	      } else {
    	        el.removeAttribute('aria-hidden');
    	      }
    	    });
    	  };

    	  // @ts-ignore
    	  const isSafariOrIOS = typeof window !== 'undefined' && !!window.GestureEvent; // true for Safari desktop + all iOS browsers https://stackoverflow.com/a/70585394

    	  /**
    	   * Fix iOS scrolling
    	   * http://stackoverflow.com/q/39626302
    	   */
    	  const iOSfix = () => {
    	    if (isSafariOrIOS && !hasClass(document.body, swalClasses.iosfix)) {
    	      const offset = document.body.scrollTop;
    	      document.body.style.top = `${offset * -1}px`;
    	      addClass(document.body, swalClasses.iosfix);
    	      lockBodyScroll();
    	    }
    	  };

    	  /**
    	   * https://github.com/sweetalert2/sweetalert2/issues/1246
    	   */
    	  const lockBodyScroll = () => {
    	    const container = getContainer();
    	    if (!container) {
    	      return;
    	    }
    	    /** @type {boolean} */
    	    let preventTouchMove;
    	    /**
    	     * @param {TouchEvent} event
    	     */
    	    container.ontouchstart = event => {
    	      preventTouchMove = shouldPreventTouchMove(event);
    	    };
    	    /**
    	     * @param {TouchEvent} event
    	     */
    	    container.ontouchmove = event => {
    	      if (preventTouchMove) {
    	        event.preventDefault();
    	        event.stopPropagation();
    	      }
    	    };
    	  };

    	  /**
    	   * @param {TouchEvent} event
    	   * @returns {boolean}
    	   */
    	  const shouldPreventTouchMove = event => {
    	    const target = event.target;
    	    const container = getContainer();
    	    const htmlContainer = getHtmlContainer();
    	    if (!container || !htmlContainer) {
    	      return false;
    	    }
    	    if (isStylus(event) || isZoom(event)) {
    	      return false;
    	    }
    	    if (target === container) {
    	      return true;
    	    }
    	    if (!isScrollable(container) && target instanceof HTMLElement && target.tagName !== 'INPUT' &&
    	    // #1603
    	    target.tagName !== 'TEXTAREA' &&
    	    // #2266
    	    !(isScrollable(htmlContainer) &&
    	    // #1944
    	    htmlContainer.contains(target))) {
    	      return true;
    	    }
    	    return false;
    	  };

    	  /**
    	   * https://github.com/sweetalert2/sweetalert2/issues/1786
    	   *
    	   * @param {*} event
    	   * @returns {boolean}
    	   */
    	  const isStylus = event => {
    	    return event.touches && event.touches.length && event.touches[0].touchType === 'stylus';
    	  };

    	  /**
    	   * https://github.com/sweetalert2/sweetalert2/issues/1891
    	   *
    	   * @param {TouchEvent} event
    	   * @returns {boolean}
    	   */
    	  const isZoom = event => {
    	    return event.touches && event.touches.length > 1;
    	  };
    	  const undoIOSfix = () => {
    	    if (hasClass(document.body, swalClasses.iosfix)) {
    	      const offset = parseInt(document.body.style.top, 10);
    	      removeClass(document.body, swalClasses.iosfix);
    	      document.body.style.top = '';
    	      document.body.scrollTop = offset * -1;
    	    }
    	  };

    	  /**
    	   * Measure scrollbar width for padding body during modal show/hide
    	   * https://github.com/twbs/bootstrap/blob/master/js/src/modal.js
    	   *
    	   * @returns {number}
    	   */
    	  const measureScrollbar = () => {
    	    const scrollDiv = document.createElement('div');
    	    scrollDiv.className = swalClasses['scrollbar-measure'];
    	    document.body.appendChild(scrollDiv);
    	    const scrollbarWidth = scrollDiv.getBoundingClientRect().width - scrollDiv.clientWidth;
    	    document.body.removeChild(scrollDiv);
    	    return scrollbarWidth;
    	  };

    	  /**
    	   * Remember state in cases where opening and handling a modal will fiddle with it.
    	   * @type {number | null}
    	   */
    	  let previousBodyPadding = null;

    	  /**
    	   * @param {string} initialBodyOverflow
    	   */
    	  const replaceScrollbarWithPadding = initialBodyOverflow => {
    	    // for queues, do not do this more than once
    	    if (previousBodyPadding !== null) {
    	      return;
    	    }
    	    // if the body has overflow
    	    if (document.body.scrollHeight > window.innerHeight || initialBodyOverflow === 'scroll' // https://github.com/sweetalert2/sweetalert2/issues/2663
    	    ) {
    	      // add padding so the content doesn't shift after removal of scrollbar
    	      previousBodyPadding = parseInt(window.getComputedStyle(document.body).getPropertyValue('padding-right'));
    	      document.body.style.paddingRight = `${previousBodyPadding + measureScrollbar()}px`;
    	    }
    	  };
    	  const undoReplaceScrollbarWithPadding = () => {
    	    if (previousBodyPadding !== null) {
    	      document.body.style.paddingRight = `${previousBodyPadding}px`;
    	      previousBodyPadding = null;
    	    }
    	  };

    	  /**
    	   * @param {SweetAlert} instance
    	   * @param {HTMLElement} container
    	   * @param {boolean} returnFocus
    	   * @param {Function} didClose
    	   */
    	  function removePopupAndResetState(instance, container, returnFocus, didClose) {
    	    if (isToast()) {
    	      triggerDidCloseAndDispose(instance, didClose);
    	    } else {
    	      restoreActiveElement(returnFocus).then(() => triggerDidCloseAndDispose(instance, didClose));
    	      removeKeydownHandler(globalState);
    	    }

    	    // workaround for https://github.com/sweetalert2/sweetalert2/issues/2088
    	    // for some reason removing the container in Safari will scroll the document to bottom
    	    if (isSafariOrIOS) {
    	      container.setAttribute('style', 'display:none !important');
    	      container.removeAttribute('class');
    	      container.innerHTML = '';
    	    } else {
    	      container.remove();
    	    }
    	    if (isModal()) {
    	      undoReplaceScrollbarWithPadding();
    	      undoIOSfix();
    	      unsetAriaHidden();
    	    }
    	    removeBodyClasses();
    	  }

    	  /**
    	   * Remove SweetAlert2 classes from body
    	   */
    	  function removeBodyClasses() {
    	    removeClass([document.documentElement, document.body], [swalClasses.shown, swalClasses['height-auto'], swalClasses['no-backdrop'], swalClasses['toast-shown']]);
    	  }

    	  /**
    	   * Instance method to close sweetAlert
    	   *
    	   * @param {any} resolveValue
    	   */
    	  function close(resolveValue) {
    	    resolveValue = prepareResolveValue(resolveValue);
    	    const swalPromiseResolve = privateMethods.swalPromiseResolve.get(this);
    	    const didClose = triggerClosePopup(this);
    	    if (this.isAwaitingPromise) {
    	      // A swal awaiting for a promise (after a click on Confirm or Deny) cannot be dismissed anymore #2335
    	      if (!resolveValue.isDismissed) {
    	        handleAwaitingPromise(this);
    	        swalPromiseResolve(resolveValue);
    	      }
    	    } else if (didClose) {
    	      // Resolve Swal promise
    	      swalPromiseResolve(resolveValue);
    	    }
    	  }
    	  const triggerClosePopup = instance => {
    	    const popup = getPopup();
    	    if (!popup) {
    	      return false;
    	    }
    	    const innerParams = privateProps.innerParams.get(instance);
    	    if (!innerParams || hasClass(popup, innerParams.hideClass.popup)) {
    	      return false;
    	    }
    	    removeClass(popup, innerParams.showClass.popup);
    	    addClass(popup, innerParams.hideClass.popup);
    	    const backdrop = getContainer();
    	    removeClass(backdrop, innerParams.showClass.backdrop);
    	    addClass(backdrop, innerParams.hideClass.backdrop);
    	    handlePopupAnimation(instance, popup, innerParams);
    	    return true;
    	  };

    	  /**
    	   * @param {any} error
    	   */
    	  function rejectPromise(error) {
    	    const rejectPromise = privateMethods.swalPromiseReject.get(this);
    	    handleAwaitingPromise(this);
    	    if (rejectPromise) {
    	      // Reject Swal promise
    	      rejectPromise(error);
    	    }
    	  }

    	  /**
    	   * @param {SweetAlert} instance
    	   */
    	  const handleAwaitingPromise = instance => {
    	    if (instance.isAwaitingPromise) {
    	      delete instance.isAwaitingPromise;
    	      // The instance might have been previously partly destroyed, we must resume the destroy process in this case #2335
    	      if (!privateProps.innerParams.get(instance)) {
    	        instance._destroy();
    	      }
    	    }
    	  };

    	  /**
    	   * @param {any} resolveValue
    	   * @returns {SweetAlertResult}
    	   */
    	  const prepareResolveValue = resolveValue => {
    	    // When user calls Swal.close()
    	    if (typeof resolveValue === 'undefined') {
    	      return {
    	        isConfirmed: false,
    	        isDenied: false,
    	        isDismissed: true
    	      };
    	    }
    	    return Object.assign({
    	      isConfirmed: false,
    	      isDenied: false,
    	      isDismissed: false
    	    }, resolveValue);
    	  };

    	  /**
    	   * @param {SweetAlert} instance
    	   * @param {HTMLElement} popup
    	   * @param {SweetAlertOptions} innerParams
    	   */
    	  const handlePopupAnimation = (instance, popup, innerParams) => {
    	    var _globalState$eventEmi;
    	    const container = getContainer();
    	    // If animation is supported, animate
    	    const animationIsSupported = hasCssAnimation(popup);
    	    if (typeof innerParams.willClose === 'function') {
    	      innerParams.willClose(popup);
    	    }
    	    (_globalState$eventEmi = globalState.eventEmitter) === null || _globalState$eventEmi === undefined || _globalState$eventEmi.emit('willClose', popup);
    	    if (animationIsSupported) {
    	      animatePopup(instance, popup, container, innerParams.returnFocus, innerParams.didClose);
    	    } else {
    	      // Otherwise, remove immediately
    	      removePopupAndResetState(instance, container, innerParams.returnFocus, innerParams.didClose);
    	    }
    	  };

    	  /**
    	   * @param {SweetAlert} instance
    	   * @param {HTMLElement} popup
    	   * @param {HTMLElement} container
    	   * @param {boolean} returnFocus
    	   * @param {Function} didClose
    	   */
    	  const animatePopup = (instance, popup, container, returnFocus, didClose) => {
    	    globalState.swalCloseEventFinishedCallback = removePopupAndResetState.bind(null, instance, container, returnFocus, didClose);
    	    /**
    	     * @param {AnimationEvent | TransitionEvent} e
    	     */
    	    const swalCloseAnimationFinished = function (e) {
    	      if (e.target === popup) {
    	        var _globalState$swalClos;
    	        (_globalState$swalClos = globalState.swalCloseEventFinishedCallback) === null || _globalState$swalClos === undefined || _globalState$swalClos.call(globalState);
    	        delete globalState.swalCloseEventFinishedCallback;
    	        popup.removeEventListener('animationend', swalCloseAnimationFinished);
    	        popup.removeEventListener('transitionend', swalCloseAnimationFinished);
    	      }
    	    };
    	    popup.addEventListener('animationend', swalCloseAnimationFinished);
    	    popup.addEventListener('transitionend', swalCloseAnimationFinished);
    	  };

    	  /**
    	   * @param {SweetAlert} instance
    	   * @param {Function} didClose
    	   */
    	  const triggerDidCloseAndDispose = (instance, didClose) => {
    	    setTimeout(() => {
    	      var _globalState$eventEmi2;
    	      if (typeof didClose === 'function') {
    	        didClose.bind(instance.params)();
    	      }
    	      (_globalState$eventEmi2 = globalState.eventEmitter) === null || _globalState$eventEmi2 === undefined || _globalState$eventEmi2.emit('didClose');
    	      // instance might have been destroyed already
    	      if (instance._destroy) {
    	        instance._destroy();
    	      }
    	    });
    	  };

    	  /**
    	   * Shows loader (spinner), this is useful with AJAX requests.
    	   * By default the loader be shown instead of the "Confirm" button.
    	   *
    	   * @param {HTMLButtonElement | null} [buttonToReplace]
    	   */
    	  const showLoading = buttonToReplace => {
    	    let popup = getPopup();
    	    if (!popup) {
    	      new Swal();
    	    }
    	    popup = getPopup();
    	    if (!popup) {
    	      return;
    	    }
    	    const loader = getLoader();
    	    if (isToast()) {
    	      hide(getIcon());
    	    } else {
    	      replaceButton(popup, buttonToReplace);
    	    }
    	    show(loader);
    	    popup.setAttribute('data-loading', 'true');
    	    popup.setAttribute('aria-busy', 'true');
    	    popup.focus();
    	  };

    	  /**
    	   * @param {HTMLElement} popup
    	   * @param {HTMLButtonElement | null} [buttonToReplace]
    	   */
    	  const replaceButton = (popup, buttonToReplace) => {
    	    const actions = getActions();
    	    const loader = getLoader();
    	    if (!actions || !loader) {
    	      return;
    	    }
    	    if (!buttonToReplace && isVisible$1(getConfirmButton())) {
    	      buttonToReplace = getConfirmButton();
    	    }
    	    show(actions);
    	    if (buttonToReplace) {
    	      hide(buttonToReplace);
    	      loader.setAttribute('data-button-to-replace', buttonToReplace.className);
    	      actions.insertBefore(loader, buttonToReplace);
    	    }
    	    addClass([popup, actions], swalClasses.loading);
    	  };

    	  /**
    	   * @param {SweetAlert} instance
    	   * @param {SweetAlertOptions} params
    	   */
    	  const handleInputOptionsAndValue = (instance, params) => {
    	    if (params.input === 'select' || params.input === 'radio') {
    	      handleInputOptions(instance, params);
    	    } else if (['text', 'email', 'number', 'tel', 'textarea'].some(i => i === params.input) && (hasToPromiseFn(params.inputValue) || isPromise(params.inputValue))) {
    	      showLoading(getConfirmButton());
    	      handleInputValue(instance, params);
    	    }
    	  };

    	  /**
    	   * @param {SweetAlert} instance
    	   * @param {SweetAlertOptions} innerParams
    	   * @returns {SweetAlertInputValue}
    	   */
    	  const getInputValue = (instance, innerParams) => {
    	    const input = instance.getInput();
    	    if (!input) {
    	      return null;
    	    }
    	    switch (innerParams.input) {
    	      case 'checkbox':
    	        return getCheckboxValue(input);
    	      case 'radio':
    	        return getRadioValue(input);
    	      case 'file':
    	        return getFileValue(input);
    	      default:
    	        return innerParams.inputAutoTrim ? input.value.trim() : input.value;
    	    }
    	  };

    	  /**
    	   * @param {HTMLInputElement} input
    	   * @returns {number}
    	   */
    	  const getCheckboxValue = input => input.checked ? 1 : 0;

    	  /**
    	   * @param {HTMLInputElement} input
    	   * @returns {string | null}
    	   */
    	  const getRadioValue = input => input.checked ? input.value : null;

    	  /**
    	   * @param {HTMLInputElement} input
    	   * @returns {FileList | File | null}
    	   */
    	  const getFileValue = input => input.files && input.files.length ? input.getAttribute('multiple') !== null ? input.files : input.files[0] : null;

    	  /**
    	   * @param {SweetAlert} instance
    	   * @param {SweetAlertOptions} params
    	   */
    	  const handleInputOptions = (instance, params) => {
    	    const popup = getPopup();
    	    if (!popup) {
    	      return;
    	    }
    	    /**
    	     * @param {Record<string, any>} inputOptions
    	     */
    	    const processInputOptions = inputOptions => {
    	      if (params.input === 'select') {
    	        populateSelectOptions(popup, formatInputOptions(inputOptions), params);
    	      } else if (params.input === 'radio') {
    	        populateRadioOptions(popup, formatInputOptions(inputOptions), params);
    	      }
    	    };
    	    if (hasToPromiseFn(params.inputOptions) || isPromise(params.inputOptions)) {
    	      showLoading(getConfirmButton());
    	      asPromise(params.inputOptions).then(inputOptions => {
    	        instance.hideLoading();
    	        processInputOptions(inputOptions);
    	      });
    	    } else if (typeof params.inputOptions === 'object') {
    	      processInputOptions(params.inputOptions);
    	    } else {
    	      error(`Unexpected type of inputOptions! Expected object, Map or Promise, got ${typeof params.inputOptions}`);
    	    }
    	  };

    	  /**
    	   * @param {SweetAlert} instance
    	   * @param {SweetAlertOptions} params
    	   */
    	  const handleInputValue = (instance, params) => {
    	    const input = instance.getInput();
    	    if (!input) {
    	      return;
    	    }
    	    hide(input);
    	    asPromise(params.inputValue).then(inputValue => {
    	      input.value = params.input === 'number' ? `${parseFloat(inputValue) || 0}` : `${inputValue}`;
    	      show(input);
    	      input.focus();
    	      instance.hideLoading();
    	    }).catch(err => {
    	      error(`Error in inputValue promise: ${err}`);
    	      input.value = '';
    	      show(input);
    	      input.focus();
    	      instance.hideLoading();
    	    });
    	  };

    	  /**
    	   * @param {HTMLElement} popup
    	   * @param {InputOptionFlattened[]} inputOptions
    	   * @param {SweetAlertOptions} params
    	   */
    	  function populateSelectOptions(popup, inputOptions, params) {
    	    const select = getDirectChildByClass(popup, swalClasses.select);
    	    if (!select) {
    	      return;
    	    }
    	    /**
    	     * @param {HTMLElement} parent
    	     * @param {string} optionLabel
    	     * @param {string} optionValue
    	     */
    	    const renderOption = (parent, optionLabel, optionValue) => {
    	      const option = document.createElement('option');
    	      option.value = optionValue;
    	      setInnerHtml(option, optionLabel);
    	      option.selected = isSelected(optionValue, params.inputValue);
    	      parent.appendChild(option);
    	    };
    	    inputOptions.forEach(inputOption => {
    	      const optionValue = inputOption[0];
    	      const optionLabel = inputOption[1];
    	      // <optgroup> spec:
    	      // https://www.w3.org/TR/html401/interact/forms.html#h-17.6
    	      // "...all OPTGROUP elements must be specified directly within a SELECT element (i.e., groups may not be nested)..."
    	      // check whether this is a <optgroup>
    	      if (Array.isArray(optionLabel)) {
    	        // if it is an array, then it is an <optgroup>
    	        const optgroup = document.createElement('optgroup');
    	        optgroup.label = optionValue;
    	        optgroup.disabled = false; // not configurable for now
    	        select.appendChild(optgroup);
    	        optionLabel.forEach(o => renderOption(optgroup, o[1], o[0]));
    	      } else {
    	        // case of <option>
    	        renderOption(select, optionLabel, optionValue);
    	      }
    	    });
    	    select.focus();
    	  }

    	  /**
    	   * @param {HTMLElement} popup
    	   * @param {InputOptionFlattened[]} inputOptions
    	   * @param {SweetAlertOptions} params
    	   */
    	  function populateRadioOptions(popup, inputOptions, params) {
    	    const radio = getDirectChildByClass(popup, swalClasses.radio);
    	    if (!radio) {
    	      return;
    	    }
    	    inputOptions.forEach(inputOption => {
    	      const radioValue = inputOption[0];
    	      const radioLabel = inputOption[1];
    	      const radioInput = document.createElement('input');
    	      const radioLabelElement = document.createElement('label');
    	      radioInput.type = 'radio';
    	      radioInput.name = swalClasses.radio;
    	      radioInput.value = radioValue;
    	      if (isSelected(radioValue, params.inputValue)) {
    	        radioInput.checked = true;
    	      }
    	      const label = document.createElement('span');
    	      setInnerHtml(label, radioLabel);
    	      label.className = swalClasses.label;
    	      radioLabelElement.appendChild(radioInput);
    	      radioLabelElement.appendChild(label);
    	      radio.appendChild(radioLabelElement);
    	    });
    	    const radios = radio.querySelectorAll('input');
    	    if (radios.length) {
    	      radios[0].focus();
    	    }
    	  }

    	  /**
    	   * Converts `inputOptions` into an array of `[value, label]`s
    	   *
    	   * @param {Record<string, any>} inputOptions
    	   * @typedef {string[]} InputOptionFlattened
    	   * @returns {InputOptionFlattened[]}
    	   */
    	  const formatInputOptions = inputOptions => {
    	    /** @type {InputOptionFlattened[]} */
    	    const result = [];
    	    if (inputOptions instanceof Map) {
    	      inputOptions.forEach((value, key) => {
    	        let valueFormatted = value;
    	        if (typeof valueFormatted === 'object') {
    	          // case of <optgroup>
    	          valueFormatted = formatInputOptions(valueFormatted);
    	        }
    	        result.push([key, valueFormatted]);
    	      });
    	    } else {
    	      Object.keys(inputOptions).forEach(key => {
    	        let valueFormatted = inputOptions[key];
    	        if (typeof valueFormatted === 'object') {
    	          // case of <optgroup>
    	          valueFormatted = formatInputOptions(valueFormatted);
    	        }
    	        result.push([key, valueFormatted]);
    	      });
    	    }
    	    return result;
    	  };

    	  /**
    	   * @param {string} optionValue
    	   * @param {SweetAlertInputValue} inputValue
    	   * @returns {boolean}
    	   */
    	  const isSelected = (optionValue, inputValue) => {
    	    return !!inputValue && inputValue.toString() === optionValue.toString();
    	  };

    	  /**
    	   * @param {SweetAlert} instance
    	   */
    	  const handleConfirmButtonClick = instance => {
    	    const innerParams = privateProps.innerParams.get(instance);
    	    instance.disableButtons();
    	    if (innerParams.input) {
    	      handleConfirmOrDenyWithInput(instance, 'confirm');
    	    } else {
    	      confirm(instance, true);
    	    }
    	  };

    	  /**
    	   * @param {SweetAlert} instance
    	   */
    	  const handleDenyButtonClick = instance => {
    	    const innerParams = privateProps.innerParams.get(instance);
    	    instance.disableButtons();
    	    if (innerParams.returnInputValueOnDeny) {
    	      handleConfirmOrDenyWithInput(instance, 'deny');
    	    } else {
    	      deny(instance, false);
    	    }
    	  };

    	  /**
    	   * @param {SweetAlert} instance
    	   * @param {Function} dismissWith
    	   */
    	  const handleCancelButtonClick = (instance, dismissWith) => {
    	    instance.disableButtons();
    	    dismissWith(DismissReason.cancel);
    	  };

    	  /**
    	   * @param {SweetAlert} instance
    	   * @param {'confirm' | 'deny'} type
    	   */
    	  const handleConfirmOrDenyWithInput = (instance, type) => {
    	    const innerParams = privateProps.innerParams.get(instance);
    	    if (!innerParams.input) {
    	      error(`The "input" parameter is needed to be set when using returnInputValueOn${capitalizeFirstLetter(type)}`);
    	      return;
    	    }
    	    const input = instance.getInput();
    	    const inputValue = getInputValue(instance, innerParams);
    	    if (innerParams.inputValidator) {
    	      handleInputValidator(instance, inputValue, type);
    	    } else if (input && !input.checkValidity()) {
    	      instance.enableButtons();
    	      instance.showValidationMessage(innerParams.validationMessage || input.validationMessage);
    	    } else if (type === 'deny') {
    	      deny(instance, inputValue);
    	    } else {
    	      confirm(instance, inputValue);
    	    }
    	  };

    	  /**
    	   * @param {SweetAlert} instance
    	   * @param {SweetAlertInputValue} inputValue
    	   * @param {'confirm' | 'deny'} type
    	   */
    	  const handleInputValidator = (instance, inputValue, type) => {
    	    const innerParams = privateProps.innerParams.get(instance);
    	    instance.disableInput();
    	    const validationPromise = Promise.resolve().then(() => asPromise(innerParams.inputValidator(inputValue, innerParams.validationMessage)));
    	    validationPromise.then(validationMessage => {
    	      instance.enableButtons();
    	      instance.enableInput();
    	      if (validationMessage) {
    	        instance.showValidationMessage(validationMessage);
    	      } else if (type === 'deny') {
    	        deny(instance, inputValue);
    	      } else {
    	        confirm(instance, inputValue);
    	      }
    	    });
    	  };

    	  /**
    	   * @param {SweetAlert} instance
    	   * @param {any} value
    	   */
    	  const deny = (instance, value) => {
    	    const innerParams = privateProps.innerParams.get(instance || undefined);
    	    if (innerParams.showLoaderOnDeny) {
    	      showLoading(getDenyButton());
    	    }
    	    if (innerParams.preDeny) {
    	      instance.isAwaitingPromise = true; // Flagging the instance as awaiting a promise so it's own promise's reject/resolve methods doesn't get destroyed until the result from this preDeny's promise is received
    	      const preDenyPromise = Promise.resolve().then(() => asPromise(innerParams.preDeny(value, innerParams.validationMessage)));
    	      preDenyPromise.then(preDenyValue => {
    	        if (preDenyValue === false) {
    	          instance.hideLoading();
    	          handleAwaitingPromise(instance);
    	        } else {
    	          instance.close({
    	            isDenied: true,
    	            value: typeof preDenyValue === 'undefined' ? value : preDenyValue
    	          });
    	        }
    	      }).catch(error => rejectWith(instance || undefined, error));
    	    } else {
    	      instance.close({
    	        isDenied: true,
    	        value
    	      });
    	    }
    	  };

    	  /**
    	   * @param {SweetAlert} instance
    	   * @param {any} value
    	   */
    	  const succeedWith = (instance, value) => {
    	    instance.close({
    	      isConfirmed: true,
    	      value
    	    });
    	  };

    	  /**
    	   *
    	   * @param {SweetAlert} instance
    	   * @param {string} error
    	   */
    	  const rejectWith = (instance, error) => {
    	    instance.rejectPromise(error);
    	  };

    	  /**
    	   *
    	   * @param {SweetAlert} instance
    	   * @param {any} value
    	   */
    	  const confirm = (instance, value) => {
    	    const innerParams = privateProps.innerParams.get(instance || undefined);
    	    if (innerParams.showLoaderOnConfirm) {
    	      showLoading();
    	    }
    	    if (innerParams.preConfirm) {
    	      instance.resetValidationMessage();
    	      instance.isAwaitingPromise = true; // Flagging the instance as awaiting a promise so it's own promise's reject/resolve methods doesn't get destroyed until the result from this preConfirm's promise is received
    	      const preConfirmPromise = Promise.resolve().then(() => asPromise(innerParams.preConfirm(value, innerParams.validationMessage)));
    	      preConfirmPromise.then(preConfirmValue => {
    	        if (isVisible$1(getValidationMessage()) || preConfirmValue === false) {
    	          instance.hideLoading();
    	          handleAwaitingPromise(instance);
    	        } else {
    	          succeedWith(instance, typeof preConfirmValue === 'undefined' ? value : preConfirmValue);
    	        }
    	      }).catch(error => rejectWith(instance || undefined, error));
    	    } else {
    	      succeedWith(instance, value);
    	    }
    	  };

    	  /**
    	   * Hides loader and shows back the button which was hidden by .showLoading()
    	   */
    	  function hideLoading() {
    	    // do nothing if popup is closed
    	    const innerParams = privateProps.innerParams.get(this);
    	    if (!innerParams) {
    	      return;
    	    }
    	    const domCache = privateProps.domCache.get(this);
    	    hide(domCache.loader);
    	    if (isToast()) {
    	      if (innerParams.icon) {
    	        show(getIcon());
    	      }
    	    } else {
    	      showRelatedButton(domCache);
    	    }
    	    removeClass([domCache.popup, domCache.actions], swalClasses.loading);
    	    domCache.popup.removeAttribute('aria-busy');
    	    domCache.popup.removeAttribute('data-loading');
    	    domCache.confirmButton.disabled = false;
    	    domCache.denyButton.disabled = false;
    	    domCache.cancelButton.disabled = false;
    	  }
    	  const showRelatedButton = domCache => {
    	    const buttonToReplace = domCache.popup.getElementsByClassName(domCache.loader.getAttribute('data-button-to-replace'));
    	    if (buttonToReplace.length) {
    	      show(buttonToReplace[0], 'inline-block');
    	    } else if (allButtonsAreHidden()) {
    	      hide(domCache.actions);
    	    }
    	  };

    	  /**
    	   * Gets the input DOM node, this method works with input parameter.
    	   *
    	   * @returns {HTMLInputElement | null}
    	   */
    	  function getInput() {
    	    const innerParams = privateProps.innerParams.get(this);
    	    const domCache = privateProps.domCache.get(this);
    	    if (!domCache) {
    	      return null;
    	    }
    	    return getInput$1(domCache.popup, innerParams.input);
    	  }

    	  /**
    	   * @param {SweetAlert} instance
    	   * @param {string[]} buttons
    	   * @param {boolean} disabled
    	   */
    	  function setButtonsDisabled(instance, buttons, disabled) {
    	    const domCache = privateProps.domCache.get(instance);
    	    buttons.forEach(button => {
    	      domCache[button].disabled = disabled;
    	    });
    	  }

    	  /**
    	   * @param {HTMLInputElement | null} input
    	   * @param {boolean} disabled
    	   */
    	  function setInputDisabled(input, disabled) {
    	    const popup = getPopup();
    	    if (!popup || !input) {
    	      return;
    	    }
    	    if (input.type === 'radio') {
    	      /** @type {NodeListOf<HTMLInputElement>} */
    	      const radios = popup.querySelectorAll(`[name="${swalClasses.radio}"]`);
    	      for (let i = 0; i < radios.length; i++) {
    	        radios[i].disabled = disabled;
    	      }
    	    } else {
    	      input.disabled = disabled;
    	    }
    	  }

    	  /**
    	   * Enable all the buttons
    	   * @this {SweetAlert}
    	   */
    	  function enableButtons() {
    	    setButtonsDisabled(this, ['confirmButton', 'denyButton', 'cancelButton'], false);
    	  }

    	  /**
    	   * Disable all the buttons
    	   * @this {SweetAlert}
    	   */
    	  function disableButtons() {
    	    setButtonsDisabled(this, ['confirmButton', 'denyButton', 'cancelButton'], true);
    	  }

    	  /**
    	   * Enable the input field
    	   * @this {SweetAlert}
    	   */
    	  function enableInput() {
    	    setInputDisabled(this.getInput(), false);
    	  }

    	  /**
    	   * Disable the input field
    	   * @this {SweetAlert}
    	   */
    	  function disableInput() {
    	    setInputDisabled(this.getInput(), true);
    	  }

    	  /**
    	   * Show block with validation message
    	   *
    	   * @param {string} error
    	   * @this {SweetAlert}
    	   */
    	  function showValidationMessage(error) {
    	    const domCache = privateProps.domCache.get(this);
    	    const params = privateProps.innerParams.get(this);
    	    setInnerHtml(domCache.validationMessage, error);
    	    domCache.validationMessage.className = swalClasses['validation-message'];
    	    if (params.customClass && params.customClass.validationMessage) {
    	      addClass(domCache.validationMessage, params.customClass.validationMessage);
    	    }
    	    show(domCache.validationMessage);
    	    const input = this.getInput();
    	    if (input) {
    	      input.setAttribute('aria-invalid', 'true');
    	      input.setAttribute('aria-describedby', swalClasses['validation-message']);
    	      focusInput(input);
    	      addClass(input, swalClasses.inputerror);
    	    }
    	  }

    	  /**
    	   * Hide block with validation message
    	   *
    	   * @this {SweetAlert}
    	   */
    	  function resetValidationMessage() {
    	    const domCache = privateProps.domCache.get(this);
    	    if (domCache.validationMessage) {
    	      hide(domCache.validationMessage);
    	    }
    	    const input = this.getInput();
    	    if (input) {
    	      input.removeAttribute('aria-invalid');
    	      input.removeAttribute('aria-describedby');
    	      removeClass(input, swalClasses.inputerror);
    	    }
    	  }

    	  const defaultParams = {
    	    title: '',
    	    titleText: '',
    	    text: '',
    	    html: '',
    	    footer: '',
    	    icon: undefined,
    	    iconColor: undefined,
    	    iconHtml: undefined,
    	    template: undefined,
    	    toast: false,
    	    draggable: false,
    	    animation: true,
    	    theme: 'light',
    	    showClass: {
    	      popup: 'swal2-show',
    	      backdrop: 'swal2-backdrop-show',
    	      icon: 'swal2-icon-show'
    	    },
    	    hideClass: {
    	      popup: 'swal2-hide',
    	      backdrop: 'swal2-backdrop-hide',
    	      icon: 'swal2-icon-hide'
    	    },
    	    customClass: {},
    	    target: 'body',
    	    color: undefined,
    	    backdrop: true,
    	    heightAuto: true,
    	    allowOutsideClick: true,
    	    allowEscapeKey: true,
    	    allowEnterKey: true,
    	    stopKeydownPropagation: true,
    	    keydownListenerCapture: false,
    	    showConfirmButton: true,
    	    showDenyButton: false,
    	    showCancelButton: false,
    	    preConfirm: undefined,
    	    preDeny: undefined,
    	    confirmButtonText: 'OK',
    	    confirmButtonAriaLabel: '',
    	    confirmButtonColor: undefined,
    	    denyButtonText: 'No',
    	    denyButtonAriaLabel: '',
    	    denyButtonColor: undefined,
    	    cancelButtonText: 'Cancel',
    	    cancelButtonAriaLabel: '',
    	    cancelButtonColor: undefined,
    	    buttonsStyling: true,
    	    reverseButtons: false,
    	    focusConfirm: true,
    	    focusDeny: false,
    	    focusCancel: false,
    	    returnFocus: true,
    	    showCloseButton: false,
    	    closeButtonHtml: '&times;',
    	    closeButtonAriaLabel: 'Close this dialog',
    	    loaderHtml: '',
    	    showLoaderOnConfirm: false,
    	    showLoaderOnDeny: false,
    	    imageUrl: undefined,
    	    imageWidth: undefined,
    	    imageHeight: undefined,
    	    imageAlt: '',
    	    timer: undefined,
    	    timerProgressBar: false,
    	    width: undefined,
    	    padding: undefined,
    	    background: undefined,
    	    input: undefined,
    	    inputPlaceholder: '',
    	    inputLabel: '',
    	    inputValue: '',
    	    inputOptions: {},
    	    inputAutoFocus: true,
    	    inputAutoTrim: true,
    	    inputAttributes: {},
    	    inputValidator: undefined,
    	    returnInputValueOnDeny: false,
    	    validationMessage: undefined,
    	    grow: false,
    	    position: 'center',
    	    progressSteps: [],
    	    currentProgressStep: undefined,
    	    progressStepsDistance: undefined,
    	    willOpen: undefined,
    	    didOpen: undefined,
    	    didRender: undefined,
    	    willClose: undefined,
    	    didClose: undefined,
    	    didDestroy: undefined,
    	    scrollbarPadding: true
    	  };
    	  const updatableParams = ['allowEscapeKey', 'allowOutsideClick', 'background', 'buttonsStyling', 'cancelButtonAriaLabel', 'cancelButtonColor', 'cancelButtonText', 'closeButtonAriaLabel', 'closeButtonHtml', 'color', 'confirmButtonAriaLabel', 'confirmButtonColor', 'confirmButtonText', 'currentProgressStep', 'customClass', 'denyButtonAriaLabel', 'denyButtonColor', 'denyButtonText', 'didClose', 'didDestroy', 'draggable', 'footer', 'hideClass', 'html', 'icon', 'iconColor', 'iconHtml', 'imageAlt', 'imageHeight', 'imageUrl', 'imageWidth', 'preConfirm', 'preDeny', 'progressSteps', 'returnFocus', 'reverseButtons', 'showCancelButton', 'showCloseButton', 'showConfirmButton', 'showDenyButton', 'text', 'title', 'titleText', 'theme', 'willClose'];

    	  /** @type {Record<string, string | undefined>} */
    	  const deprecatedParams = {
    	    allowEnterKey: undefined
    	  };
    	  const toastIncompatibleParams = ['allowOutsideClick', 'allowEnterKey', 'backdrop', 'draggable', 'focusConfirm', 'focusDeny', 'focusCancel', 'returnFocus', 'heightAuto', 'keydownListenerCapture'];

    	  /**
    	   * Is valid parameter
    	   *
    	   * @param {string} paramName
    	   * @returns {boolean}
    	   */
    	  const isValidParameter = paramName => {
    	    return Object.prototype.hasOwnProperty.call(defaultParams, paramName);
    	  };

    	  /**
    	   * Is valid parameter for Swal.update() method
    	   *
    	   * @param {string} paramName
    	   * @returns {boolean}
    	   */
    	  const isUpdatableParameter = paramName => {
    	    return updatableParams.indexOf(paramName) !== -1;
    	  };

    	  /**
    	   * Is deprecated parameter
    	   *
    	   * @param {string} paramName
    	   * @returns {string | undefined}
    	   */
    	  const isDeprecatedParameter = paramName => {
    	    return deprecatedParams[paramName];
    	  };

    	  /**
    	   * @param {string} param
    	   */
    	  const checkIfParamIsValid = param => {
    	    if (!isValidParameter(param)) {
    	      warn(`Unknown parameter "${param}"`);
    	    }
    	  };

    	  /**
    	   * @param {string} param
    	   */
    	  const checkIfToastParamIsValid = param => {
    	    if (toastIncompatibleParams.includes(param)) {
    	      warn(`The parameter "${param}" is incompatible with toasts`);
    	    }
    	  };

    	  /**
    	   * @param {string} param
    	   */
    	  const checkIfParamIsDeprecated = param => {
    	    const isDeprecated = isDeprecatedParameter(param);
    	    if (isDeprecated) {
    	      warnAboutDeprecation(param, isDeprecated);
    	    }
    	  };

    	  /**
    	   * Show relevant warnings for given params
    	   *
    	   * @param {SweetAlertOptions} params
    	   */
    	  const showWarningsForParams = params => {
    	    if (params.backdrop === false && params.allowOutsideClick) {
    	      warn('"allowOutsideClick" parameter requires `backdrop` parameter to be set to `true`');
    	    }
    	    if (params.theme && !['light', 'dark', 'auto'].includes(params.theme)) {
    	      warn(`Invalid theme "${params.theme}". Expected "light", "dark", or "auto"`);
    	    }
    	    for (const param in params) {
    	      checkIfParamIsValid(param);
    	      if (params.toast) {
    	        checkIfToastParamIsValid(param);
    	      }
    	      checkIfParamIsDeprecated(param);
    	    }
    	  };

    	  /**
    	   * Updates popup parameters.
    	   *
    	   * @param {SweetAlertOptions} params
    	   */
    	  function update(params) {
    	    const container = getContainer();
    	    const popup = getPopup();
    	    const innerParams = privateProps.innerParams.get(this);
    	    if (!popup || hasClass(popup, innerParams.hideClass.popup)) {
    	      warn(`You're trying to update the closed or closing popup, that won't work. Use the update() method in preConfirm parameter or show a new popup.`);
    	      return;
    	    }
    	    const validUpdatableParams = filterValidParams(params);
    	    const updatedParams = Object.assign({}, innerParams, validUpdatableParams);
    	    showWarningsForParams(updatedParams);
    	    container.dataset['swal2Theme'] = updatedParams.theme;
    	    render(this, updatedParams);
    	    privateProps.innerParams.set(this, updatedParams);
    	    Object.defineProperties(this, {
    	      params: {
    	        value: Object.assign({}, this.params, params),
    	        writable: false,
    	        enumerable: true
    	      }
    	    });
    	  }

    	  /**
    	   * @param {SweetAlertOptions} params
    	   * @returns {SweetAlertOptions}
    	   */
    	  const filterValidParams = params => {
    	    const validUpdatableParams = {};
    	    Object.keys(params).forEach(param => {
    	      if (isUpdatableParameter(param)) {
    	        validUpdatableParams[param] = params[param];
    	      } else {
    	        warn(`Invalid parameter to update: ${param}`);
    	      }
    	    });
    	    return validUpdatableParams;
    	  };

    	  /**
    	   * Dispose the current SweetAlert2 instance
    	   */
    	  function _destroy() {
    	    const domCache = privateProps.domCache.get(this);
    	    const innerParams = privateProps.innerParams.get(this);
    	    if (!innerParams) {
    	      disposeWeakMaps(this); // The WeakMaps might have been partly destroyed, we must recall it to dispose any remaining WeakMaps #2335
    	      return; // This instance has already been destroyed
    	    }

    	    // Check if there is another Swal closing
    	    if (domCache.popup && globalState.swalCloseEventFinishedCallback) {
    	      globalState.swalCloseEventFinishedCallback();
    	      delete globalState.swalCloseEventFinishedCallback;
    	    }
    	    if (typeof innerParams.didDestroy === 'function') {
    	      innerParams.didDestroy();
    	    }
    	    globalState.eventEmitter.emit('didDestroy');
    	    disposeSwal(this);
    	  }

    	  /**
    	   * @param {SweetAlert} instance
    	   */
    	  const disposeSwal = instance => {
    	    disposeWeakMaps(instance);
    	    // Unset this.params so GC will dispose it (#1569)
    	    delete instance.params;
    	    // Unset globalState props so GC will dispose globalState (#1569)
    	    delete globalState.keydownHandler;
    	    delete globalState.keydownTarget;
    	    // Unset currentInstance
    	    delete globalState.currentInstance;
    	  };

    	  /**
    	   * @param {SweetAlert} instance
    	   */
    	  const disposeWeakMaps = instance => {
    	    // If the current instance is awaiting a promise result, we keep the privateMethods to call them once the promise result is retrieved #2335
    	    if (instance.isAwaitingPromise) {
    	      unsetWeakMaps(privateProps, instance);
    	      instance.isAwaitingPromise = true;
    	    } else {
    	      unsetWeakMaps(privateMethods, instance);
    	      unsetWeakMaps(privateProps, instance);
    	      delete instance.isAwaitingPromise;
    	      // Unset instance methods
    	      delete instance.disableButtons;
    	      delete instance.enableButtons;
    	      delete instance.getInput;
    	      delete instance.disableInput;
    	      delete instance.enableInput;
    	      delete instance.hideLoading;
    	      delete instance.disableLoading;
    	      delete instance.showValidationMessage;
    	      delete instance.resetValidationMessage;
    	      delete instance.close;
    	      delete instance.closePopup;
    	      delete instance.closeModal;
    	      delete instance.closeToast;
    	      delete instance.rejectPromise;
    	      delete instance.update;
    	      delete instance._destroy;
    	    }
    	  };

    	  /**
    	   * @param {object} obj
    	   * @param {SweetAlert} instance
    	   */
    	  const unsetWeakMaps = (obj, instance) => {
    	    for (const i in obj) {
    	      obj[i].delete(instance);
    	    }
    	  };

    	  var instanceMethods = /*#__PURE__*/Object.freeze({
    	    __proto__: null,
    	    _destroy: _destroy,
    	    close: close,
    	    closeModal: close,
    	    closePopup: close,
    	    closeToast: close,
    	    disableButtons: disableButtons,
    	    disableInput: disableInput,
    	    disableLoading: hideLoading,
    	    enableButtons: enableButtons,
    	    enableInput: enableInput,
    	    getInput: getInput,
    	    handleAwaitingPromise: handleAwaitingPromise,
    	    hideLoading: hideLoading,
    	    rejectPromise: rejectPromise,
    	    resetValidationMessage: resetValidationMessage,
    	    showValidationMessage: showValidationMessage,
    	    update: update
    	  });

    	  /**
    	   * @param {SweetAlertOptions} innerParams
    	   * @param {DomCache} domCache
    	   * @param {Function} dismissWith
    	   */
    	  const handlePopupClick = (innerParams, domCache, dismissWith) => {
    	    if (innerParams.toast) {
    	      handleToastClick(innerParams, domCache, dismissWith);
    	    } else {
    	      // Ignore click events that had mousedown on the popup but mouseup on the container
    	      // This can happen when the user drags a slider
    	      handleModalMousedown(domCache);

    	      // Ignore click events that had mousedown on the container but mouseup on the popup
    	      handleContainerMousedown(domCache);
    	      handleModalClick(innerParams, domCache, dismissWith);
    	    }
    	  };

    	  /**
    	   * @param {SweetAlertOptions} innerParams
    	   * @param {DomCache} domCache
    	   * @param {Function} dismissWith
    	   */
    	  const handleToastClick = (innerParams, domCache, dismissWith) => {
    	    // Closing toast by internal click
    	    domCache.popup.onclick = () => {
    	      if (innerParams && (isAnyButtonShown(innerParams) || innerParams.timer || innerParams.input)) {
    	        return;
    	      }
    	      dismissWith(DismissReason.close);
    	    };
    	  };

    	  /**
    	   * @param {SweetAlertOptions} innerParams
    	   * @returns {boolean}
    	   */
    	  const isAnyButtonShown = innerParams => {
    	    return !!(innerParams.showConfirmButton || innerParams.showDenyButton || innerParams.showCancelButton || innerParams.showCloseButton);
    	  };
    	  let ignoreOutsideClick = false;

    	  /**
    	   * @param {DomCache} domCache
    	   */
    	  const handleModalMousedown = domCache => {
    	    domCache.popup.onmousedown = () => {
    	      domCache.container.onmouseup = function (e) {
    	        domCache.container.onmouseup = () => {};
    	        // We only check if the mouseup target is the container because usually it doesn't
    	        // have any other direct children aside of the popup
    	        if (e.target === domCache.container) {
    	          ignoreOutsideClick = true;
    	        }
    	      };
    	    };
    	  };

    	  /**
    	   * @param {DomCache} domCache
    	   */
    	  const handleContainerMousedown = domCache => {
    	    domCache.container.onmousedown = e => {
    	      // prevent the modal text from being selected on double click on the container (allowOutsideClick: false)
    	      if (e.target === domCache.container) {
    	        e.preventDefault();
    	      }
    	      domCache.popup.onmouseup = function (e) {
    	        domCache.popup.onmouseup = () => {};
    	        // We also need to check if the mouseup target is a child of the popup
    	        if (e.target === domCache.popup || e.target instanceof HTMLElement && domCache.popup.contains(e.target)) {
    	          ignoreOutsideClick = true;
    	        }
    	      };
    	    };
    	  };

    	  /**
    	   * @param {SweetAlertOptions} innerParams
    	   * @param {DomCache} domCache
    	   * @param {Function} dismissWith
    	   */
    	  const handleModalClick = (innerParams, domCache, dismissWith) => {
    	    domCache.container.onclick = e => {
    	      if (ignoreOutsideClick) {
    	        ignoreOutsideClick = false;
    	        return;
    	      }
    	      if (e.target === domCache.container && callIfFunction(innerParams.allowOutsideClick)) {
    	        dismissWith(DismissReason.backdrop);
    	      }
    	    };
    	  };

    	  const isJqueryElement = elem => typeof elem === 'object' && elem.jquery;
    	  const isElement = elem => elem instanceof Element || isJqueryElement(elem);
    	  const argsToParams = args => {
    	    const params = {};
    	    if (typeof args[0] === 'object' && !isElement(args[0])) {
    	      Object.assign(params, args[0]);
    	    } else {
    	      ['title', 'html', 'icon'].forEach((name, index) => {
    	        const arg = args[index];
    	        if (typeof arg === 'string' || isElement(arg)) {
    	          params[name] = arg;
    	        } else if (arg !== undefined) {
    	          error(`Unexpected type of ${name}! Expected "string" or "Element", got ${typeof arg}`);
    	        }
    	      });
    	    }
    	    return params;
    	  };

    	  /**
    	   * Main method to create a new SweetAlert2 popup
    	   *
    	   * @param  {...SweetAlertOptions} args
    	   * @returns {Promise<SweetAlertResult>}
    	   */
    	  function fire() {
    	    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    	      args[_key] = arguments[_key];
    	    }
    	    return new this(...args);
    	  }

    	  /**
    	   * Returns an extended version of `Swal` containing `params` as defaults.
    	   * Useful for reusing Swal configuration.
    	   *
    	   * For example:
    	   *
    	   * Before:
    	   * const textPromptOptions = { input: 'text', showCancelButton: true }
    	   * const {value: firstName} = await Swal.fire({ ...textPromptOptions, title: 'What is your first name?' })
    	   * const {value: lastName} = await Swal.fire({ ...textPromptOptions, title: 'What is your last name?' })
    	   *
    	   * After:
    	   * const TextPrompt = Swal.mixin({ input: 'text', showCancelButton: true })
    	   * const {value: firstName} = await TextPrompt('What is your first name?')
    	   * const {value: lastName} = await TextPrompt('What is your last name?')
    	   *
    	   * @param {SweetAlertOptions} mixinParams
    	   * @returns {SweetAlert}
    	   */
    	  function mixin(mixinParams) {
    	    class MixinSwal extends this {
    	      _main(params, priorityMixinParams) {
    	        return super._main(params, Object.assign({}, mixinParams, priorityMixinParams));
    	      }
    	    }
    	    // @ts-ignore
    	    return MixinSwal;
    	  }

    	  /**
    	   * If `timer` parameter is set, returns number of milliseconds of timer remained.
    	   * Otherwise, returns undefined.
    	   *
    	   * @returns {number | undefined}
    	   */
    	  const getTimerLeft = () => {
    	    return globalState.timeout && globalState.timeout.getTimerLeft();
    	  };

    	  /**
    	   * Stop timer. Returns number of milliseconds of timer remained.
    	   * If `timer` parameter isn't set, returns undefined.
    	   *
    	   * @returns {number | undefined}
    	   */
    	  const stopTimer = () => {
    	    if (globalState.timeout) {
    	      stopTimerProgressBar();
    	      return globalState.timeout.stop();
    	    }
    	  };

    	  /**
    	   * Resume timer. Returns number of milliseconds of timer remained.
    	   * If `timer` parameter isn't set, returns undefined.
    	   *
    	   * @returns {number | undefined}
    	   */
    	  const resumeTimer = () => {
    	    if (globalState.timeout) {
    	      const remaining = globalState.timeout.start();
    	      animateTimerProgressBar(remaining);
    	      return remaining;
    	    }
    	  };

    	  /**
    	   * Resume timer. Returns number of milliseconds of timer remained.
    	   * If `timer` parameter isn't set, returns undefined.
    	   *
    	   * @returns {number | undefined}
    	   */
    	  const toggleTimer = () => {
    	    const timer = globalState.timeout;
    	    return timer && (timer.running ? stopTimer() : resumeTimer());
    	  };

    	  /**
    	   * Increase timer. Returns number of milliseconds of an updated timer.
    	   * If `timer` parameter isn't set, returns undefined.
    	   *
    	   * @param {number} ms
    	   * @returns {number | undefined}
    	   */
    	  const increaseTimer = ms => {
    	    if (globalState.timeout) {
    	      const remaining = globalState.timeout.increase(ms);
    	      animateTimerProgressBar(remaining, true);
    	      return remaining;
    	    }
    	  };

    	  /**
    	   * Check if timer is running. Returns true if timer is running
    	   * or false if timer is paused or stopped.
    	   * If `timer` parameter isn't set, returns undefined
    	   *
    	   * @returns {boolean}
    	   */
    	  const isTimerRunning = () => {
    	    return !!(globalState.timeout && globalState.timeout.isRunning());
    	  };

    	  let bodyClickListenerAdded = false;
    	  const clickHandlers = {};

    	  /**
    	   * @param {string} attr
    	   */
    	  function bindClickHandler() {
    	    let attr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'data-swal-template';
    	    clickHandlers[attr] = this;
    	    if (!bodyClickListenerAdded) {
    	      document.body.addEventListener('click', bodyClickListener);
    	      bodyClickListenerAdded = true;
    	    }
    	  }
    	  const bodyClickListener = event => {
    	    for (let el = event.target; el && el !== document; el = el.parentNode) {
    	      for (const attr in clickHandlers) {
    	        const template = el.getAttribute(attr);
    	        if (template) {
    	          clickHandlers[attr].fire({
    	            template
    	          });
    	          return;
    	        }
    	      }
    	    }
    	  };

    	  // Source: https://gist.github.com/mudge/5830382?permalink_comment_id=2691957#gistcomment-2691957

    	  class EventEmitter {
    	    constructor() {
    	      /** @type {Events} */
    	      this.events = {};
    	    }

    	    /**
    	     * @param {string} eventName
    	     * @returns {EventHandlers}
    	     */
    	    _getHandlersByEventName(eventName) {
    	      if (typeof this.events[eventName] === 'undefined') {
    	        // not Set because we need to keep the FIFO order
    	        // https://github.com/sweetalert2/sweetalert2/pull/2763#discussion_r1748990334
    	        this.events[eventName] = [];
    	      }
    	      return this.events[eventName];
    	    }

    	    /**
    	     * @param {string} eventName
    	     * @param {EventHandler} eventHandler
    	     */
    	    on(eventName, eventHandler) {
    	      const currentHandlers = this._getHandlersByEventName(eventName);
    	      if (!currentHandlers.includes(eventHandler)) {
    	        currentHandlers.push(eventHandler);
    	      }
    	    }

    	    /**
    	     * @param {string} eventName
    	     * @param {EventHandler} eventHandler
    	     */
    	    once(eventName, eventHandler) {
    	      var _this = this;
    	      /**
    	       * @param {Array} args
    	       */
    	      const onceFn = function () {
    	        _this.removeListener(eventName, onceFn);
    	        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    	          args[_key] = arguments[_key];
    	        }
    	        eventHandler.apply(_this, args);
    	      };
    	      this.on(eventName, onceFn);
    	    }

    	    /**
    	     * @param {string} eventName
    	     * @param {Array} args
    	     */
    	    emit(eventName) {
    	      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    	        args[_key2 - 1] = arguments[_key2];
    	      }
    	      this._getHandlersByEventName(eventName).forEach(
    	      /**
    	       * @param {EventHandler} eventHandler
    	       */
    	      eventHandler => {
    	        try {
    	          eventHandler.apply(this, args);
    	        } catch (error) {
    	          console.error(error);
    	        }
    	      });
    	    }

    	    /**
    	     * @param {string} eventName
    	     * @param {EventHandler} eventHandler
    	     */
    	    removeListener(eventName, eventHandler) {
    	      const currentHandlers = this._getHandlersByEventName(eventName);
    	      const index = currentHandlers.indexOf(eventHandler);
    	      if (index > -1) {
    	        currentHandlers.splice(index, 1);
    	      }
    	    }

    	    /**
    	     * @param {string} eventName
    	     */
    	    removeAllListeners(eventName) {
    	      if (this.events[eventName] !== undefined) {
    	        // https://github.com/sweetalert2/sweetalert2/pull/2763#discussion_r1749239222
    	        this.events[eventName].length = 0;
    	      }
    	    }
    	    reset() {
    	      this.events = {};
    	    }
    	  }

    	  globalState.eventEmitter = new EventEmitter();

    	  /**
    	   * @param {string} eventName
    	   * @param {EventHandler} eventHandler
    	   */
    	  const on = (eventName, eventHandler) => {
    	    globalState.eventEmitter.on(eventName, eventHandler);
    	  };

    	  /**
    	   * @param {string} eventName
    	   * @param {EventHandler} eventHandler
    	   */
    	  const once = (eventName, eventHandler) => {
    	    globalState.eventEmitter.once(eventName, eventHandler);
    	  };

    	  /**
    	   * @param {string} [eventName]
    	   * @param {EventHandler} [eventHandler]
    	   */
    	  const off = (eventName, eventHandler) => {
    	    // Remove all handlers for all events
    	    if (!eventName) {
    	      globalState.eventEmitter.reset();
    	      return;
    	    }
    	    if (eventHandler) {
    	      // Remove a specific handler
    	      globalState.eventEmitter.removeListener(eventName, eventHandler);
    	    } else {
    	      // Remove all handlers for a specific event
    	      globalState.eventEmitter.removeAllListeners(eventName);
    	    }
    	  };

    	  var staticMethods = /*#__PURE__*/Object.freeze({
    	    __proto__: null,
    	    argsToParams: argsToParams,
    	    bindClickHandler: bindClickHandler,
    	    clickCancel: clickCancel,
    	    clickConfirm: clickConfirm,
    	    clickDeny: clickDeny,
    	    enableLoading: showLoading,
    	    fire: fire,
    	    getActions: getActions,
    	    getCancelButton: getCancelButton,
    	    getCloseButton: getCloseButton,
    	    getConfirmButton: getConfirmButton,
    	    getContainer: getContainer,
    	    getDenyButton: getDenyButton,
    	    getFocusableElements: getFocusableElements,
    	    getFooter: getFooter,
    	    getHtmlContainer: getHtmlContainer,
    	    getIcon: getIcon,
    	    getIconContent: getIconContent,
    	    getImage: getImage,
    	    getInputLabel: getInputLabel,
    	    getLoader: getLoader,
    	    getPopup: getPopup,
    	    getProgressSteps: getProgressSteps,
    	    getTimerLeft: getTimerLeft,
    	    getTimerProgressBar: getTimerProgressBar,
    	    getTitle: getTitle,
    	    getValidationMessage: getValidationMessage,
    	    increaseTimer: increaseTimer,
    	    isDeprecatedParameter: isDeprecatedParameter,
    	    isLoading: isLoading,
    	    isTimerRunning: isTimerRunning,
    	    isUpdatableParameter: isUpdatableParameter,
    	    isValidParameter: isValidParameter,
    	    isVisible: isVisible,
    	    mixin: mixin,
    	    off: off,
    	    on: on,
    	    once: once,
    	    resumeTimer: resumeTimer,
    	    showLoading: showLoading,
    	    stopTimer: stopTimer,
    	    toggleTimer: toggleTimer
    	  });

    	  class Timer {
    	    /**
    	     * @param {Function} callback
    	     * @param {number} delay
    	     */
    	    constructor(callback, delay) {
    	      this.callback = callback;
    	      this.remaining = delay;
    	      this.running = false;
    	      this.start();
    	    }

    	    /**
    	     * @returns {number}
    	     */
    	    start() {
    	      if (!this.running) {
    	        this.running = true;
    	        this.started = new Date();
    	        this.id = setTimeout(this.callback, this.remaining);
    	      }
    	      return this.remaining;
    	    }

    	    /**
    	     * @returns {number}
    	     */
    	    stop() {
    	      if (this.started && this.running) {
    	        this.running = false;
    	        clearTimeout(this.id);
    	        this.remaining -= new Date().getTime() - this.started.getTime();
    	      }
    	      return this.remaining;
    	    }

    	    /**
    	     * @param {number} n
    	     * @returns {number}
    	     */
    	    increase(n) {
    	      const running = this.running;
    	      if (running) {
    	        this.stop();
    	      }
    	      this.remaining += n;
    	      if (running) {
    	        this.start();
    	      }
    	      return this.remaining;
    	    }

    	    /**
    	     * @returns {number}
    	     */
    	    getTimerLeft() {
    	      if (this.running) {
    	        this.stop();
    	        this.start();
    	      }
    	      return this.remaining;
    	    }

    	    /**
    	     * @returns {boolean}
    	     */
    	    isRunning() {
    	      return this.running;
    	    }
    	  }

    	  const swalStringParams = ['swal-title', 'swal-html', 'swal-footer'];

    	  /**
    	   * @param {SweetAlertOptions} params
    	   * @returns {SweetAlertOptions}
    	   */
    	  const getTemplateParams = params => {
    	    const template = typeof params.template === 'string' ? (/** @type {HTMLTemplateElement} */document.querySelector(params.template)) : params.template;
    	    if (!template) {
    	      return {};
    	    }
    	    /** @type {DocumentFragment} */
    	    const templateContent = template.content;
    	    showWarningsForElements(templateContent);
    	    const result = Object.assign(getSwalParams(templateContent), getSwalFunctionParams(templateContent), getSwalButtons(templateContent), getSwalImage(templateContent), getSwalIcon(templateContent), getSwalInput(templateContent), getSwalStringParams(templateContent, swalStringParams));
    	    return result;
    	  };

    	  /**
    	   * @param {DocumentFragment} templateContent
    	   * @returns {Record<string, any>}
    	   */
    	  const getSwalParams = templateContent => {
    	    /** @type {Record<string, any>} */
    	    const result = {};
    	    /** @type {HTMLElement[]} */
    	    const swalParams = Array.from(templateContent.querySelectorAll('swal-param'));
    	    swalParams.forEach(param => {
    	      showWarningsForAttributes(param, ['name', 'value']);
    	      const paramName = /** @type {keyof SweetAlertOptions} */param.getAttribute('name');
    	      const value = param.getAttribute('value');
    	      if (!paramName || !value) {
    	        return;
    	      }
    	      if (typeof defaultParams[paramName] === 'boolean') {
    	        result[paramName] = value !== 'false';
    	      } else if (typeof defaultParams[paramName] === 'object') {
    	        result[paramName] = JSON.parse(value);
    	      } else {
    	        result[paramName] = value;
    	      }
    	    });
    	    return result;
    	  };

    	  /**
    	   * @param {DocumentFragment} templateContent
    	   * @returns {Record<string, any>}
    	   */
    	  const getSwalFunctionParams = templateContent => {
    	    /** @type {Record<string, any>} */
    	    const result = {};
    	    /** @type {HTMLElement[]} */
    	    const swalFunctions = Array.from(templateContent.querySelectorAll('swal-function-param'));
    	    swalFunctions.forEach(param => {
    	      const paramName = /** @type {keyof SweetAlertOptions} */param.getAttribute('name');
    	      const value = param.getAttribute('value');
    	      if (!paramName || !value) {
    	        return;
    	      }
    	      result[paramName] = new Function(`return ${value}`)();
    	    });
    	    return result;
    	  };

    	  /**
    	   * @param {DocumentFragment} templateContent
    	   * @returns {Record<string, any>}
    	   */
    	  const getSwalButtons = templateContent => {
    	    /** @type {Record<string, any>} */
    	    const result = {};
    	    /** @type {HTMLElement[]} */
    	    const swalButtons = Array.from(templateContent.querySelectorAll('swal-button'));
    	    swalButtons.forEach(button => {
    	      showWarningsForAttributes(button, ['type', 'color', 'aria-label']);
    	      const type = button.getAttribute('type');
    	      if (!type || !['confirm', 'cancel', 'deny'].includes(type)) {
    	        return;
    	      }
    	      result[`${type}ButtonText`] = button.innerHTML;
    	      result[`show${capitalizeFirstLetter(type)}Button`] = true;
    	      if (button.hasAttribute('color')) {
    	        result[`${type}ButtonColor`] = button.getAttribute('color');
    	      }
    	      if (button.hasAttribute('aria-label')) {
    	        result[`${type}ButtonAriaLabel`] = button.getAttribute('aria-label');
    	      }
    	    });
    	    return result;
    	  };

    	  /**
    	   * @param {DocumentFragment} templateContent
    	   * @returns {Pick<SweetAlertOptions, 'imageUrl' | 'imageWidth' | 'imageHeight' | 'imageAlt'>}
    	   */
    	  const getSwalImage = templateContent => {
    	    const result = {};
    	    /** @type {HTMLElement | null} */
    	    const image = templateContent.querySelector('swal-image');
    	    if (image) {
    	      showWarningsForAttributes(image, ['src', 'width', 'height', 'alt']);
    	      if (image.hasAttribute('src')) {
    	        result.imageUrl = image.getAttribute('src') || undefined;
    	      }
    	      if (image.hasAttribute('width')) {
    	        result.imageWidth = image.getAttribute('width') || undefined;
    	      }
    	      if (image.hasAttribute('height')) {
    	        result.imageHeight = image.getAttribute('height') || undefined;
    	      }
    	      if (image.hasAttribute('alt')) {
    	        result.imageAlt = image.getAttribute('alt') || undefined;
    	      }
    	    }
    	    return result;
    	  };

    	  /**
    	   * @param {DocumentFragment} templateContent
    	   * @returns {Record<string, any>}
    	   */
    	  const getSwalIcon = templateContent => {
    	    const result = {};
    	    /** @type {HTMLElement | null} */
    	    const icon = templateContent.querySelector('swal-icon');
    	    if (icon) {
    	      showWarningsForAttributes(icon, ['type', 'color']);
    	      if (icon.hasAttribute('type')) {
    	        result.icon = icon.getAttribute('type');
    	      }
    	      if (icon.hasAttribute('color')) {
    	        result.iconColor = icon.getAttribute('color');
    	      }
    	      result.iconHtml = icon.innerHTML;
    	    }
    	    return result;
    	  };

    	  /**
    	   * @param {DocumentFragment} templateContent
    	   * @returns {Record<string, any>}
    	   */
    	  const getSwalInput = templateContent => {
    	    /** @type {Record<string, any>} */
    	    const result = {};
    	    /** @type {HTMLElement | null} */
    	    const input = templateContent.querySelector('swal-input');
    	    if (input) {
    	      showWarningsForAttributes(input, ['type', 'label', 'placeholder', 'value']);
    	      result.input = input.getAttribute('type') || 'text';
    	      if (input.hasAttribute('label')) {
    	        result.inputLabel = input.getAttribute('label');
    	      }
    	      if (input.hasAttribute('placeholder')) {
    	        result.inputPlaceholder = input.getAttribute('placeholder');
    	      }
    	      if (input.hasAttribute('value')) {
    	        result.inputValue = input.getAttribute('value');
    	      }
    	    }
    	    /** @type {HTMLElement[]} */
    	    const inputOptions = Array.from(templateContent.querySelectorAll('swal-input-option'));
    	    if (inputOptions.length) {
    	      result.inputOptions = {};
    	      inputOptions.forEach(option => {
    	        showWarningsForAttributes(option, ['value']);
    	        const optionValue = option.getAttribute('value');
    	        if (!optionValue) {
    	          return;
    	        }
    	        const optionName = option.innerHTML;
    	        result.inputOptions[optionValue] = optionName;
    	      });
    	    }
    	    return result;
    	  };

    	  /**
    	   * @param {DocumentFragment} templateContent
    	   * @param {string[]} paramNames
    	   * @returns {Record<string, any>}
    	   */
    	  const getSwalStringParams = (templateContent, paramNames) => {
    	    /** @type {Record<string, any>} */
    	    const result = {};
    	    for (const i in paramNames) {
    	      const paramName = paramNames[i];
    	      /** @type {HTMLElement | null} */
    	      const tag = templateContent.querySelector(paramName);
    	      if (tag) {
    	        showWarningsForAttributes(tag, []);
    	        result[paramName.replace(/^swal-/, '')] = tag.innerHTML.trim();
    	      }
    	    }
    	    return result;
    	  };

    	  /**
    	   * @param {DocumentFragment} templateContent
    	   */
    	  const showWarningsForElements = templateContent => {
    	    const allowedElements = swalStringParams.concat(['swal-param', 'swal-function-param', 'swal-button', 'swal-image', 'swal-icon', 'swal-input', 'swal-input-option']);
    	    Array.from(templateContent.children).forEach(el => {
    	      const tagName = el.tagName.toLowerCase();
    	      if (!allowedElements.includes(tagName)) {
    	        warn(`Unrecognized element <${tagName}>`);
    	      }
    	    });
    	  };

    	  /**
    	   * @param {HTMLElement} el
    	   * @param {string[]} allowedAttributes
    	   */
    	  const showWarningsForAttributes = (el, allowedAttributes) => {
    	    Array.from(el.attributes).forEach(attribute => {
    	      if (allowedAttributes.indexOf(attribute.name) === -1) {
    	        warn([`Unrecognized attribute "${attribute.name}" on <${el.tagName.toLowerCase()}>.`, `${allowedAttributes.length ? `Allowed attributes are: ${allowedAttributes.join(', ')}` : 'To set the value, use HTML within the element.'}`]);
    	      }
    	    });
    	  };

    	  const SHOW_CLASS_TIMEOUT = 10;

    	  /**
    	   * Open popup, add necessary classes and styles, fix scrollbar
    	   *
    	   * @param {SweetAlertOptions} params
    	   */
    	  const openPopup = params => {
    	    const container = getContainer();
    	    const popup = getPopup();
    	    if (typeof params.willOpen === 'function') {
    	      params.willOpen(popup);
    	    }
    	    globalState.eventEmitter.emit('willOpen', popup);
    	    const bodyStyles = window.getComputedStyle(document.body);
    	    const initialBodyOverflow = bodyStyles.overflowY;
    	    addClasses(container, popup, params);

    	    // scrolling is 'hidden' until animation is done, after that 'auto'
    	    setTimeout(() => {
    	      setScrollingVisibility(container, popup);
    	    }, SHOW_CLASS_TIMEOUT);
    	    if (isModal()) {
    	      fixScrollContainer(container, params.scrollbarPadding, initialBodyOverflow);
    	      setAriaHidden();
    	    }
    	    if (!isToast() && !globalState.previousActiveElement) {
    	      globalState.previousActiveElement = document.activeElement;
    	    }
    	    if (typeof params.didOpen === 'function') {
    	      setTimeout(() => params.didOpen(popup));
    	    }
    	    globalState.eventEmitter.emit('didOpen', popup);
    	    removeClass(container, swalClasses['no-transition']);
    	  };

    	  /**
    	   * @param {AnimationEvent} event
    	   */
    	  const swalOpenAnimationFinished = event => {
    	    const popup = getPopup();
    	    if (event.target !== popup) {
    	      return;
    	    }
    	    const container = getContainer();
    	    popup.removeEventListener('animationend', swalOpenAnimationFinished);
    	    popup.removeEventListener('transitionend', swalOpenAnimationFinished);
    	    container.style.overflowY = 'auto';
    	  };

    	  /**
    	   * @param {HTMLElement} container
    	   * @param {HTMLElement} popup
    	   */
    	  const setScrollingVisibility = (container, popup) => {
    	    if (hasCssAnimation(popup)) {
    	      container.style.overflowY = 'hidden';
    	      popup.addEventListener('animationend', swalOpenAnimationFinished);
    	      popup.addEventListener('transitionend', swalOpenAnimationFinished);
    	    } else {
    	      container.style.overflowY = 'auto';
    	    }
    	  };

    	  /**
    	   * @param {HTMLElement} container
    	   * @param {boolean} scrollbarPadding
    	   * @param {string} initialBodyOverflow
    	   */
    	  const fixScrollContainer = (container, scrollbarPadding, initialBodyOverflow) => {
    	    iOSfix();
    	    if (scrollbarPadding && initialBodyOverflow !== 'hidden') {
    	      replaceScrollbarWithPadding(initialBodyOverflow);
    	    }

    	    // sweetalert2/issues/1247
    	    setTimeout(() => {
    	      container.scrollTop = 0;
    	    });
    	  };

    	  /**
    	   * @param {HTMLElement} container
    	   * @param {HTMLElement} popup
    	   * @param {SweetAlertOptions} params
    	   */
    	  const addClasses = (container, popup, params) => {
    	    addClass(container, params.showClass.backdrop);
    	    if (params.animation) {
    	      // this workaround with opacity is needed for https://github.com/sweetalert2/sweetalert2/issues/2059
    	      popup.style.setProperty('opacity', '0', 'important');
    	      show(popup, 'grid');
    	      setTimeout(() => {
    	        // Animate popup right after showing it
    	        addClass(popup, params.showClass.popup);
    	        // and remove the opacity workaround
    	        popup.style.removeProperty('opacity');
    	      }, SHOW_CLASS_TIMEOUT); // 10ms in order to fix #2062
    	    } else {
    	      show(popup, 'grid');
    	    }
    	    addClass([document.documentElement, document.body], swalClasses.shown);
    	    if (params.heightAuto && params.backdrop && !params.toast) {
    	      addClass([document.documentElement, document.body], swalClasses['height-auto']);
    	    }
    	  };

    	  var defaultInputValidators = {
    	    /**
    	     * @param {string} string
    	     * @param {string} [validationMessage]
    	     * @returns {Promise<string | void>}
    	     */
    	    email: (string, validationMessage) => {
    	      return /^[a-zA-Z0-9.+_'-]+@[a-zA-Z0-9.-]+\.[a-zA-Z0-9-]+$/.test(string) ? Promise.resolve() : Promise.resolve(validationMessage || 'Invalid email address');
    	    },
    	    /**
    	     * @param {string} string
    	     * @param {string} [validationMessage]
    	     * @returns {Promise<string | void>}
    	     */
    	    url: (string, validationMessage) => {
    	      // taken from https://stackoverflow.com/a/3809435 with a small change from #1306 and #2013
    	      return /^https?:\/\/(www\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\.[a-z]{2,63}\b([-a-zA-Z0-9@:%_+.~#?&/=]*)$/.test(string) ? Promise.resolve() : Promise.resolve(validationMessage || 'Invalid URL');
    	    }
    	  };

    	  /**
    	   * @param {SweetAlertOptions} params
    	   */
    	  function setDefaultInputValidators(params) {
    	    // Use default `inputValidator` for supported input types if not provided
    	    if (params.inputValidator) {
    	      return;
    	    }
    	    if (params.input === 'email') {
    	      params.inputValidator = defaultInputValidators['email'];
    	    }
    	    if (params.input === 'url') {
    	      params.inputValidator = defaultInputValidators['url'];
    	    }
    	  }

    	  /**
    	   * @param {SweetAlertOptions} params
    	   */
    	  function validateCustomTargetElement(params) {
    	    // Determine if the custom target element is valid
    	    if (!params.target || typeof params.target === 'string' && !document.querySelector(params.target) || typeof params.target !== 'string' && !params.target.appendChild) {
    	      warn('Target parameter is not valid, defaulting to "body"');
    	      params.target = 'body';
    	    }
    	  }

    	  /**
    	   * Set type, text and actions on popup
    	   *
    	   * @param {SweetAlertOptions} params
    	   */
    	  function setParameters(params) {
    	    setDefaultInputValidators(params);

    	    // showLoaderOnConfirm && preConfirm
    	    if (params.showLoaderOnConfirm && !params.preConfirm) {
    	      warn('showLoaderOnConfirm is set to true, but preConfirm is not defined.\n' + 'showLoaderOnConfirm should be used together with preConfirm, see usage example:\n' + 'https://sweetalert2.github.io/#ajax-request');
    	    }
    	    validateCustomTargetElement(params);

    	    // Replace newlines with <br> in title
    	    if (typeof params.title === 'string') {
    	      params.title = params.title.split('\n').join('<br />');
    	    }
    	    init(params);
    	  }

    	  /** @type {SweetAlert} */
    	  let currentInstance;
    	  var _promise = /*#__PURE__*/new WeakMap();
    	  class SweetAlert {
    	    /**
    	     * @param {...any} args
    	     * @this {SweetAlert}
    	     */
    	    constructor() {
    	      /**
    	       * @type {Promise<SweetAlertResult>}
    	       */
    	      _classPrivateFieldInitSpec(this, _promise, undefined);
    	      // Prevent run in Node env
    	      if (typeof window === 'undefined') {
    	        return;
    	      }
    	      currentInstance = this;

    	      // @ts-ignore
    	      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    	        args[_key] = arguments[_key];
    	      }
    	      const outerParams = Object.freeze(this.constructor.argsToParams(args));

    	      /** @type {Readonly<SweetAlertOptions>} */
    	      this.params = outerParams;

    	      /** @type {boolean} */
    	      this.isAwaitingPromise = false;
    	      _classPrivateFieldSet2(_promise, this, this._main(currentInstance.params));
    	    }
    	    _main(userParams) {
    	      let mixinParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    	      showWarningsForParams(Object.assign({}, mixinParams, userParams));
    	      if (globalState.currentInstance) {
    	        const swalPromiseResolve = privateMethods.swalPromiseResolve.get(globalState.currentInstance);
    	        const {
    	          isAwaitingPromise
    	        } = globalState.currentInstance;
    	        globalState.currentInstance._destroy();
    	        if (!isAwaitingPromise) {
    	          swalPromiseResolve({
    	            isDismissed: true
    	          });
    	        }
    	        if (isModal()) {
    	          unsetAriaHidden();
    	        }
    	      }
    	      globalState.currentInstance = currentInstance;
    	      const innerParams = prepareParams(userParams, mixinParams);
    	      setParameters(innerParams);
    	      Object.freeze(innerParams);

    	      // clear the previous timer
    	      if (globalState.timeout) {
    	        globalState.timeout.stop();
    	        delete globalState.timeout;
    	      }

    	      // clear the restore focus timeout
    	      clearTimeout(globalState.restoreFocusTimeout);
    	      const domCache = populateDomCache(currentInstance);
    	      render(currentInstance, innerParams);
    	      privateProps.innerParams.set(currentInstance, innerParams);
    	      return swalPromise(currentInstance, domCache, innerParams);
    	    }

    	    // `catch` cannot be the name of a module export, so we define our thenable methods here instead
    	    then(onFulfilled) {
    	      return _classPrivateFieldGet2(_promise, this).then(onFulfilled);
    	    }
    	    finally(onFinally) {
    	      return _classPrivateFieldGet2(_promise, this).finally(onFinally);
    	    }
    	  }

    	  /**
    	   * @param {SweetAlert} instance
    	   * @param {DomCache} domCache
    	   * @param {SweetAlertOptions} innerParams
    	   * @returns {Promise}
    	   */
    	  const swalPromise = (instance, domCache, innerParams) => {
    	    return new Promise((resolve, reject) => {
    	      // functions to handle all closings/dismissals
    	      /**
    	       * @param {DismissReason} dismiss
    	       */
    	      const dismissWith = dismiss => {
    	        instance.close({
    	          isDismissed: true,
    	          dismiss
    	        });
    	      };
    	      privateMethods.swalPromiseResolve.set(instance, resolve);
    	      privateMethods.swalPromiseReject.set(instance, reject);
    	      domCache.confirmButton.onclick = () => {
    	        handleConfirmButtonClick(instance);
    	      };
    	      domCache.denyButton.onclick = () => {
    	        handleDenyButtonClick(instance);
    	      };
    	      domCache.cancelButton.onclick = () => {
    	        handleCancelButtonClick(instance, dismissWith);
    	      };
    	      domCache.closeButton.onclick = () => {
    	        dismissWith(DismissReason.close);
    	      };
    	      handlePopupClick(innerParams, domCache, dismissWith);
    	      addKeydownHandler(globalState, innerParams, dismissWith);
    	      handleInputOptionsAndValue(instance, innerParams);
    	      openPopup(innerParams);
    	      setupTimer(globalState, innerParams, dismissWith);
    	      initFocus(domCache, innerParams);

    	      // Scroll container to top on open (#1247, #1946)
    	      setTimeout(() => {
    	        domCache.container.scrollTop = 0;
    	      });
    	    });
    	  };

    	  /**
    	   * @param {SweetAlertOptions} userParams
    	   * @param {SweetAlertOptions} mixinParams
    	   * @returns {SweetAlertOptions}
    	   */
    	  const prepareParams = (userParams, mixinParams) => {
    	    const templateParams = getTemplateParams(userParams);
    	    const params = Object.assign({}, defaultParams, mixinParams, templateParams, userParams); // precedence is described in #2131
    	    params.showClass = Object.assign({}, defaultParams.showClass, params.showClass);
    	    params.hideClass = Object.assign({}, defaultParams.hideClass, params.hideClass);
    	    if (params.animation === false) {
    	      params.showClass = {
    	        backdrop: 'swal2-noanimation'
    	      };
    	      params.hideClass = {};
    	    }
    	    return params;
    	  };

    	  /**
    	   * @param {SweetAlert} instance
    	   * @returns {DomCache}
    	   */
    	  const populateDomCache = instance => {
    	    const domCache = {
    	      popup: getPopup(),
    	      container: getContainer(),
    	      actions: getActions(),
    	      confirmButton: getConfirmButton(),
    	      denyButton: getDenyButton(),
    	      cancelButton: getCancelButton(),
    	      loader: getLoader(),
    	      closeButton: getCloseButton(),
    	      validationMessage: getValidationMessage(),
    	      progressSteps: getProgressSteps()
    	    };
    	    privateProps.domCache.set(instance, domCache);
    	    return domCache;
    	  };

    	  /**
    	   * @param {GlobalState} globalState
    	   * @param {SweetAlertOptions} innerParams
    	   * @param {Function} dismissWith
    	   */
    	  const setupTimer = (globalState, innerParams, dismissWith) => {
    	    const timerProgressBar = getTimerProgressBar();
    	    hide(timerProgressBar);
    	    if (innerParams.timer) {
    	      globalState.timeout = new Timer(() => {
    	        dismissWith('timer');
    	        delete globalState.timeout;
    	      }, innerParams.timer);
    	      if (innerParams.timerProgressBar) {
    	        show(timerProgressBar);
    	        applyCustomClass(timerProgressBar, innerParams, 'timerProgressBar');
    	        setTimeout(() => {
    	          if (globalState.timeout && globalState.timeout.running) {
    	            // timer can be already stopped or unset at this point
    	            animateTimerProgressBar(innerParams.timer);
    	          }
    	        });
    	      }
    	    }
    	  };

    	  /**
    	   * Initialize focus in the popup:
    	   *
    	   * 1. If `toast` is `true`, don't steal focus from the document.
    	   * 2. Else if there is an [autofocus] element, focus it.
    	   * 3. Else if `focusConfirm` is `true` and confirm button is visible, focus it.
    	   * 4. Else if `focusDeny` is `true` and deny button is visible, focus it.
    	   * 5. Else if `focusCancel` is `true` and cancel button is visible, focus it.
    	   * 6. Else focus the first focusable element in a popup (if any).
    	   *
    	   * @param {DomCache} domCache
    	   * @param {SweetAlertOptions} innerParams
    	   */
    	  const initFocus = (domCache, innerParams) => {
    	    if (innerParams.toast) {
    	      return;
    	    }
    	    // TODO: this is dumb, remove `allowEnterKey` param in the next major version
    	    if (!callIfFunction(innerParams.allowEnterKey)) {
    	      warnAboutDeprecation('allowEnterKey');
    	      blurActiveElement();
    	      return;
    	    }
    	    if (focusAutofocus(domCache)) {
    	      return;
    	    }
    	    if (focusButton(domCache, innerParams)) {
    	      return;
    	    }
    	    setFocus(-1, 1);
    	  };

    	  /**
    	   * @param {DomCache} domCache
    	   * @returns {boolean}
    	   */
    	  const focusAutofocus = domCache => {
    	    const autofocusElements = Array.from(domCache.popup.querySelectorAll('[autofocus]'));
    	    for (const autofocusElement of autofocusElements) {
    	      if (autofocusElement instanceof HTMLElement && isVisible$1(autofocusElement)) {
    	        autofocusElement.focus();
    	        return true;
    	      }
    	    }
    	    return false;
    	  };

    	  /**
    	   * @param {DomCache} domCache
    	   * @param {SweetAlertOptions} innerParams
    	   * @returns {boolean}
    	   */
    	  const focusButton = (domCache, innerParams) => {
    	    if (innerParams.focusDeny && isVisible$1(domCache.denyButton)) {
    	      domCache.denyButton.focus();
    	      return true;
    	    }
    	    if (innerParams.focusCancel && isVisible$1(domCache.cancelButton)) {
    	      domCache.cancelButton.focus();
    	      return true;
    	    }
    	    if (innerParams.focusConfirm && isVisible$1(domCache.confirmButton)) {
    	      domCache.confirmButton.focus();
    	      return true;
    	    }
    	    return false;
    	  };
    	  const blurActiveElement = () => {
    	    if (document.activeElement instanceof HTMLElement && typeof document.activeElement.blur === 'function') {
    	      document.activeElement.blur();
    	    }
    	  };

    	  // Dear russian users visiting russian sites. Let's have fun.
    	  if (typeof window !== 'undefined' && /^ru\b/.test(navigator.language) && location.host.match(/\.(ru|su|by|xn--p1ai)$/)) {
    	    const now = new Date();
    	    const initiationDate = localStorage.getItem('swal-initiation');
    	    if (!initiationDate) {
    	      localStorage.setItem('swal-initiation', `${now}`);
    	    } else if ((now.getTime() - Date.parse(initiationDate)) / (1000 * 60 * 60 * 24) > 3) {
    	      setTimeout(() => {
    	        document.body.style.pointerEvents = 'none';
    	        const ukrainianAnthem = document.createElement('audio');
    	        ukrainianAnthem.src = 'https://flag-gimn.ru/wp-content/uploads/2021/09/Ukraina.mp3';
    	        ukrainianAnthem.loop = true;
    	        document.body.appendChild(ukrainianAnthem);
    	        setTimeout(() => {
    	          ukrainianAnthem.play().catch(() => {
    	            // ignore
    	          });
    	        }, 2500);
    	      }, 500);
    	    }
    	  }

    	  // Assign instance methods from src/instanceMethods/*.js to prototype
    	  SweetAlert.prototype.disableButtons = disableButtons;
    	  SweetAlert.prototype.enableButtons = enableButtons;
    	  SweetAlert.prototype.getInput = getInput;
    	  SweetAlert.prototype.disableInput = disableInput;
    	  SweetAlert.prototype.enableInput = enableInput;
    	  SweetAlert.prototype.hideLoading = hideLoading;
    	  SweetAlert.prototype.disableLoading = hideLoading;
    	  SweetAlert.prototype.showValidationMessage = showValidationMessage;
    	  SweetAlert.prototype.resetValidationMessage = resetValidationMessage;
    	  SweetAlert.prototype.close = close;
    	  SweetAlert.prototype.closePopup = close;
    	  SweetAlert.prototype.closeModal = close;
    	  SweetAlert.prototype.closeToast = close;
    	  SweetAlert.prototype.rejectPromise = rejectPromise;
    	  SweetAlert.prototype.update = update;
    	  SweetAlert.prototype._destroy = _destroy;

    	  // Assign static methods from src/staticMethods/*.js to constructor
    	  Object.assign(SweetAlert, staticMethods);

    	  // Proxy to instance methods to constructor, for now, for backwards compatibility
    	  Object.keys(instanceMethods).forEach(key => {
    	    /**
    	     * @param {...any} args
    	     * @returns {any | undefined}
    	     */
    	    SweetAlert[key] = function () {
    	      if (currentInstance && currentInstance[key]) {
    	        return currentInstance[key](...arguments);
    	      }
    	      return null;
    	    };
    	  });
    	  SweetAlert.DismissReason = DismissReason;
    	  SweetAlert.version = '11.16.0';

    	  const Swal = SweetAlert;
    	  // @ts-ignore
    	  Swal.default = Swal;

    	  return Swal;

    	}));
    	if (typeof commonjsGlobal !== 'undefined' && commonjsGlobal.Sweetalert2){commonjsGlobal.swal = commonjsGlobal.sweetAlert = commonjsGlobal.Swal = commonjsGlobal.SweetAlert = commonjsGlobal.Sweetalert2;}
    	"undefined"!=typeof document&&function(e,t){var n=e.createElement("style");if(e.getElementsByTagName("head")[0].appendChild(n),n.styleSheet)n.styleSheet.disabled||(n.styleSheet.cssText=t);else try{n.innerHTML=t;}catch(e){n.innerText=t;}}(document,":root{--swal2-container-padding: 0.625em;--swal2-backdrop: rgba(0, 0, 0, 0.4);--swal2-width: 32em;--swal2-padding: 0 0 1.25em;--swal2-border: none;--swal2-border-radius: 0.3125rem;--swal2-background: white;--swal2-color: #545454;--swal2-footer-border-color: #eee;--swal2-input-background: transparent;--swal2-validation-message-background: #f0f0f0;--swal2-validation-message-color: #666}[data-swal2-theme=dark]{--swal2-dark-theme-black: #19191a;--swal2-dark-theme-white: #e1e1e1;--swal2-background: var(--swal2-dark-theme-black);--swal2-color: var(--swal2-dark-theme-white);--swal2-footer-border-color: #555;--swal2-input-background: color-mix(in srgb, var(--swal2-dark-theme-black), var(--swal2-dark-theme-white) 10%);--swal2-validation-message-background: color-mix(in srgb, var(--swal2-dark-theme-black), var(--swal2-dark-theme-white) 10%);--swal2-validation-message-color: var(--swal2-dark-theme-white)}@media(prefers-color-scheme: dark){[data-swal2-theme=auto]{--swal2-dark-theme-black: #19191a;--swal2-dark-theme-white: #e1e1e1;--swal2-background: var(--swal2-dark-theme-black);--swal2-color: var(--swal2-dark-theme-white);--swal2-footer-border-color: #555;--swal2-input-background: color-mix(in srgb, var(--swal2-dark-theme-black), var(--swal2-dark-theme-white) 10%);--swal2-validation-message-background: color-mix(in srgb, var(--swal2-dark-theme-black), var(--swal2-dark-theme-white) 10%);--swal2-validation-message-color: var(--swal2-dark-theme-white)}}body.swal2-shown:not(.swal2-no-backdrop,.swal2-toast-shown){overflow:hidden}body.swal2-height-auto{height:auto !important}body.swal2-no-backdrop .swal2-container{background-color:rgba(0,0,0,0) !important;pointer-events:none}body.swal2-no-backdrop .swal2-container .swal2-popup{pointer-events:all}body.swal2-no-backdrop .swal2-container .swal2-modal{box-shadow:0 0 10px var(--swal2-backdrop)}body.swal2-toast-shown .swal2-container{box-sizing:border-box;width:360px;max-width:100%;background-color:rgba(0,0,0,0);pointer-events:none}body.swal2-toast-shown .swal2-container.swal2-top{inset:0 auto auto 50%;transform:translateX(-50%)}body.swal2-toast-shown .swal2-container.swal2-top-end,body.swal2-toast-shown .swal2-container.swal2-top-right{inset:0 0 auto auto}body.swal2-toast-shown .swal2-container.swal2-top-start,body.swal2-toast-shown .swal2-container.swal2-top-left{inset:0 auto auto 0}body.swal2-toast-shown .swal2-container.swal2-center-start,body.swal2-toast-shown .swal2-container.swal2-center-left{inset:50% auto auto 0;transform:translateY(-50%)}body.swal2-toast-shown .swal2-container.swal2-center{inset:50% auto auto 50%;transform:translate(-50%, -50%)}body.swal2-toast-shown .swal2-container.swal2-center-end,body.swal2-toast-shown .swal2-container.swal2-center-right{inset:50% 0 auto auto;transform:translateY(-50%)}body.swal2-toast-shown .swal2-container.swal2-bottom-start,body.swal2-toast-shown .swal2-container.swal2-bottom-left{inset:auto auto 0 0}body.swal2-toast-shown .swal2-container.swal2-bottom{inset:auto auto 0 50%;transform:translateX(-50%)}body.swal2-toast-shown .swal2-container.swal2-bottom-end,body.swal2-toast-shown .swal2-container.swal2-bottom-right{inset:auto 0 0 auto}@media print{body.swal2-shown:not(.swal2-no-backdrop,.swal2-toast-shown){overflow-y:scroll !important}body.swal2-shown:not(.swal2-no-backdrop,.swal2-toast-shown)>[aria-hidden=true]{display:none}body.swal2-shown:not(.swal2-no-backdrop,.swal2-toast-shown) .swal2-container{position:static !important}}div:where(.swal2-container){display:grid;position:fixed;z-index:1060;inset:0;box-sizing:border-box;grid-template-areas:\"top-start     top            top-end\" \"center-start  center         center-end\" \"bottom-start  bottom-center  bottom-end\";grid-template-rows:minmax(min-content, auto) minmax(min-content, auto) minmax(min-content, auto);height:100%;padding:var(--swal2-container-padding);overflow-x:hidden;transition:background-color .1s;-webkit-overflow-scrolling:touch}div:where(.swal2-container).swal2-backdrop-show,div:where(.swal2-container).swal2-noanimation{background:var(--swal2-backdrop)}div:where(.swal2-container).swal2-backdrop-hide{background:rgba(0,0,0,0) !important}div:where(.swal2-container).swal2-top-start,div:where(.swal2-container).swal2-center-start,div:where(.swal2-container).swal2-bottom-start{grid-template-columns:minmax(0, 1fr) auto auto}div:where(.swal2-container).swal2-top,div:where(.swal2-container).swal2-center,div:where(.swal2-container).swal2-bottom{grid-template-columns:auto minmax(0, 1fr) auto}div:where(.swal2-container).swal2-top-end,div:where(.swal2-container).swal2-center-end,div:where(.swal2-container).swal2-bottom-end{grid-template-columns:auto auto minmax(0, 1fr)}div:where(.swal2-container).swal2-top-start>.swal2-popup{align-self:start}div:where(.swal2-container).swal2-top>.swal2-popup{grid-column:2;place-self:start center}div:where(.swal2-container).swal2-top-end>.swal2-popup,div:where(.swal2-container).swal2-top-right>.swal2-popup{grid-column:3;place-self:start end}div:where(.swal2-container).swal2-center-start>.swal2-popup,div:where(.swal2-container).swal2-center-left>.swal2-popup{grid-row:2;align-self:center}div:where(.swal2-container).swal2-center>.swal2-popup{grid-column:2;grid-row:2;place-self:center center}div:where(.swal2-container).swal2-center-end>.swal2-popup,div:where(.swal2-container).swal2-center-right>.swal2-popup{grid-column:3;grid-row:2;place-self:center end}div:where(.swal2-container).swal2-bottom-start>.swal2-popup,div:where(.swal2-container).swal2-bottom-left>.swal2-popup{grid-column:1;grid-row:3;align-self:end}div:where(.swal2-container).swal2-bottom>.swal2-popup{grid-column:2;grid-row:3;place-self:end center}div:where(.swal2-container).swal2-bottom-end>.swal2-popup,div:where(.swal2-container).swal2-bottom-right>.swal2-popup{grid-column:3;grid-row:3;place-self:end end}div:where(.swal2-container).swal2-grow-row>.swal2-popup,div:where(.swal2-container).swal2-grow-fullscreen>.swal2-popup{grid-column:1/4;width:100%}div:where(.swal2-container).swal2-grow-column>.swal2-popup,div:where(.swal2-container).swal2-grow-fullscreen>.swal2-popup{grid-row:1/4;align-self:stretch}div:where(.swal2-container).swal2-no-transition{transition:none !important}div:where(.swal2-container) div:where(.swal2-popup){display:none;position:relative;box-sizing:border-box;grid-template-columns:minmax(0, 100%);width:var(--swal2-width);max-width:100%;padding:var(--swal2-padding);border:var(--swal2-border);border-radius:var(--swal2-border-radius);background:var(--swal2-background);color:var(--swal2-color);font-family:inherit;font-size:1rem}div:where(.swal2-container) div:where(.swal2-popup):focus{outline:none}div:where(.swal2-container) div:where(.swal2-popup).swal2-loading{overflow-y:hidden}div:where(.swal2-container) div:where(.swal2-popup).swal2-draggable{cursor:grab}div:where(.swal2-container) div:where(.swal2-popup).swal2-draggable div:where(.swal2-icon){cursor:grab}div:where(.swal2-container) div:where(.swal2-popup).swal2-dragging{cursor:grabbing}div:where(.swal2-container) div:where(.swal2-popup).swal2-dragging div:where(.swal2-icon){cursor:grabbing}div:where(.swal2-container) h2:where(.swal2-title){position:relative;max-width:100%;margin:0;padding:.8em 1em 0;color:inherit;font-size:1.875em;font-weight:600;text-align:center;text-transform:none;word-wrap:break-word;cursor:initial}div:where(.swal2-container) div:where(.swal2-actions){display:flex;z-index:1;box-sizing:border-box;flex-wrap:wrap;align-items:center;justify-content:center;width:auto;margin:1.25em auto 0;padding:0}div:where(.swal2-container) div:where(.swal2-actions):not(.swal2-loading) .swal2-styled[disabled]{opacity:.4}div:where(.swal2-container) div:where(.swal2-actions):not(.swal2-loading) .swal2-styled:hover{background-image:linear-gradient(rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0.1))}div:where(.swal2-container) div:where(.swal2-actions):not(.swal2-loading) .swal2-styled:active{background-image:linear-gradient(rgba(0, 0, 0, 0.2), rgba(0, 0, 0, 0.2))}div:where(.swal2-container) div:where(.swal2-loader){display:none;align-items:center;justify-content:center;width:2.2em;height:2.2em;margin:0 1.875em;animation:swal2-rotate-loading 1.5s linear 0s infinite normal;border-width:.25em;border-style:solid;border-radius:100%;border-color:#2778c4 rgba(0,0,0,0) #2778c4 rgba(0,0,0,0)}div:where(.swal2-container) button:where(.swal2-styled){margin:.3125em;padding:.625em 1.1em;transition:box-shadow .1s;box-shadow:0 0 0 3px rgba(0,0,0,0);font-weight:500}div:where(.swal2-container) button:where(.swal2-styled):not([disabled]){cursor:pointer}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-confirm){border:0;border-radius:.25em;background:initial;background-color:#7066e0;color:#fff;font-size:1em}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-confirm):focus-visible{box-shadow:0 0 0 3px rgba(112,102,224,.5)}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-deny){border:0;border-radius:.25em;background:initial;background-color:#dc3741;color:#fff;font-size:1em}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-deny):focus-visible{box-shadow:0 0 0 3px rgba(220,55,65,.5)}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-cancel){border:0;border-radius:.25em;background:initial;background-color:#6e7881;color:#fff;font-size:1em}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-cancel):focus-visible{box-shadow:0 0 0 3px rgba(110,120,129,.5)}div:where(.swal2-container) button:where(.swal2-styled).swal2-default-outline:focus-visible{box-shadow:0 0 0 3px rgba(100,150,200,.5)}div:where(.swal2-container) button:where(.swal2-styled):focus-visible{outline:none}div:where(.swal2-container) button:where(.swal2-styled)::-moz-focus-inner{border:0}div:where(.swal2-container) div:where(.swal2-footer){margin:1em 0 0;padding:1em 1em 0;border-top:1px solid var(--swal2-footer-border-color);color:inherit;font-size:1em;text-align:center;cursor:initial}div:where(.swal2-container) .swal2-timer-progress-bar-container{position:absolute;right:0;bottom:0;left:0;grid-column:auto !important;overflow:hidden;border-bottom-right-radius:var(--swal2-border-radius);border-bottom-left-radius:var(--swal2-border-radius)}div:where(.swal2-container) div:where(.swal2-timer-progress-bar){width:100%;height:.25em;background:rgba(0,0,0,.2)}div:where(.swal2-container) img:where(.swal2-image){max-width:100%;margin:2em auto 1em;cursor:initial}div:where(.swal2-container) button:where(.swal2-close){z-index:2;align-items:center;justify-content:center;width:1.2em;height:1.2em;margin-top:0;margin-right:0;margin-bottom:-1.2em;padding:0;overflow:hidden;transition:color .1s,box-shadow .1s;border:none;border-radius:var(--swal2-border-radius);background:rgba(0,0,0,0);color:#ccc;font-family:monospace;font-size:2.5em;cursor:pointer;justify-self:end}div:where(.swal2-container) button:where(.swal2-close):hover{transform:none;background:rgba(0,0,0,0);color:#f27474}div:where(.swal2-container) button:where(.swal2-close):focus-visible{outline:none;box-shadow:inset 0 0 0 3px rgba(100,150,200,.5)}div:where(.swal2-container) button:where(.swal2-close)::-moz-focus-inner{border:0}div:where(.swal2-container) div:where(.swal2-html-container){z-index:1;justify-content:center;margin:0;padding:1em 1.6em .3em;overflow:auto;color:inherit;font-size:1.125em;font-weight:normal;line-height:normal;text-align:center;word-wrap:break-word;word-break:break-word;cursor:initial}div:where(.swal2-container) input:where(.swal2-input),div:where(.swal2-container) input:where(.swal2-file),div:where(.swal2-container) textarea:where(.swal2-textarea),div:where(.swal2-container) select:where(.swal2-select),div:where(.swal2-container) div:where(.swal2-radio),div:where(.swal2-container) label:where(.swal2-checkbox){margin:1em 2em 3px}div:where(.swal2-container) input:where(.swal2-input),div:where(.swal2-container) input:where(.swal2-file),div:where(.swal2-container) textarea:where(.swal2-textarea){box-sizing:border-box;width:auto;transition:border-color .1s,box-shadow .1s;border:1px solid #d9d9d9;border-radius:.1875em;background:var(--swal2-input-background);box-shadow:inset 0 1px 1px rgba(0,0,0,.06),0 0 0 3px rgba(0,0,0,0);color:inherit;font-size:1.125em}div:where(.swal2-container) input:where(.swal2-input).swal2-inputerror,div:where(.swal2-container) input:where(.swal2-file).swal2-inputerror,div:where(.swal2-container) textarea:where(.swal2-textarea).swal2-inputerror{border-color:#f27474 !important;box-shadow:0 0 2px #f27474 !important}div:where(.swal2-container) input:where(.swal2-input):focus,div:where(.swal2-container) input:where(.swal2-file):focus,div:where(.swal2-container) textarea:where(.swal2-textarea):focus{border:1px solid #b4dbed;outline:none;box-shadow:inset 0 1px 1px rgba(0,0,0,.06),0 0 0 3px rgba(100,150,200,.5)}div:where(.swal2-container) input:where(.swal2-input)::placeholder,div:where(.swal2-container) input:where(.swal2-file)::placeholder,div:where(.swal2-container) textarea:where(.swal2-textarea)::placeholder{color:#ccc}div:where(.swal2-container) .swal2-range{margin:1em 2em 3px;background:var(--swal2-background)}div:where(.swal2-container) .swal2-range input{width:80%}div:where(.swal2-container) .swal2-range output{width:20%;color:inherit;font-weight:600;text-align:center}div:where(.swal2-container) .swal2-range input,div:where(.swal2-container) .swal2-range output{height:2.625em;padding:0;font-size:1.125em;line-height:2.625em}div:where(.swal2-container) .swal2-input{height:2.625em;padding:0 .75em}div:where(.swal2-container) .swal2-file{width:75%;margin-right:auto;margin-left:auto;background:var(--swal2-input-background);font-size:1.125em}div:where(.swal2-container) .swal2-textarea{height:6.75em;padding:.75em}div:where(.swal2-container) .swal2-select{min-width:50%;max-width:100%;padding:.375em .625em;background:var(--swal2-input-background);color:inherit;font-size:1.125em}div:where(.swal2-container) .swal2-radio,div:where(.swal2-container) .swal2-checkbox{align-items:center;justify-content:center;background:var(--swal2-background);color:inherit}div:where(.swal2-container) .swal2-radio label,div:where(.swal2-container) .swal2-checkbox label{margin:0 .6em;font-size:1.125em}div:where(.swal2-container) .swal2-radio input,div:where(.swal2-container) .swal2-checkbox input{flex-shrink:0;margin:0 .4em}div:where(.swal2-container) label:where(.swal2-input-label){display:flex;justify-content:center;margin:1em auto 0}div:where(.swal2-container) div:where(.swal2-validation-message){align-items:center;justify-content:center;margin:1em 0 0;padding:.625em;overflow:hidden;background:var(--swal2-validation-message-background);color:var(--swal2-validation-message-color);font-size:1em;font-weight:300}div:where(.swal2-container) div:where(.swal2-validation-message)::before{content:\"!\";display:inline-block;width:1.5em;min-width:1.5em;height:1.5em;margin:0 .625em;border-radius:50%;background-color:#f27474;color:#fff;font-weight:600;line-height:1.5em;text-align:center}div:where(.swal2-container) .swal2-progress-steps{flex-wrap:wrap;align-items:center;max-width:100%;margin:1.25em auto;padding:0;background:rgba(0,0,0,0);font-weight:600}div:where(.swal2-container) .swal2-progress-steps li{display:inline-block;position:relative}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step{z-index:20;flex-shrink:0;width:2em;height:2em;border-radius:2em;background:#2778c4;color:#fff;line-height:2em;text-align:center}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step.swal2-active-progress-step{background:#2778c4}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step.swal2-active-progress-step~.swal2-progress-step{background:#add8e6;color:#fff}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step.swal2-active-progress-step~.swal2-progress-step-line{background:#add8e6}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step-line{z-index:10;flex-shrink:0;width:2.5em;height:.4em;margin:0 -1px;background:#2778c4}div:where(.swal2-icon){position:relative;box-sizing:content-box;justify-content:center;width:5em;height:5em;margin:2.5em auto .6em;border:.25em solid rgba(0,0,0,0);border-radius:50%;border-color:#000;font-family:inherit;line-height:5em;cursor:default;user-select:none}div:where(.swal2-icon) .swal2-icon-content{display:flex;align-items:center;font-size:3.75em}div:where(.swal2-icon).swal2-error{border-color:#f27474;color:#f27474}div:where(.swal2-icon).swal2-error .swal2-x-mark{position:relative;flex-grow:1}div:where(.swal2-icon).swal2-error [class^=swal2-x-mark-line]{display:block;position:absolute;top:2.3125em;width:2.9375em;height:.3125em;border-radius:.125em;background-color:#f27474}div:where(.swal2-icon).swal2-error [class^=swal2-x-mark-line][class$=left]{left:1.0625em;transform:rotate(45deg)}div:where(.swal2-icon).swal2-error [class^=swal2-x-mark-line][class$=right]{right:1em;transform:rotate(-45deg)}div:where(.swal2-icon).swal2-error.swal2-icon-show{animation:swal2-animate-error-icon .5s}div:where(.swal2-icon).swal2-error.swal2-icon-show .swal2-x-mark{animation:swal2-animate-error-x-mark .5s}div:where(.swal2-icon).swal2-warning{border-color:#f8bb86;color:#f8bb86}div:where(.swal2-icon).swal2-warning.swal2-icon-show{animation:swal2-animate-error-icon .5s}div:where(.swal2-icon).swal2-warning.swal2-icon-show .swal2-icon-content{animation:swal2-animate-i-mark .5s}div:where(.swal2-icon).swal2-info{border-color:#3fc3ee;color:#3fc3ee}div:where(.swal2-icon).swal2-info.swal2-icon-show{animation:swal2-animate-error-icon .5s}div:where(.swal2-icon).swal2-info.swal2-icon-show .swal2-icon-content{animation:swal2-animate-i-mark .8s}div:where(.swal2-icon).swal2-question{border-color:#87adbd;color:#87adbd}div:where(.swal2-icon).swal2-question.swal2-icon-show{animation:swal2-animate-error-icon .5s}div:where(.swal2-icon).swal2-question.swal2-icon-show .swal2-icon-content{animation:swal2-animate-question-mark .8s}div:where(.swal2-icon).swal2-success{border-color:#a5dc86;color:#a5dc86}div:where(.swal2-icon).swal2-success [class^=swal2-success-circular-line]{position:absolute;width:3.75em;height:7.5em;border-radius:50%}div:where(.swal2-icon).swal2-success [class^=swal2-success-circular-line][class$=left]{top:-0.4375em;left:-2.0635em;transform:rotate(-45deg);transform-origin:3.75em 3.75em;border-radius:7.5em 0 0 7.5em}div:where(.swal2-icon).swal2-success [class^=swal2-success-circular-line][class$=right]{top:-0.6875em;left:1.875em;transform:rotate(-45deg);transform-origin:0 3.75em;border-radius:0 7.5em 7.5em 0}div:where(.swal2-icon).swal2-success .swal2-success-ring{position:absolute;z-index:2;top:-0.25em;left:-0.25em;box-sizing:content-box;width:100%;height:100%;border:.25em solid rgba(165,220,134,.3);border-radius:50%}div:where(.swal2-icon).swal2-success .swal2-success-fix{position:absolute;z-index:1;top:.5em;left:1.625em;width:.4375em;height:5.625em;transform:rotate(-45deg)}div:where(.swal2-icon).swal2-success [class^=swal2-success-line]{display:block;position:absolute;z-index:2;height:.3125em;border-radius:.125em;background-color:#a5dc86}div:where(.swal2-icon).swal2-success [class^=swal2-success-line][class$=tip]{top:2.875em;left:.8125em;width:1.5625em;transform:rotate(45deg)}div:where(.swal2-icon).swal2-success [class^=swal2-success-line][class$=long]{top:2.375em;right:.5em;width:2.9375em;transform:rotate(-45deg)}div:where(.swal2-icon).swal2-success.swal2-icon-show .swal2-success-line-tip{animation:swal2-animate-success-line-tip .75s}div:where(.swal2-icon).swal2-success.swal2-icon-show .swal2-success-line-long{animation:swal2-animate-success-line-long .75s}div:where(.swal2-icon).swal2-success.swal2-icon-show .swal2-success-circular-line-right{animation:swal2-rotate-success-circular-line 4.25s ease-in}[class^=swal2]{-webkit-tap-highlight-color:rgba(0,0,0,0)}.swal2-show{animation:swal2-show .3s}.swal2-hide{animation:swal2-hide .15s forwards}.swal2-noanimation{transition:none}.swal2-scrollbar-measure{position:absolute;top:-9999px;width:50px;height:50px;overflow:scroll}.swal2-rtl .swal2-close{margin-right:initial;margin-left:0}.swal2-rtl .swal2-timer-progress-bar{right:0;left:auto}.swal2-toast{box-sizing:border-box;grid-column:1/4 !important;grid-row:1/4 !important;grid-template-columns:min-content auto min-content;padding:1em;overflow-y:hidden;background:#fff;box-shadow:0 0 1px rgba(0,0,0,.075),0 1px 2px rgba(0,0,0,.075),1px 2px 4px rgba(0,0,0,.075),1px 3px 8px rgba(0,0,0,.075),2px 4px 16px rgba(0,0,0,.075);pointer-events:all}.swal2-toast>*{grid-column:2}.swal2-toast h2:where(.swal2-title){margin:.5em 1em;padding:0;font-size:1em;text-align:initial}.swal2-toast .swal2-loading{justify-content:center}.swal2-toast input:where(.swal2-input){height:2em;margin:.5em;font-size:1em}.swal2-toast .swal2-validation-message{font-size:1em}.swal2-toast div:where(.swal2-footer){margin:.5em 0 0;padding:.5em 0 0;font-size:.8em}.swal2-toast button:where(.swal2-close){grid-column:3/3;grid-row:1/99;align-self:center;width:.8em;height:.8em;margin:0;font-size:2em}.swal2-toast div:where(.swal2-html-container){margin:.5em 1em;padding:0;overflow:initial;font-size:1em;text-align:initial}.swal2-toast div:where(.swal2-html-container):empty{padding:0}.swal2-toast .swal2-loader{grid-column:1;grid-row:1/99;align-self:center;width:2em;height:2em;margin:.25em}.swal2-toast .swal2-icon{grid-column:1;grid-row:1/99;align-self:center;width:2em;min-width:2em;height:2em;margin:0 .5em 0 0}.swal2-toast .swal2-icon .swal2-icon-content{display:flex;align-items:center;font-size:1.8em;font-weight:bold}.swal2-toast .swal2-icon.swal2-success .swal2-success-ring{width:2em;height:2em}.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line]{top:.875em;width:1.375em}.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=left]{left:.3125em}.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=right]{right:.3125em}.swal2-toast div:where(.swal2-actions){justify-content:flex-start;height:auto;margin:0;margin-top:.5em;padding:0 .5em}.swal2-toast button:where(.swal2-styled){margin:.25em .5em;padding:.4em .6em;font-size:1em}.swal2-toast .swal2-success{border-color:#a5dc86}.swal2-toast .swal2-success [class^=swal2-success-circular-line]{position:absolute;width:1.6em;height:3em;border-radius:50%}.swal2-toast .swal2-success [class^=swal2-success-circular-line][class$=left]{top:-0.8em;left:-0.5em;transform:rotate(-45deg);transform-origin:2em 2em;border-radius:4em 0 0 4em}.swal2-toast .swal2-success [class^=swal2-success-circular-line][class$=right]{top:-0.25em;left:.9375em;transform-origin:0 1.5em;border-radius:0 4em 4em 0}.swal2-toast .swal2-success .swal2-success-ring{width:2em;height:2em}.swal2-toast .swal2-success .swal2-success-fix{top:0;left:.4375em;width:.4375em;height:2.6875em}.swal2-toast .swal2-success [class^=swal2-success-line]{height:.3125em}.swal2-toast .swal2-success [class^=swal2-success-line][class$=tip]{top:1.125em;left:.1875em;width:.75em}.swal2-toast .swal2-success [class^=swal2-success-line][class$=long]{top:.9375em;right:.1875em;width:1.375em}.swal2-toast .swal2-success.swal2-icon-show .swal2-success-line-tip{animation:swal2-toast-animate-success-line-tip .75s}.swal2-toast .swal2-success.swal2-icon-show .swal2-success-line-long{animation:swal2-toast-animate-success-line-long .75s}.swal2-toast.swal2-show{animation:swal2-toast-show .5s}.swal2-toast.swal2-hide{animation:swal2-toast-hide .1s forwards}@keyframes swal2-show{0%{transform:scale(0.7)}45%{transform:scale(1.05)}80%{transform:scale(0.95)}100%{transform:scale(1)}}@keyframes swal2-hide{0%{transform:scale(1);opacity:1}100%{transform:scale(0.5);opacity:0}}@keyframes swal2-animate-success-line-tip{0%{top:1.1875em;left:.0625em;width:0}54%{top:1.0625em;left:.125em;width:0}70%{top:2.1875em;left:-0.375em;width:3.125em}84%{top:3em;left:1.3125em;width:1.0625em}100%{top:2.8125em;left:.8125em;width:1.5625em}}@keyframes swal2-animate-success-line-long{0%{top:3.375em;right:2.875em;width:0}65%{top:3.375em;right:2.875em;width:0}84%{top:2.1875em;right:0;width:3.4375em}100%{top:2.375em;right:.5em;width:2.9375em}}@keyframes swal2-rotate-success-circular-line{0%{transform:rotate(-45deg)}5%{transform:rotate(-45deg)}12%{transform:rotate(-405deg)}100%{transform:rotate(-405deg)}}@keyframes swal2-animate-error-x-mark{0%{margin-top:1.625em;transform:scale(0.4);opacity:0}50%{margin-top:1.625em;transform:scale(0.4);opacity:0}80%{margin-top:-0.375em;transform:scale(1.15)}100%{margin-top:0;transform:scale(1);opacity:1}}@keyframes swal2-animate-error-icon{0%{transform:rotateX(100deg);opacity:0}100%{transform:rotateX(0deg);opacity:1}}@keyframes swal2-rotate-loading{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}@keyframes swal2-animate-question-mark{0%{transform:rotateY(-360deg)}100%{transform:rotateY(0)}}@keyframes swal2-animate-i-mark{0%{transform:rotateZ(45deg);opacity:0}25%{transform:rotateZ(-25deg);opacity:.4}50%{transform:rotateZ(15deg);opacity:.8}75%{transform:rotateZ(-5deg);opacity:1}100%{transform:rotateX(0);opacity:1}}@keyframes swal2-toast-show{0%{transform:translateY(-0.625em) rotateZ(2deg)}33%{transform:translateY(0) rotateZ(-2deg)}66%{transform:translateY(0.3125em) rotateZ(2deg)}100%{transform:translateY(0) rotateZ(0deg)}}@keyframes swal2-toast-hide{100%{transform:rotateZ(1deg);opacity:0}}@keyframes swal2-toast-animate-success-line-tip{0%{top:.5625em;left:.0625em;width:0}54%{top:.125em;left:.125em;width:0}70%{top:.625em;left:-0.25em;width:1.625em}84%{top:1.0625em;left:.75em;width:.5em}100%{top:1.125em;left:.1875em;width:.75em}}@keyframes swal2-toast-animate-success-line-long{0%{top:1.625em;right:1.375em;width:0}65%{top:1.25em;right:.9375em;width:0}84%{top:.9375em;right:0;width:1.125em}100%{top:.9375em;right:.1875em;width:1.375em}}"); 
    } (sweetalert2_all));

    var sweetalert2_allExports = sweetalert2_all.exports;
    var Swal = /*@__PURE__*/getDefaultExportFromCjs(sweetalert2_allExports);

    /* src\Components\Form\FormField.svelte generated by Svelte v3.59.2 */

    const file$l = "src\\Components\\Form\\FormField.svelte";

    // (89:4) {:else}
    function create_else_block$4(ctx) {
    	let input;
    	let input_type_value;
    	let input_class_value;
    	let input_autocomplete_value;
    	let input_placeholder_value;
    	let input_value_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			input = element("input");

    			attr_dev(input, "type", input_type_value = /*type*/ ctx[5] === "password-nocheck"
    			? "password"
    			: /*type*/ ctx[5]);

    			attr_dev(input, "class", input_class_value = "w-full border rounded p-2 " + (/*errorMessage*/ ctx[8] || /*internalErrorMessage*/ ctx[9]
    			? 'border-red-600'
    			: ''));

    			input.required = /*required*/ ctx[4];
    			attr_dev(input, "maxlength", /*maxLength*/ ctx[2]);
    			attr_dev(input, "minlength", /*minLength*/ ctx[3]);
    			attr_dev(input, "min", /*min*/ ctx[6]);
    			attr_dev(input, "max", /*max*/ ctx[7]);
    			attr_dev(input, "autocomplete", input_autocomplete_value = /*type*/ ctx[5] == "password" ? "off" : "on");
    			attr_dev(input, "placeholder", input_placeholder_value = /*name*/ ctx[1] + (/*required*/ ctx[4] ? "*" : ""));
    			input.value = input_value_value = /*value*/ ctx[0] || "";
    			add_location(input, file$l, 89, 8, 3506);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);

    			if (!mounted) {
    				dispose = listen_dev(input, "change", /*valueChanged*/ ctx[10], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*type*/ 32 && input_type_value !== (input_type_value = /*type*/ ctx[5] === "password-nocheck"
    			? "password"
    			: /*type*/ ctx[5])) {
    				attr_dev(input, "type", input_type_value);
    			}

    			if (dirty & /*errorMessage, internalErrorMessage*/ 768 && input_class_value !== (input_class_value = "w-full border rounded p-2 " + (/*errorMessage*/ ctx[8] || /*internalErrorMessage*/ ctx[9]
    			? 'border-red-600'
    			: ''))) {
    				attr_dev(input, "class", input_class_value);
    			}

    			if (dirty & /*required*/ 16) {
    				prop_dev(input, "required", /*required*/ ctx[4]);
    			}

    			if (dirty & /*maxLength*/ 4) {
    				attr_dev(input, "maxlength", /*maxLength*/ ctx[2]);
    			}

    			if (dirty & /*minLength*/ 8) {
    				attr_dev(input, "minlength", /*minLength*/ ctx[3]);
    			}

    			if (dirty & /*min*/ 64) {
    				attr_dev(input, "min", /*min*/ ctx[6]);
    			}

    			if (dirty & /*max*/ 128) {
    				attr_dev(input, "max", /*max*/ ctx[7]);
    			}

    			if (dirty & /*type*/ 32 && input_autocomplete_value !== (input_autocomplete_value = /*type*/ ctx[5] == "password" ? "off" : "on")) {
    				attr_dev(input, "autocomplete", input_autocomplete_value);
    			}

    			if (dirty & /*name, required*/ 18 && input_placeholder_value !== (input_placeholder_value = /*name*/ ctx[1] + (/*required*/ ctx[4] ? "*" : ""))) {
    				attr_dev(input, "placeholder", input_placeholder_value);
    			}

    			if (dirty & /*value*/ 1 && input_value_value !== (input_value_value = /*value*/ ctx[0] || "") && input.value !== input_value_value) {
    				prop_dev(input, "value", input_value_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$4.name,
    		type: "else",
    		source: "(89:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (77:4) {#if type === "longtext"}
    function create_if_block$6(ctx) {
    	let textarea;
    	let textarea_class_value;
    	let textarea_placeholder_value;
    	let textarea_value_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			textarea = element("textarea");

    			attr_dev(textarea, "class", textarea_class_value = "h-64 w-full border p-2 rounded " + (/*errorMessage*/ ctx[8] || /*internalErrorMessage*/ ctx[9]
    			? 'border-red-600'
    			: ''));

    			textarea.required = /*required*/ ctx[4];
    			attr_dev(textarea, "maxlength", /*maxLength*/ ctx[2]);
    			attr_dev(textarea, "minlength", /*minLength*/ ctx[3]);
    			attr_dev(textarea, "placeholder", textarea_placeholder_value = /*name*/ ctx[1] + (/*required*/ ctx[4] ? "*" : ""));
    			textarea.value = textarea_value_value = /*value*/ ctx[0] || "";
    			add_location(textarea, file$l, 77, 8, 3089);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, textarea, anchor);

    			if (!mounted) {
    				dispose = listen_dev(textarea, "change", /*valueChanged*/ ctx[10], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*errorMessage, internalErrorMessage*/ 768 && textarea_class_value !== (textarea_class_value = "h-64 w-full border p-2 rounded " + (/*errorMessage*/ ctx[8] || /*internalErrorMessage*/ ctx[9]
    			? 'border-red-600'
    			: ''))) {
    				attr_dev(textarea, "class", textarea_class_value);
    			}

    			if (dirty & /*required*/ 16) {
    				prop_dev(textarea, "required", /*required*/ ctx[4]);
    			}

    			if (dirty & /*maxLength*/ 4) {
    				attr_dev(textarea, "maxlength", /*maxLength*/ ctx[2]);
    			}

    			if (dirty & /*minLength*/ 8) {
    				attr_dev(textarea, "minlength", /*minLength*/ ctx[3]);
    			}

    			if (dirty & /*name, required*/ 18 && textarea_placeholder_value !== (textarea_placeholder_value = /*name*/ ctx[1] + (/*required*/ ctx[4] ? "*" : ""))) {
    				attr_dev(textarea, "placeholder", textarea_placeholder_value);
    			}

    			if (dirty & /*value*/ 1 && textarea_value_value !== (textarea_value_value = /*value*/ ctx[0] || "")) {
    				prop_dev(textarea, "value", textarea_value_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(textarea);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$6.name,
    		type: "if",
    		source: "(77:4) {#if type === \\\"longtext\\\"}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$m(ctx) {
    	let div;
    	let t0;
    	let small;
    	let t1_value = (/*errorMessage*/ ctx[8] || /*internalErrorMessage*/ ctx[9]) + "";
    	let t1;

    	function select_block_type(ctx, dirty) {
    		if (/*type*/ ctx[5] === "longtext") return create_if_block$6;
    		return create_else_block$4;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if_block.c();
    			t0 = space();
    			small = element("small");
    			t1 = text(t1_value);
    			attr_dev(small, "class", "text-red-600");
    			add_location(small, file$l, 106, 4, 4087);
    			attr_dev(div, "class", "p-2 w-full");
    			add_location(div, file$l, 75, 0, 3024);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if_block.m(div, null);
    			append_dev(div, t0);
    			append_dev(div, small);
    			append_dev(small, t1);
    		},
    		p: function update(ctx, [dirty]) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div, t0);
    				}
    			}

    			if (dirty & /*errorMessage, internalErrorMessage*/ 768 && t1_value !== (t1_value = (/*errorMessage*/ ctx[8] || /*internalErrorMessage*/ ctx[9]) + "")) set_data_dev(t1, t1_value);
    		},
    		i: noop$1,
    		o: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$m.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$m($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('FormField', slots, []);
    	let internalErrorMessage = "";
    	let { value = undefined } = $$props;
    	let { onchange = undefined } = $$props;
    	let { name } = $$props;
    	let { maxLength = undefined } = $$props;
    	let { minLength = undefined } = $$props;
    	let { required = true } = $$props;
    	let { type = "text" } = $$props;
    	let { min = undefined } = $$props;
    	let { max = undefined } = $$props;
    	let { errorMessage = "" } = $$props;

    	function valueChanged(event) {
    		$$invalidate(9, internalErrorMessage = "");
    		const value = event.target.value;

    		if (!value && required) {
    			$$invalidate(9, internalErrorMessage = name + " is verplicht");

    			onchange === null || onchange === void 0
    			? void 0
    			: onchange(value, false);

    			return;
    		}

    		if (maxLength && value.length > maxLength) {
    			$$invalidate(9, internalErrorMessage = name + " mag niet langer zijn dan " + maxLength + " karakters.");

    			onchange === null || onchange === void 0
    			? void 0
    			: onchange(value, false);

    			return;
    		}

    		if (minLength && value.length < minLength) {
    			$$invalidate(9, internalErrorMessage = name + " mag niet korter zijn dan " + minLength + " karakters.");

    			onchange === null || onchange === void 0
    			? void 0
    			: onchange(value, false);

    			return;
    		}

    		if (type == "password") {
    			const passwordRegex = /^.*(?=.{8,})(?=.*[a-zA-Z])(?=.*\d)(?=.*[!#$%&? "]).*$/;

    			if (!value.match(passwordRegex)) {
    				$$invalidate(9, internalErrorMessage = name + " moet minimaal 8 karakters lang zijn, een getal, hoofdletter en een speciaal karakter bevatten.");

    				onchange === null || onchange === void 0
    				? void 0
    				: onchange(value, false);

    				return;
    			}
    		}

    		if (type == "email") {
    			const emailRegex = /^(([^<>()[\]\.,;:\s@\"]+(\.[^<>()[\]\.,;:\s@\"]+)*)|(\".+\"))@(([^<>()[\]\.,;:\s@\"]+\.)+[^<>()[\]\.,;:\s@\"]{2,})$/i;

    			if (!value.match(emailRegex)) {
    				$$invalidate(9, internalErrorMessage = name + " is een ongeldige e-mail adres");

    				onchange === null || onchange === void 0
    				? void 0
    				: onchange(value, false);

    				return;
    			}
    		}

    		if (type == "number") {
    			try {
    				const val = parseInt(value);

    				if (val > max) {
    					$$invalidate(9, internalErrorMessage = name + " mag niet groter zijn dan " + max);

    					onchange === null || onchange === void 0
    					? void 0
    					: onchange(value, false);

    					return;
    				}

    				if (val < min) {
    					$$invalidate(9, internalErrorMessage = name + " mag niet kleiner zijn dan " + min);

    					onchange === null || onchange === void 0
    					? void 0
    					: onchange(value, false);

    					return;
    				}
    			} catch(e) {
    				$$invalidate(9, internalErrorMessage = name + " is een ongeldig getal");

    				onchange === null || onchange === void 0
    				? void 0
    				: onchange(value, false);

    				return;
    			}
    		}

    		onchange === null || onchange === void 0
    		? void 0
    		: onchange(value, true);
    	}

    	$$self.$$.on_mount.push(function () {
    		if (name === undefined && !('name' in $$props || $$self.$$.bound[$$self.$$.props['name']])) {
    			console.warn("<FormField> was created without expected prop 'name'");
    		}
    	});

    	const writable_props = [
    		'value',
    		'onchange',
    		'name',
    		'maxLength',
    		'minLength',
    		'required',
    		'type',
    		'min',
    		'max',
    		'errorMessage'
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<FormField> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('value' in $$props) $$invalidate(0, value = $$props.value);
    		if ('onchange' in $$props) $$invalidate(11, onchange = $$props.onchange);
    		if ('name' in $$props) $$invalidate(1, name = $$props.name);
    		if ('maxLength' in $$props) $$invalidate(2, maxLength = $$props.maxLength);
    		if ('minLength' in $$props) $$invalidate(3, minLength = $$props.minLength);
    		if ('required' in $$props) $$invalidate(4, required = $$props.required);
    		if ('type' in $$props) $$invalidate(5, type = $$props.type);
    		if ('min' in $$props) $$invalidate(6, min = $$props.min);
    		if ('max' in $$props) $$invalidate(7, max = $$props.max);
    		if ('errorMessage' in $$props) $$invalidate(8, errorMessage = $$props.errorMessage);
    	};

    	$$self.$capture_state = () => ({
    		internalErrorMessage,
    		value,
    		onchange,
    		name,
    		maxLength,
    		minLength,
    		required,
    		type,
    		min,
    		max,
    		errorMessage,
    		valueChanged
    	});

    	$$self.$inject_state = $$props => {
    		if ('internalErrorMessage' in $$props) $$invalidate(9, internalErrorMessage = $$props.internalErrorMessage);
    		if ('value' in $$props) $$invalidate(0, value = $$props.value);
    		if ('onchange' in $$props) $$invalidate(11, onchange = $$props.onchange);
    		if ('name' in $$props) $$invalidate(1, name = $$props.name);
    		if ('maxLength' in $$props) $$invalidate(2, maxLength = $$props.maxLength);
    		if ('minLength' in $$props) $$invalidate(3, minLength = $$props.minLength);
    		if ('required' in $$props) $$invalidate(4, required = $$props.required);
    		if ('type' in $$props) $$invalidate(5, type = $$props.type);
    		if ('min' in $$props) $$invalidate(6, min = $$props.min);
    		if ('max' in $$props) $$invalidate(7, max = $$props.max);
    		if ('errorMessage' in $$props) $$invalidate(8, errorMessage = $$props.errorMessage);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		value,
    		name,
    		maxLength,
    		minLength,
    		required,
    		type,
    		min,
    		max,
    		errorMessage,
    		internalErrorMessage,
    		valueChanged,
    		onchange
    	];
    }

    class FormField extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$m, create_fragment$m, safe_not_equal, {
    			value: 0,
    			onchange: 11,
    			name: 1,
    			maxLength: 2,
    			minLength: 3,
    			required: 4,
    			type: 5,
    			min: 6,
    			max: 7,
    			errorMessage: 8
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FormField",
    			options,
    			id: create_fragment$m.name
    		});
    	}

    	get value() {
    		throw new Error("<FormField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<FormField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onchange() {
    		throw new Error("<FormField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onchange(value) {
    		throw new Error("<FormField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get name() {
    		throw new Error("<FormField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set name(value) {
    		throw new Error("<FormField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get maxLength() {
    		throw new Error("<FormField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set maxLength(value) {
    		throw new Error("<FormField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get minLength() {
    		throw new Error("<FormField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set minLength(value) {
    		throw new Error("<FormField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get required() {
    		throw new Error("<FormField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set required(value) {
    		throw new Error("<FormField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get type() {
    		throw new Error("<FormField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set type(value) {
    		throw new Error("<FormField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get min() {
    		throw new Error("<FormField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set min(value) {
    		throw new Error("<FormField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get max() {
    		throw new Error("<FormField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set max(value) {
    		throw new Error("<FormField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get errorMessage() {
    		throw new Error("<FormField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set errorMessage(value) {
    		throw new Error("<FormField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    class ApiContext {
        constructor() {
            this.baseUrl = "https://localhost:7196/";
            this.userContext = new UserContext();
        }
        async updatePlant(form) {
            const response = await this.sendRequest("plants/update/" + form.id, "PUT", form);
            if (!response.ok) {
                return null;
            }
            return await response.json();
        }
        async sendRequest(url, method, body = null) {
            const headerObj = {
                'Content-Type': 'application/json',
            };
            if (this.userContext.isAuth()) {
                const bearerToken = this.userContext.token();
                headerObj['Authorization'] = 'Bearer ' + bearerToken;
            }
            const args = {
                method: method,
                headers: headerObj,
                body: undefined,
            };
            if (body) {
                args.body = JSON.stringify(body);
            }
            try {
                const response = await fetch(this.baseUrl + url, args);
                if (response.status === 401) {
                    push("/account/login");
                }
                else if (response.status === 500) {
                    throw new Error("internal server error");
                }
                return response;
            }
            catch (e) {
                Swal.fire({
                    title: "Er is iets fout gegaan",
                    text: `Een onverwachte fout is opgetreden. Probeer het later opnieuw. Als de fout blijft optreden, neem contact op met de ontwikkelaar.`
                });
            }
        }
        async submitContactForm(formObj) {
            try {
                return (await this.sendRequest("mailing/send", "POST", formObj)).ok;
            }
            catch (e) {
            }
            return false;
        }
        async submitRegistrationForm(formObj) {
            try {
                return (await this.sendRequest("account/register", "POST", formObj)).ok;
            }
            catch (e) {
            }
            return false;
        }
        async submitLogin(formObj) {
            try {
                var response = await this.sendRequest("account/login", "POST", formObj);
                if (!response.ok) {
                    return false;
                }
                const result = await response.json();
                return result;
            }
            catch (e) {
            }
            return false;
        }
        async getPlants() {
            const response = await this.sendRequest("plants", "GET");
            if (!response.ok) {
                return [];
            }
            return await response.json();
        }
        async getPlant(id) {
            const response = await this.sendRequest("plants/" + id, "GET");
            if (!response.ok) {
                return null;
            }
            return await response.json();
        }
        async plantIsConnected(id) {
            const response = await this.sendRequest("plants/state/" + id, "GET");
            const obj = await response.json();
            return obj.state === "Connected";
        }
        async createPlant(formObj) {
            const response = await this.sendRequest("plants/create", "POST", formObj);
            if (!response || !response.ok) {
                const errors = (await response.json()).errors;
                if (Object.keys(errors).length) {
                    return "SomethingWentWrong";
                }
                return "ReachedLimit";
            }
            const obj = await response.json();
            return obj;
        }
    }

    /* src\Pages\Account\Login\LoginForm.svelte generated by Svelte v3.59.2 */
    const file$k = "src\\Pages\\Account\\Login\\LoginForm.svelte";

    function create_fragment$l(ctx) {
    	let form;
    	let span;
    	let t1;
    	let div0;
    	let formfield0;
    	let t2;
    	let div1;
    	let formfield1;
    	let t3;
    	let button;
    	let current;
    	let mounted;
    	let dispose;

    	formfield0 = new FormField({
    			props: {
    				onchange: /*func*/ ctx[3],
    				name: "email",
    				type: "email",
    				maxLength: 255
    			},
    			$$inline: true
    		});

    	formfield1 = new FormField({
    			props: {
    				onchange: /*func_1*/ ctx[4],
    				name: "Wachtwoord",
    				type: "password-nocheck",
    				maxLength: 255
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			form = element("form");
    			span = element("span");
    			span.textContent = "* Verplichte velden";
    			t1 = space();
    			div0 = element("div");
    			create_component(formfield0.$$.fragment);
    			t2 = space();
    			div1 = element("div");
    			create_component(formfield1.$$.fragment);
    			t3 = space();
    			button = element("button");
    			button.textContent = "Versturen";
    			attr_dev(span, "class", "text-gray-500 ml-2");
    			add_location(span, file$k, 55, 4, 1420);
    			attr_dev(div0, "class", "md:w-1/2 w-3/4");
    			add_location(div0, file$k, 56, 4, 1485);
    			attr_dev(div1, "class", "md:w-1/2 w-3/4");
    			add_location(div1, file$k, 65, 4, 1724);
    			attr_dev(button, "type", "submit");
    			attr_dev(button, "class", "py-2 px-4 border-sky-600 bg-sky-400 text-white rounded-lg");
    			add_location(button, file$k, 74, 4, 1982);
    			attr_dev(form, "action", "");
    			attr_dev(form, "class", "p-2 w-full flex-col h-full flex items-center justify-center flex-wrap");
    			attr_dev(form, "method", "get");
    			add_location(form, file$k, 49, 0, 1266);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, form, anchor);
    			append_dev(form, span);
    			append_dev(form, t1);
    			append_dev(form, div0);
    			mount_component(formfield0, div0, null);
    			append_dev(form, t2);
    			append_dev(form, div1);
    			mount_component(formfield1, div1, null);
    			append_dev(form, t3);
    			append_dev(form, button);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(form, "submit", /*submit*/ ctx[2], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop$1,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(formfield0.$$.fragment, local);
    			transition_in(formfield1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(formfield0.$$.fragment, local);
    			transition_out(formfield1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(form);
    			destroy_component(formfield0);
    			destroy_component(formfield1);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$l.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function updateValidity$4(object, value, valid) {
    	object.value = value;
    	object.valid = valid;
    }

    function instance$l($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('LoginForm', slots, []);
    	var userContext = new UserContext();

    	if (userContext.isAuth()) {
    		push("/plants");
    	}

    	const email = { valid: false, value: "" };
    	const password = { valid: false, value: "" };

    	async function submit(event) {
    		event.preventDefault();

    		if ([password, email].some(x => !x.valid)) {
    			return;
    		}

    		var context = new ApiContext();

    		const result = await context.submitLogin({
    			email: email.value,
    			password: password.value
    		});

    		if (!result) {
    			Swal.fire({
    				title: "Kon niet inloggen",
    				text: "Email/wachtwoord combinatie was niet bekend.",
    				icon: "error"
    			});

    			return;
    		}

    		userContext.setAuth({
    			token: result.token,
    			role: result.role,
    			name: email.value
    		});

    		push("/plants");
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<LoginForm> was created with unknown prop '${key}'`);
    	});

    	const func = (value, valid) => updateValidity$4(email, value, valid);
    	const func_1 = (value, valid) => updateValidity$4(password, value, valid);

    	$$self.$capture_state = () => ({
    		Swal,
    		FormField,
    		ApiContext,
    		UserContext,
    		push,
    		userContext,
    		email,
    		password,
    		updateValidity: updateValidity$4,
    		submit
    	});

    	$$self.$inject_state = $$props => {
    		if ('userContext' in $$props) userContext = $$props.userContext;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [email, password, submit, func, func_1];
    }

    class LoginForm extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$l, create_fragment$l, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "LoginForm",
    			options,
    			id: create_fragment$l.name
    		});
    	}
    }

    /* src\Pages\Account\Login\LoginPage.svelte generated by Svelte v3.59.2 */
    const file$j = "src\\Pages\\Account\\Login\\LoginPage.svelte";

    function create_fragment$k(ctx) {
    	let div1;
    	let h1;
    	let t1;
    	let loginform;
    	let t2;
    	let div0;
    	let a;
    	let current;
    	loginform = new LoginForm({ $$inline: true });

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			h1 = element("h1");
    			h1.textContent = "Inloggen";
    			t1 = space();
    			create_component(loginform.$$.fragment);
    			t2 = space();
    			div0 = element("div");
    			a = element("a");
    			a.textContent = "Nog geen account?";
    			attr_dev(h1, "class", "text-center text-2xl w-full text-gray-900");
    			add_location(h1, file$j, 5, 4, 127);
    			attr_dev(a, "href", "/#/account/register");
    			attr_dev(a, "class", "underline");
    			add_location(a, file$j, 8, 4, 265);
    			attr_dev(div0, "class", "w-full flex justify-center");
    			add_location(div0, file$j, 7, 4, 219);
    			attr_dev(div1, "class", "flex flex-col justify-center w-full");
    			add_location(div1, file$j, 4, 0, 72);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, h1);
    			append_dev(div1, t1);
    			mount_component(loginform, div1, null);
    			append_dev(div1, t2);
    			append_dev(div1, div0);
    			append_dev(div0, a);
    			current = true;
    		},
    		p: noop$1,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(loginform.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(loginform.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_component(loginform);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$k.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$k($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('LoginPage', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<LoginPage> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ LoginForm });
    	return [];
    }

    class LoginPage extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$k, create_fragment$k, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "LoginPage",
    			options,
    			id: create_fragment$k.name
    		});
    	}
    }

    /* src\Pages\Account\Register\RegisterForm.svelte generated by Svelte v3.59.2 */
    const file$i = "src\\Pages\\Account\\Register\\RegisterForm.svelte";

    function create_fragment$j(ctx) {
    	let form;
    	let span;
    	let t1;
    	let div0;
    	let formfield0;
    	let t2;
    	let div1;
    	let formfield1;
    	let t3;
    	let div2;
    	let formfield2;
    	let t4;
    	let button;
    	let current;
    	let mounted;
    	let dispose;

    	formfield0 = new FormField({
    			props: {
    				onchange: /*func*/ ctx[5],
    				name: "email",
    				type: "email",
    				maxLength: 255
    			},
    			$$inline: true
    		});

    	formfield1 = new FormField({
    			props: {
    				onchange: /*func_1*/ ctx[6],
    				name: "Wachtwoord",
    				type: "password",
    				maxLength: 255
    			},
    			$$inline: true
    		});

    	formfield2 = new FormField({
    			props: {
    				onchange: /*func_2*/ ctx[7],
    				name: "Wachtwoordherhaling",
    				errorMessage: /*repeatPasswordErrMessage*/ ctx[0],
    				type: "password",
    				maxLength: 255
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			form = element("form");
    			span = element("span");
    			span.textContent = "* Verplichte velden";
    			t1 = space();
    			div0 = element("div");
    			create_component(formfield0.$$.fragment);
    			t2 = space();
    			div1 = element("div");
    			create_component(formfield1.$$.fragment);
    			t3 = space();
    			div2 = element("div");
    			create_component(formfield2.$$.fragment);
    			t4 = space();
    			button = element("button");
    			button.textContent = "Versturen";
    			attr_dev(span, "class", "text-gray-500 ml-2");
    			add_location(span, file$i, 64, 4, 1848);
    			attr_dev(div0, "class", "md:w-1/2 w-3/4");
    			add_location(div0, file$i, 65, 4, 1913);
    			attr_dev(div1, "class", "md:w-1/2 w-3/4");
    			add_location(div1, file$i, 74, 4, 2152);
    			attr_dev(div2, "class", "md:w-1/2 w-3/4");
    			add_location(div2, file$i, 82, 4, 2400);
    			attr_dev(button, "type", "submit");
    			attr_dev(button, "class", "py-2 px-4 border-sky-600 bg-sky-400 text-white rounded-lg");
    			add_location(button, file$i, 92, 4, 2719);
    			attr_dev(form, "action", "");
    			attr_dev(form, "class", "p-2 w-full flex-col h-full flex items-center justify-center flex-wrap");
    			attr_dev(form, "method", "get");
    			add_location(form, file$i, 58, 0, 1694);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, form, anchor);
    			append_dev(form, span);
    			append_dev(form, t1);
    			append_dev(form, div0);
    			mount_component(formfield0, div0, null);
    			append_dev(form, t2);
    			append_dev(form, div1);
    			mount_component(formfield1, div1, null);
    			append_dev(form, t3);
    			append_dev(form, div2);
    			mount_component(formfield2, div2, null);
    			append_dev(form, t4);
    			append_dev(form, button);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(form, "submit", /*submit*/ ctx[4], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			const formfield2_changes = {};
    			if (dirty & /*repeatPasswordErrMessage*/ 1) formfield2_changes.errorMessage = /*repeatPasswordErrMessage*/ ctx[0];
    			formfield2.$set(formfield2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(formfield0.$$.fragment, local);
    			transition_in(formfield1.$$.fragment, local);
    			transition_in(formfield2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(formfield0.$$.fragment, local);
    			transition_out(formfield1.$$.fragment, local);
    			transition_out(formfield2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(form);
    			destroy_component(formfield0);
    			destroy_component(formfield1);
    			destroy_component(formfield2);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$j.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function updateValidity$3(object, value, valid) {
    	object.value = value;
    	object.valid = valid;
    }

    function instance$j($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('RegisterForm', slots, []);
    	var userContext = new UserContext();

    	if (userContext.isAuth()) {
    		push("/plants");
    	}

    	const email = { valid: false, value: "" };
    	const repeatPassword = { valid: false, value: "" };
    	const password = { valid: false, value: "" };
    	let repeatPasswordErrMessage = '';

    	async function submit(event) {
    		event.preventDefault();

    		if ([repeatPassword, password, email].some(x => !x.valid)) {
    			return;
    		}

    		if (repeatPassword.value != password.value) {
    			$$invalidate(0, repeatPasswordErrMessage = 'Wachtwoorden komen niet overeen');
    			return;
    		} else {
    			$$invalidate(0, repeatPasswordErrMessage = '');
    		}

    		var context = new ApiContext();

    		const result = await context.submitRegistrationForm({
    			email: email.value,
    			password: password.value
    		});

    		await Swal.fire({
    			title: result
    			? "Account aangemaakt!"
    			: "Er is iets fout gegaan.",
    			text: result
    			? "Je account is aangemaakt. Na het wegklikken verwijzen we je naar de inlogpagina."
    			: "Je account kon niet aangemaakt worden, waarschijnlijk omdat je e-mail al bestaat.",
    			icon: result ? "success" : "error"
    		});

    		push("/account/login");
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<RegisterForm> was created with unknown prop '${key}'`);
    	});

    	const func = (value, valid) => updateValidity$3(email, value, valid);
    	const func_1 = (value, valid) => updateValidity$3(password, value, valid);
    	const func_2 = (value, valid) => updateValidity$3(repeatPassword, value, valid);

    	$$self.$capture_state = () => ({
    		Swal,
    		FormField,
    		ApiContext,
    		UserContext,
    		push,
    		userContext,
    		email,
    		repeatPassword,
    		password,
    		repeatPasswordErrMessage,
    		updateValidity: updateValidity$3,
    		submit
    	});

    	$$self.$inject_state = $$props => {
    		if ('userContext' in $$props) userContext = $$props.userContext;
    		if ('repeatPasswordErrMessage' in $$props) $$invalidate(0, repeatPasswordErrMessage = $$props.repeatPasswordErrMessage);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		repeatPasswordErrMessage,
    		email,
    		repeatPassword,
    		password,
    		submit,
    		func,
    		func_1,
    		func_2
    	];
    }

    class RegisterForm extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$j, create_fragment$j, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "RegisterForm",
    			options,
    			id: create_fragment$j.name
    		});
    	}
    }

    /* src\Pages\Account\Register\RegisterPage.svelte generated by Svelte v3.59.2 */
    const file$h = "src\\Pages\\Account\\Register\\RegisterPage.svelte";

    function create_fragment$i(ctx) {
    	let div;
    	let h1;
    	let t1;
    	let registerform;
    	let current;
    	registerform = new RegisterForm({ $$inline: true });

    	const block = {
    		c: function create() {
    			div = element("div");
    			h1 = element("h1");
    			h1.textContent = "Registreren";
    			t1 = space();
    			create_component(registerform.$$.fragment);
    			attr_dev(h1, "class", "text-center text-2xl w-full text-gray-900");
    			add_location(h1, file$h, 5, 4, 133);
    			attr_dev(div, "class", "flex flex-col justify-center w-full");
    			add_location(div, file$h, 4, 0, 78);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, h1);
    			append_dev(div, t1);
    			mount_component(registerform, div, null);
    			current = true;
    		},
    		p: noop$1,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(registerform.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(registerform.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(registerform);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$i.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$i($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('RegisterPage', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<RegisterPage> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ RegisterForm });
    	return [];
    }

    class RegisterPage extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$i, create_fragment$i, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "RegisterPage",
    			options,
    			id: create_fragment$i.name
    		});
    	}
    }

    var AccountRoutes = {
        "/account/register": RegisterPage,
        "/account/login": LoginPage
    };

    function ensureLoggedIn() {
        if (!new UserContext().isAuth()) {
            push("/account/login");
        }
    }

    /* src\Pages\Plant\Create\CreatePlantForm.svelte generated by Svelte v3.59.2 */
    const file$g = "src\\Pages\\Plant\\Create\\CreatePlantForm.svelte";

    function create_fragment$h(ctx) {
    	let form;
    	let span;
    	let t1;
    	let div0;
    	let formfield0;
    	let t2;
    	let div1;
    	let formfield1;
    	let t3;
    	let button;
    	let current;
    	let mounted;
    	let dispose;

    	formfield0 = new FormField({
    			props: {
    				onchange: /*func*/ ctx[3],
    				name: "name",
    				type: "text",
    				maxLength: 255
    			},
    			$$inline: true
    		});

    	formfield1 = new FormField({
    			props: {
    				onchange: /*func_1*/ ctx[4],
    				name: "duratie (seconden)",
    				type: "number",
    				max: 300,
    				min: 0
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			form = element("form");
    			span = element("span");
    			span.textContent = "* Verplichte velden";
    			t1 = space();
    			div0 = element("div");
    			create_component(formfield0.$$.fragment);
    			t2 = space();
    			div1 = element("div");
    			create_component(formfield1.$$.fragment);
    			t3 = space();
    			button = element("button");
    			button.textContent = "Versturen";
    			attr_dev(span, "class", "text-gray-500 ml-2");
    			add_location(span, file$g, 61, 4, 1926);
    			attr_dev(div0, "class", "md:w-1/2 w-3/4");
    			add_location(div0, file$g, 62, 4, 1991);
    			attr_dev(div1, "class", "md:w-1/2 w-3/4");
    			add_location(div1, file$g, 71, 4, 2228);
    			attr_dev(button, "type", "submit");
    			attr_dev(button, "class", "py-2 px-4 border-sky-600 bg-sky-400 text-white rounded-lg");
    			add_location(button, file$g, 81, 4, 2499);
    			attr_dev(form, "action", "");
    			attr_dev(form, "method", "get");
    			attr_dev(form, "class", "p-2 w-full flex-col h-full flex items-center justify-center flex-wrap");
    			add_location(form, file$g, 56, 0, 1774);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, form, anchor);
    			append_dev(form, span);
    			append_dev(form, t1);
    			append_dev(form, div0);
    			mount_component(formfield0, div0, null);
    			append_dev(form, t2);
    			append_dev(form, div1);
    			mount_component(formfield1, div1, null);
    			append_dev(form, t3);
    			append_dev(form, button);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(form, "submit", /*submit*/ ctx[2], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop$1,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(formfield0.$$.fragment, local);
    			transition_in(formfield1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(formfield0.$$.fragment, local);
    			transition_out(formfield1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(form);
    			destroy_component(formfield0);
    			destroy_component(formfield1);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$h.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function updateValidity$2(object, value, valid) {
    	object.value = value;
    	object.valid = valid;
    }

    function instance$h($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('CreatePlantForm', slots, []);
    	ensureLoggedIn();
    	const name = { valid: false, value: "" };
    	const duration = { valid: false, value: 0 };

    	async function submit(event) {
    		event.preventDefault();

    		if ([duration, name].some(x => !x.valid)) {
    			return;
    		}

    		var context = new ApiContext();

    		const result = await context.createPlant({
    			duration: duration.value,
    			name: name.value
    		});

    		if (result === "SomethingWentWrong") {
    			Swal.fire({
    				title: "Plant kon niet aangemaakt worden",
    				text: "De plant kon niet aangemaakt worden. Probeer het later nog een keer.",
    				icon: "error"
    			});

    			return;
    		} else if (result === "ReachedLimit") {
    			Swal.fire({
    				title: "Plant kon niet aangemaakt worden",
    				text: "U heeft uw limiet van 5 planten bereikt. Verwijder een plant of maak een nieuw account aan.",
    				icon: "error"
    			});

    			return;
    		}

    		await Swal.fire({
    			title: "Plant aangemaakt!",
    			text: "De plant is aangemaakt. Om de hydrocomputer te verbinden" + "met de server is een token nodig. Het token is: '" + result.password + "'. Sla deze goed op, deze kan niet teruggehaald worden.",
    			icon: "success"
    		});

    		push("/plants/" + result.id);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CreatePlantForm> was created with unknown prop '${key}'`);
    	});

    	const func = (value, valid) => updateValidity$2(name, value, valid);
    	const func_1 = (value, valid) => updateValidity$2(duration, value, valid);

    	$$self.$capture_state = () => ({
    		Swal,
    		FormField,
    		ApiContext,
    		push,
    		ensureLoggedIn,
    		name,
    		duration,
    		updateValidity: updateValidity$2,
    		submit
    	});

    	return [name, duration, submit, func, func_1];
    }

    class CreatePlantForm extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$h, create_fragment$h, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CreatePlantForm",
    			options,
    			id: create_fragment$h.name
    		});
    	}
    }

    /* src\Pages\Plant\Create\CreatePlantPage.svelte generated by Svelte v3.59.2 */
    const file$f = "src\\Pages\\Plant\\Create\\CreatePlantPage.svelte";

    function create_fragment$g(ctx) {
    	let div;
    	let h1;
    	let t1;
    	let createplantform;
    	let current;
    	createplantform = new CreatePlantForm({ $$inline: true });

    	const block = {
    		c: function create() {
    			div = element("div");
    			h1 = element("h1");
    			h1.textContent = "Plant aanmaken";
    			t1 = space();
    			create_component(createplantform.$$.fragment);
    			attr_dev(h1, "class", "text-center text-2xl w-full text-gray-900");
    			add_location(h1, file$f, 7, 4, 235);
    			attr_dev(div, "class", "flex flex-col justify-center w-full");
    			add_location(div, file$f, 6, 0, 180);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, h1);
    			append_dev(div, t1);
    			mount_component(createplantform, div, null);
    			current = true;
    		},
    		p: noop$1,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(createplantform.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(createplantform.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(createplantform);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$g.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$g($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('CreatePlantPage', slots, []);
    	ensureLoggedIn();
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CreatePlantPage> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ ensureLoggedIn, CreatePlantForm });
    	return [];
    }

    class CreatePlantPage extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$g, create_fragment$g, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CreatePlantPage",
    			options,
    			id: create_fragment$g.name
    		});
    	}
    }

    /* src\Components\Loader.svelte generated by Svelte v3.59.2 */

    const file$e = "src\\Components\\Loader.svelte";

    function create_fragment$f(ctx) {
    	let svg;
    	let g1;
    	let circle0;
    	let animate0;
    	let animate1;
    	let circle1;
    	let animate2;
    	let animate3;
    	let circle2;
    	let animate4;
    	let animate5;
    	let circle3;
    	let animate6;
    	let animate7;
    	let circle4;
    	let animate8;
    	let animate9;
    	let g0;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			g1 = svg_element("g");
    			circle0 = svg_element("circle");
    			animate0 = svg_element("animate");
    			animate1 = svg_element("animate");
    			circle1 = svg_element("circle");
    			animate2 = svg_element("animate");
    			animate3 = svg_element("animate");
    			circle2 = svg_element("circle");
    			animate4 = svg_element("animate");
    			animate5 = svg_element("animate");
    			circle3 = svg_element("circle");
    			animate6 = svg_element("animate");
    			animate7 = svg_element("animate");
    			circle4 = svg_element("circle");
    			animate8 = svg_element("animate");
    			animate9 = svg_element("animate");
    			g0 = svg_element("g");
    			attr_dev(animate0, "begin", "0s");
    			attr_dev(animate0, "keySplines", "0 0.5 0.5 1");
    			attr_dev(animate0, "values", "10;0");
    			attr_dev(animate0, "keyTimes", "0;1");
    			attr_dev(animate0, "calcMode", "spline");
    			attr_dev(animate0, "dur", "0.8064516129032259s");
    			attr_dev(animate0, "repeatCount", "indefinite");
    			attr_dev(animate0, "attributeName", "r");
    			add_location(animate0, file$e, 4, 4, 360);
    			attr_dev(animate1, "begin", "0s");
    			attr_dev(animate1, "values", "#00bdf8;#0284c7;#00bdf8;#0284c7;#00bdf8");
    			attr_dev(animate1, "keyTimes", "0;0.25;0.5;0.75;1");
    			attr_dev(animate1, "calcMode", "discrete");
    			attr_dev(animate1, "dur", "3.2258064516129035s");
    			attr_dev(animate1, "repeatCount", "indefinite");
    			attr_dev(animate1, "attributeName", "fill");
    			add_location(animate1, file$e, 5, 4, 537);
    			attr_dev(circle0, "fill", "#00bdf8");
    			attr_dev(circle0, "r", "10");
    			attr_dev(circle0, "cy", "50");
    			attr_dev(circle0, "cx", "84");
    			add_location(circle0, file$e, 3, 253, 308);
    			attr_dev(animate2, "begin", "0s");
    			attr_dev(animate2, "keySplines", "0 0.5 0.5 1;0 0.5 0.5 1;0 0.5 0.5 1;0 0.5 0.5 1");
    			attr_dev(animate2, "values", "0;0;10;10;10");
    			attr_dev(animate2, "keyTimes", "0;0.25;0.5;0.75;1");
    			attr_dev(animate2, "calcMode", "spline");
    			attr_dev(animate2, "dur", "3.2258064516129035s");
    			attr_dev(animate2, "repeatCount", "indefinite");
    			attr_dev(animate2, "attributeName", "r");
    			add_location(animate2, file$e, 7, 2, 798);
    			attr_dev(animate3, "begin", "0s");
    			attr_dev(animate3, "keySplines", "0 0.5 0.5 1;0 0.5 0.5 1;0 0.5 0.5 1;0 0.5 0.5 1");
    			attr_dev(animate3, "values", "16;16;16;50;84");
    			attr_dev(animate3, "keyTimes", "0;0.25;0.5;0.75;1");
    			attr_dev(animate3, "calcMode", "spline");
    			attr_dev(animate3, "dur", "3.2258064516129035s");
    			attr_dev(animate3, "repeatCount", "indefinite");
    			attr_dev(animate3, "attributeName", "cx");
    			add_location(animate3, file$e, 8, 2, 1031);
    			attr_dev(circle1, "fill", "#00bdf8");
    			attr_dev(circle1, "r", "10");
    			attr_dev(circle1, "cy", "50");
    			attr_dev(circle1, "cx", "16");
    			add_location(circle1, file$e, 6, 9, 748);
    			attr_dev(animate4, "begin", "-0.8064516129032259s");
    			attr_dev(animate4, "keySplines", "0 0.5 0.5 1;0 0.5 0.5 1;0 0.5 0.5 1;0 0.5 0.5 1");
    			attr_dev(animate4, "values", "0;0;10;10;10");
    			attr_dev(animate4, "keyTimes", "0;0.25;0.5;0.75;1");
    			attr_dev(animate4, "calcMode", "spline");
    			attr_dev(animate4, "dur", "3.2258064516129035s");
    			attr_dev(animate4, "repeatCount", "indefinite");
    			attr_dev(animate4, "attributeName", "r");
    			add_location(animate4, file$e, 10, 2, 1324);
    			attr_dev(animate5, "begin", "-0.8064516129032259s");
    			attr_dev(animate5, "keySplines", "0 0.5 0.5 1;0 0.5 0.5 1;0 0.5 0.5 1;0 0.5 0.5 1");
    			attr_dev(animate5, "values", "16;16;16;50;84");
    			attr_dev(animate5, "keyTimes", "0;0.25;0.5;0.75;1");
    			attr_dev(animate5, "calcMode", "spline");
    			attr_dev(animate5, "dur", "3.2258064516129035s");
    			attr_dev(animate5, "repeatCount", "indefinite");
    			attr_dev(animate5, "attributeName", "cx");
    			add_location(animate5, file$e, 11, 2, 1575);
    			attr_dev(circle2, "fill", "#0284c7");
    			attr_dev(circle2, "r", "10");
    			attr_dev(circle2, "cy", "50");
    			attr_dev(circle2, "cx", "50");
    			add_location(circle2, file$e, 9, 9, 1274);
    			attr_dev(animate6, "begin", "-1.6129032258064517s");
    			attr_dev(animate6, "keySplines", "0 0.5 0.5 1;0 0.5 0.5 1;0 0.5 0.5 1;0 0.5 0.5 1");
    			attr_dev(animate6, "values", "0;0;10;10;10");
    			attr_dev(animate6, "keyTimes", "0;0.25;0.5;0.75;1");
    			attr_dev(animate6, "calcMode", "spline");
    			attr_dev(animate6, "dur", "3.2258064516129035s");
    			attr_dev(animate6, "repeatCount", "indefinite");
    			attr_dev(animate6, "attributeName", "r");
    			add_location(animate6, file$e, 13, 2, 1886);
    			attr_dev(animate7, "begin", "-1.6129032258064517s");
    			attr_dev(animate7, "keySplines", "0 0.5 0.5 1;0 0.5 0.5 1;0 0.5 0.5 1;0 0.5 0.5 1");
    			attr_dev(animate7, "values", "16;16;16;50;84");
    			attr_dev(animate7, "keyTimes", "0;0.25;0.5;0.75;1");
    			attr_dev(animate7, "calcMode", "spline");
    			attr_dev(animate7, "dur", "3.2258064516129035s");
    			attr_dev(animate7, "repeatCount", "indefinite");
    			attr_dev(animate7, "attributeName", "cx");
    			add_location(animate7, file$e, 14, 2, 2137);
    			attr_dev(circle3, "fill", "#00bdf8");
    			attr_dev(circle3, "r", "10");
    			attr_dev(circle3, "cy", "50");
    			attr_dev(circle3, "cx", "84");
    			add_location(circle3, file$e, 12, 9, 1836);
    			attr_dev(animate8, "begin", "-2.4193548387096775s");
    			attr_dev(animate8, "keySplines", "0 0.5 0.5 1;0 0.5 0.5 1;0 0.5 0.5 1;0 0.5 0.5 1");
    			attr_dev(animate8, "values", "0;0;10;10;10");
    			attr_dev(animate8, "keyTimes", "0;0.25;0.5;0.75;1");
    			attr_dev(animate8, "calcMode", "spline");
    			attr_dev(animate8, "dur", "3.2258064516129035s");
    			attr_dev(animate8, "repeatCount", "indefinite");
    			attr_dev(animate8, "attributeName", "r");
    			add_location(animate8, file$e, 16, 2, 2448);
    			attr_dev(animate9, "begin", "-2.4193548387096775s");
    			attr_dev(animate9, "keySplines", "0 0.5 0.5 1;0 0.5 0.5 1;0 0.5 0.5 1;0 0.5 0.5 1");
    			attr_dev(animate9, "values", "16;16;16;50;84");
    			attr_dev(animate9, "keyTimes", "0;0.25;0.5;0.75;1");
    			attr_dev(animate9, "calcMode", "spline");
    			attr_dev(animate9, "dur", "3.2258064516129035s");
    			attr_dev(animate9, "repeatCount", "indefinite");
    			attr_dev(animate9, "attributeName", "cx");
    			add_location(animate9, file$e, 17, 2, 2699);
    			attr_dev(circle4, "fill", "#0284c7");
    			attr_dev(circle4, "r", "10");
    			attr_dev(circle4, "cy", "50");
    			attr_dev(circle4, "cx", "16");
    			add_location(circle4, file$e, 15, 9, 2398);
    			add_location(g0, file$e, 18, 9, 2960);
    			add_location(g1, file$e, 3, 250, 305);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "viewBox", "0 0 100 100");
    			attr_dev(svg, "preserveAspectRatio", "xMidYMid");
    			attr_dev(svg, "width", /*width*/ ctx[0]);
    			attr_dev(svg, "height", /*width*/ ctx[0]);
    			set_style(svg, "shape-rendering", "auto");
    			set_style(svg, "display", "block");
    			set_style(svg, "background", "rgba(0, 189, 248, 0)");
    			attr_dev(svg, "xmlns:xlink", "http://www.w3.org/1999/xlink");
    			add_location(svg, file$e, 3, 0, 55);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, g1);
    			append_dev(g1, circle0);
    			append_dev(circle0, animate0);
    			append_dev(circle0, animate1);
    			append_dev(g1, circle1);
    			append_dev(circle1, animate2);
    			append_dev(circle1, animate3);
    			append_dev(g1, circle2);
    			append_dev(circle2, animate4);
    			append_dev(circle2, animate5);
    			append_dev(g1, circle3);
    			append_dev(circle3, animate6);
    			append_dev(circle3, animate7);
    			append_dev(g1, circle4);
    			append_dev(circle4, animate8);
    			append_dev(circle4, animate9);
    			append_dev(g1, g0);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*width*/ 1) {
    				attr_dev(svg, "width", /*width*/ ctx[0]);
    			}

    			if (dirty & /*width*/ 1) {
    				attr_dev(svg, "height", /*width*/ ctx[0]);
    			}
    		},
    		i: noop$1,
    		o: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$f.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$f($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Loader', slots, []);
    	let { width = 50 } = $$props;
    	const writable_props = ['width'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Loader> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('width' in $$props) $$invalidate(0, width = $$props.width);
    	};

    	$$self.$capture_state = () => ({ width });

    	$$self.$inject_state = $$props => {
    		if ('width' in $$props) $$invalidate(0, width = $$props.width);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [width];
    }

    class Loader extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$f, create_fragment$f, safe_not_equal, { width: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Loader",
    			options,
    			id: create_fragment$f.name
    		});
    	}

    	get width() {
    		throw new Error("<Loader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set width(value) {
    		throw new Error("<Loader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /*!
     * @kurkle/color v0.3.4
     * https://github.com/kurkle/color#readme
     * (c) 2024 Jukka Kurkela
     * Released under the MIT License
     */
    function round(v) {
      return v + 0.5 | 0;
    }
    const lim = (v, l, h) => Math.max(Math.min(v, h), l);
    function p2b(v) {
      return lim(round(v * 2.55), 0, 255);
    }
    function n2b(v) {
      return lim(round(v * 255), 0, 255);
    }
    function b2n(v) {
      return lim(round(v / 2.55) / 100, 0, 1);
    }
    function n2p(v) {
      return lim(round(v * 100), 0, 100);
    }

    const map$1$1 = {0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15};
    const hex = [...'0123456789ABCDEF'];
    const h1 = b => hex[b & 0xF];
    const h2 = b => hex[(b & 0xF0) >> 4] + hex[b & 0xF];
    const eq = b => ((b & 0xF0) >> 4) === (b & 0xF);
    const isShort = v => eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);
    function hexParse(str) {
      var len = str.length;
      var ret;
      if (str[0] === '#') {
        if (len === 4 || len === 5) {
          ret = {
            r: 255 & map$1$1[str[1]] * 17,
            g: 255 & map$1$1[str[2]] * 17,
            b: 255 & map$1$1[str[3]] * 17,
            a: len === 5 ? map$1$1[str[4]] * 17 : 255
          };
        } else if (len === 7 || len === 9) {
          ret = {
            r: map$1$1[str[1]] << 4 | map$1$1[str[2]],
            g: map$1$1[str[3]] << 4 | map$1$1[str[4]],
            b: map$1$1[str[5]] << 4 | map$1$1[str[6]],
            a: len === 9 ? (map$1$1[str[7]] << 4 | map$1$1[str[8]]) : 255
          };
        }
      }
      return ret;
    }
    const alpha = (a, f) => a < 255 ? f(a) : '';
    function hexString(v) {
      var f = isShort(v) ? h1 : h2;
      return v
        ? '#' + f(v.r) + f(v.g) + f(v.b) + alpha(v.a, f)
        : undefined;
    }

    const HUE_RE = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
    function hsl2rgbn(h, s, l) {
      const a = s * Math.min(l, 1 - l);
      const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
      return [f(0), f(8), f(4)];
    }
    function hsv2rgbn(h, s, v) {
      const f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
      return [f(5), f(3), f(1)];
    }
    function hwb2rgbn(h, w, b) {
      const rgb = hsl2rgbn(h, 1, 0.5);
      let i;
      if (w + b > 1) {
        i = 1 / (w + b);
        w *= i;
        b *= i;
      }
      for (i = 0; i < 3; i++) {
        rgb[i] *= 1 - w - b;
        rgb[i] += w;
      }
      return rgb;
    }
    function hueValue(r, g, b, d, max) {
      if (r === max) {
        return ((g - b) / d) + (g < b ? 6 : 0);
      }
      if (g === max) {
        return (b - r) / d + 2;
      }
      return (r - g) / d + 4;
    }
    function rgb2hsl(v) {
      const range = 255;
      const r = v.r / range;
      const g = v.g / range;
      const b = v.b / range;
      const max = Math.max(r, g, b);
      const min = Math.min(r, g, b);
      const l = (max + min) / 2;
      let h, s, d;
      if (max !== min) {
        d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        h = hueValue(r, g, b, d, max);
        h = h * 60 + 0.5;
      }
      return [h | 0, s || 0, l];
    }
    function calln(f, a, b, c) {
      return (
        Array.isArray(a)
          ? f(a[0], a[1], a[2])
          : f(a, b, c)
      ).map(n2b);
    }
    function hsl2rgb(h, s, l) {
      return calln(hsl2rgbn, h, s, l);
    }
    function hwb2rgb(h, w, b) {
      return calln(hwb2rgbn, h, w, b);
    }
    function hsv2rgb(h, s, v) {
      return calln(hsv2rgbn, h, s, v);
    }
    function hue(h) {
      return (h % 360 + 360) % 360;
    }
    function hueParse(str) {
      const m = HUE_RE.exec(str);
      let a = 255;
      let v;
      if (!m) {
        return;
      }
      if (m[5] !== v) {
        a = m[6] ? p2b(+m[5]) : n2b(+m[5]);
      }
      const h = hue(+m[2]);
      const p1 = +m[3] / 100;
      const p2 = +m[4] / 100;
      if (m[1] === 'hwb') {
        v = hwb2rgb(h, p1, p2);
      } else if (m[1] === 'hsv') {
        v = hsv2rgb(h, p1, p2);
      } else {
        v = hsl2rgb(h, p1, p2);
      }
      return {
        r: v[0],
        g: v[1],
        b: v[2],
        a: a
      };
    }
    function rotate(v, deg) {
      var h = rgb2hsl(v);
      h[0] = hue(h[0] + deg);
      h = hsl2rgb(h);
      v.r = h[0];
      v.g = h[1];
      v.b = h[2];
    }
    function hslString(v) {
      if (!v) {
        return;
      }
      const a = rgb2hsl(v);
      const h = a[0];
      const s = n2p(a[1]);
      const l = n2p(a[2]);
      return v.a < 255
        ? `hsla(${h}, ${s}%, ${l}%, ${b2n(v.a)})`
        : `hsl(${h}, ${s}%, ${l}%)`;
    }

    const map$2 = {
    	x: 'dark',
    	Z: 'light',
    	Y: 're',
    	X: 'blu',
    	W: 'gr',
    	V: 'medium',
    	U: 'slate',
    	A: 'ee',
    	T: 'ol',
    	S: 'or',
    	B: 'ra',
    	C: 'lateg',
    	D: 'ights',
    	R: 'in',
    	Q: 'turquois',
    	E: 'hi',
    	P: 'ro',
    	O: 'al',
    	N: 'le',
    	M: 'de',
    	L: 'yello',
    	F: 'en',
    	K: 'ch',
    	G: 'arks',
    	H: 'ea',
    	I: 'ightg',
    	J: 'wh'
    };
    const names$1 = {
    	OiceXe: 'f0f8ff',
    	antiquewEte: 'faebd7',
    	aqua: 'ffff',
    	aquamarRe: '7fffd4',
    	azuY: 'f0ffff',
    	beige: 'f5f5dc',
    	bisque: 'ffe4c4',
    	black: '0',
    	blanKedOmond: 'ffebcd',
    	Xe: 'ff',
    	XeviTet: '8a2be2',
    	bPwn: 'a52a2a',
    	burlywood: 'deb887',
    	caMtXe: '5f9ea0',
    	KartYuse: '7fff00',
    	KocTate: 'd2691e',
    	cSO: 'ff7f50',
    	cSnflowerXe: '6495ed',
    	cSnsilk: 'fff8dc',
    	crimson: 'dc143c',
    	cyan: 'ffff',
    	xXe: '8b',
    	xcyan: '8b8b',
    	xgTMnPd: 'b8860b',
    	xWay: 'a9a9a9',
    	xgYF: '6400',
    	xgYy: 'a9a9a9',
    	xkhaki: 'bdb76b',
    	xmagFta: '8b008b',
    	xTivegYF: '556b2f',
    	xSange: 'ff8c00',
    	xScEd: '9932cc',
    	xYd: '8b0000',
    	xsOmon: 'e9967a',
    	xsHgYF: '8fbc8f',
    	xUXe: '483d8b',
    	xUWay: '2f4f4f',
    	xUgYy: '2f4f4f',
    	xQe: 'ced1',
    	xviTet: '9400d3',
    	dAppRk: 'ff1493',
    	dApskyXe: 'bfff',
    	dimWay: '696969',
    	dimgYy: '696969',
    	dodgerXe: '1e90ff',
    	fiYbrick: 'b22222',
    	flSOwEte: 'fffaf0',
    	foYstWAn: '228b22',
    	fuKsia: 'ff00ff',
    	gaRsbSo: 'dcdcdc',
    	ghostwEte: 'f8f8ff',
    	gTd: 'ffd700',
    	gTMnPd: 'daa520',
    	Way: '808080',
    	gYF: '8000',
    	gYFLw: 'adff2f',
    	gYy: '808080',
    	honeyMw: 'f0fff0',
    	hotpRk: 'ff69b4',
    	RdianYd: 'cd5c5c',
    	Rdigo: '4b0082',
    	ivSy: 'fffff0',
    	khaki: 'f0e68c',
    	lavFMr: 'e6e6fa',
    	lavFMrXsh: 'fff0f5',
    	lawngYF: '7cfc00',
    	NmoncEffon: 'fffacd',
    	ZXe: 'add8e6',
    	ZcSO: 'f08080',
    	Zcyan: 'e0ffff',
    	ZgTMnPdLw: 'fafad2',
    	ZWay: 'd3d3d3',
    	ZgYF: '90ee90',
    	ZgYy: 'd3d3d3',
    	ZpRk: 'ffb6c1',
    	ZsOmon: 'ffa07a',
    	ZsHgYF: '20b2aa',
    	ZskyXe: '87cefa',
    	ZUWay: '778899',
    	ZUgYy: '778899',
    	ZstAlXe: 'b0c4de',
    	ZLw: 'ffffe0',
    	lime: 'ff00',
    	limegYF: '32cd32',
    	lRF: 'faf0e6',
    	magFta: 'ff00ff',
    	maPon: '800000',
    	VaquamarRe: '66cdaa',
    	VXe: 'cd',
    	VScEd: 'ba55d3',
    	VpurpN: '9370db',
    	VsHgYF: '3cb371',
    	VUXe: '7b68ee',
    	VsprRggYF: 'fa9a',
    	VQe: '48d1cc',
    	VviTetYd: 'c71585',
    	midnightXe: '191970',
    	mRtcYam: 'f5fffa',
    	mistyPse: 'ffe4e1',
    	moccasR: 'ffe4b5',
    	navajowEte: 'ffdead',
    	navy: '80',
    	Tdlace: 'fdf5e6',
    	Tive: '808000',
    	TivedBb: '6b8e23',
    	Sange: 'ffa500',
    	SangeYd: 'ff4500',
    	ScEd: 'da70d6',
    	pOegTMnPd: 'eee8aa',
    	pOegYF: '98fb98',
    	pOeQe: 'afeeee',
    	pOeviTetYd: 'db7093',
    	papayawEp: 'ffefd5',
    	pHKpuff: 'ffdab9',
    	peru: 'cd853f',
    	pRk: 'ffc0cb',
    	plum: 'dda0dd',
    	powMrXe: 'b0e0e6',
    	purpN: '800080',
    	YbeccapurpN: '663399',
    	Yd: 'ff0000',
    	Psybrown: 'bc8f8f',
    	PyOXe: '4169e1',
    	saddNbPwn: '8b4513',
    	sOmon: 'fa8072',
    	sandybPwn: 'f4a460',
    	sHgYF: '2e8b57',
    	sHshell: 'fff5ee',
    	siFna: 'a0522d',
    	silver: 'c0c0c0',
    	skyXe: '87ceeb',
    	UXe: '6a5acd',
    	UWay: '708090',
    	UgYy: '708090',
    	snow: 'fffafa',
    	sprRggYF: 'ff7f',
    	stAlXe: '4682b4',
    	tan: 'd2b48c',
    	teO: '8080',
    	tEstN: 'd8bfd8',
    	tomato: 'ff6347',
    	Qe: '40e0d0',
    	viTet: 'ee82ee',
    	JHt: 'f5deb3',
    	wEte: 'ffffff',
    	wEtesmoke: 'f5f5f5',
    	Lw: 'ffff00',
    	LwgYF: '9acd32'
    };
    function unpack() {
      const unpacked = {};
      const keys = Object.keys(names$1);
      const tkeys = Object.keys(map$2);
      let i, j, k, ok, nk;
      for (i = 0; i < keys.length; i++) {
        ok = nk = keys[i];
        for (j = 0; j < tkeys.length; j++) {
          k = tkeys[j];
          nk = nk.replace(k, map$2[k]);
        }
        k = parseInt(names$1[ok], 16);
        unpacked[nk] = [k >> 16 & 0xFF, k >> 8 & 0xFF, k & 0xFF];
      }
      return unpacked;
    }

    let names;
    function nameParse(str) {
      if (!names) {
        names = unpack();
        names.transparent = [0, 0, 0, 0];
      }
      const a = names[str.toLowerCase()];
      return a && {
        r: a[0],
        g: a[1],
        b: a[2],
        a: a.length === 4 ? a[3] : 255
      };
    }

    const RGB_RE = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
    function rgbParse(str) {
      const m = RGB_RE.exec(str);
      let a = 255;
      let r, g, b;
      if (!m) {
        return;
      }
      if (m[7] !== r) {
        const v = +m[7];
        a = m[8] ? p2b(v) : lim(v * 255, 0, 255);
      }
      r = +m[1];
      g = +m[3];
      b = +m[5];
      r = 255 & (m[2] ? p2b(r) : lim(r, 0, 255));
      g = 255 & (m[4] ? p2b(g) : lim(g, 0, 255));
      b = 255 & (m[6] ? p2b(b) : lim(b, 0, 255));
      return {
        r: r,
        g: g,
        b: b,
        a: a
      };
    }
    function rgbString(v) {
      return v && (
        v.a < 255
          ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})`
          : `rgb(${v.r}, ${v.g}, ${v.b})`
      );
    }

    const to = v => v <= 0.0031308 ? v * 12.92 : Math.pow(v, 1.0 / 2.4) * 1.055 - 0.055;
    const from = v => v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);
    function interpolate$1(rgb1, rgb2, t) {
      const r = from(b2n(rgb1.r));
      const g = from(b2n(rgb1.g));
      const b = from(b2n(rgb1.b));
      return {
        r: n2b(to(r + t * (from(b2n(rgb2.r)) - r))),
        g: n2b(to(g + t * (from(b2n(rgb2.g)) - g))),
        b: n2b(to(b + t * (from(b2n(rgb2.b)) - b))),
        a: rgb1.a + t * (rgb2.a - rgb1.a)
      };
    }

    function modHSL(v, i, ratio) {
      if (v) {
        let tmp = rgb2hsl(v);
        tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));
        tmp = hsl2rgb(tmp);
        v.r = tmp[0];
        v.g = tmp[1];
        v.b = tmp[2];
      }
    }
    function clone$1(v, proto) {
      return v ? Object.assign(proto || {}, v) : v;
    }
    function fromObject(input) {
      var v = {r: 0, g: 0, b: 0, a: 255};
      if (Array.isArray(input)) {
        if (input.length >= 3) {
          v = {r: input[0], g: input[1], b: input[2], a: 255};
          if (input.length > 3) {
            v.a = n2b(input[3]);
          }
        }
      } else {
        v = clone$1(input, {r: 0, g: 0, b: 0, a: 1});
        v.a = n2b(v.a);
      }
      return v;
    }
    function functionParse(str) {
      if (str.charAt(0) === 'r') {
        return rgbParse(str);
      }
      return hueParse(str);
    }
    class Color {
      constructor(input) {
        if (input instanceof Color) {
          return input;
        }
        const type = typeof input;
        let v;
        if (type === 'object') {
          v = fromObject(input);
        } else if (type === 'string') {
          v = hexParse(input) || nameParse(input) || functionParse(input);
        }
        this._rgb = v;
        this._valid = !!v;
      }
      get valid() {
        return this._valid;
      }
      get rgb() {
        var v = clone$1(this._rgb);
        if (v) {
          v.a = b2n(v.a);
        }
        return v;
      }
      set rgb(obj) {
        this._rgb = fromObject(obj);
      }
      rgbString() {
        return this._valid ? rgbString(this._rgb) : undefined;
      }
      hexString() {
        return this._valid ? hexString(this._rgb) : undefined;
      }
      hslString() {
        return this._valid ? hslString(this._rgb) : undefined;
      }
      mix(color, weight) {
        if (color) {
          const c1 = this.rgb;
          const c2 = color.rgb;
          let w2;
          const p = weight === w2 ? 0.5 : weight;
          const w = 2 * p - 1;
          const a = c1.a - c2.a;
          const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;
          w2 = 1 - w1;
          c1.r = 0xFF & w1 * c1.r + w2 * c2.r + 0.5;
          c1.g = 0xFF & w1 * c1.g + w2 * c2.g + 0.5;
          c1.b = 0xFF & w1 * c1.b + w2 * c2.b + 0.5;
          c1.a = p * c1.a + (1 - p) * c2.a;
          this.rgb = c1;
        }
        return this;
      }
      interpolate(color, t) {
        if (color) {
          this._rgb = interpolate$1(this._rgb, color._rgb, t);
        }
        return this;
      }
      clone() {
        return new Color(this.rgb);
      }
      alpha(a) {
        this._rgb.a = n2b(a);
        return this;
      }
      clearer(ratio) {
        const rgb = this._rgb;
        rgb.a *= 1 - ratio;
        return this;
      }
      greyscale() {
        const rgb = this._rgb;
        const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);
        rgb.r = rgb.g = rgb.b = val;
        return this;
      }
      opaquer(ratio) {
        const rgb = this._rgb;
        rgb.a *= 1 + ratio;
        return this;
      }
      negate() {
        const v = this._rgb;
        v.r = 255 - v.r;
        v.g = 255 - v.g;
        v.b = 255 - v.b;
        return this;
      }
      lighten(ratio) {
        modHSL(this._rgb, 2, ratio);
        return this;
      }
      darken(ratio) {
        modHSL(this._rgb, 2, -ratio);
        return this;
      }
      saturate(ratio) {
        modHSL(this._rgb, 1, ratio);
        return this;
      }
      desaturate(ratio) {
        modHSL(this._rgb, 1, -ratio);
        return this;
      }
      rotate(deg) {
        rotate(this._rgb, deg);
        return this;
      }
    }

    /*!
     * Chart.js v4.4.7
     * https://www.chartjs.org
     * (c) 2024 Chart.js Contributors
     * Released under the MIT License
     */

    /**
     * @namespace Chart.helpers
     */ /**
     * An empty function that can be used, for example, for optional callback.
     */ function noop() {
    /* noop */ }
    /**
     * Returns a unique id, sequentially generated from a global variable.
     */ const uid = (()=>{
        let id = 0;
        return ()=>id++;
    })();
    /**
     * Returns true if `value` is neither null nor undefined, else returns false.
     * @param value - The value to test.
     * @since 2.7.0
     */ function isNullOrUndef(value) {
        return value === null || value === undefined;
    }
    /**
     * Returns true if `value` is an array (including typed arrays), else returns false.
     * @param value - The value to test.
     * @function
     */ function isArray$1(value) {
        if (Array.isArray && Array.isArray(value)) {
            return true;
        }
        const type = Object.prototype.toString.call(value);
        if (type.slice(0, 7) === '[object' && type.slice(-6) === 'Array]') {
            return true;
        }
        return false;
    }
    /**
     * Returns true if `value` is an object (excluding null), else returns false.
     * @param value - The value to test.
     * @since 2.7.0
     */ function isObject$1(value) {
        return value !== null && Object.prototype.toString.call(value) === '[object Object]';
    }
    /**
     * Returns true if `value` is a finite number, else returns false
     * @param value  - The value to test.
     */ function isNumberFinite(value) {
        return (typeof value === 'number' || value instanceof Number) && isFinite(+value);
    }
    /**
     * Returns `value` if finite, else returns `defaultValue`.
     * @param value - The value to return if defined.
     * @param defaultValue - The value to return if `value` is not finite.
     */ function finiteOrDefault(value, defaultValue) {
        return isNumberFinite(value) ? value : defaultValue;
    }
    /**
     * Returns `value` if defined, else returns `defaultValue`.
     * @param value - The value to return if defined.
     * @param defaultValue - The value to return if `value` is undefined.
     */ function valueOrDefault(value, defaultValue) {
        return typeof value === 'undefined' ? defaultValue : value;
    }
    const toPercentage = (value, dimension)=>typeof value === 'string' && value.endsWith('%') ? parseFloat(value) / 100 : +value / dimension;
    const toDimension = (value, dimension)=>typeof value === 'string' && value.endsWith('%') ? parseFloat(value) / 100 * dimension : +value;
    /**
     * Calls `fn` with the given `args` in the scope defined by `thisArg` and returns the
     * value returned by `fn`. If `fn` is not a function, this method returns undefined.
     * @param fn - The function to call.
     * @param args - The arguments with which `fn` should be called.
     * @param [thisArg] - The value of `this` provided for the call to `fn`.
     */ function callback(fn, args, thisArg) {
        if (fn && typeof fn.call === 'function') {
            return fn.apply(thisArg, args);
        }
    }
    function each(loopable, fn, thisArg, reverse) {
        let i, len, keys;
        if (isArray$1(loopable)) {
            len = loopable.length;
            if (reverse) {
                for(i = len - 1; i >= 0; i--){
                    fn.call(thisArg, loopable[i], i);
                }
            } else {
                for(i = 0; i < len; i++){
                    fn.call(thisArg, loopable[i], i);
                }
            }
        } else if (isObject$1(loopable)) {
            keys = Object.keys(loopable);
            len = keys.length;
            for(i = 0; i < len; i++){
                fn.call(thisArg, loopable[keys[i]], keys[i]);
            }
        }
    }
    /**
     * Returns true if the `a0` and `a1` arrays have the same content, else returns false.
     * @param a0 - The array to compare
     * @param a1 - The array to compare
     * @private
     */ function _elementsEqual(a0, a1) {
        let i, ilen, v0, v1;
        if (!a0 || !a1 || a0.length !== a1.length) {
            return false;
        }
        for(i = 0, ilen = a0.length; i < ilen; ++i){
            v0 = a0[i];
            v1 = a1[i];
            if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {
                return false;
            }
        }
        return true;
    }
    /**
     * Returns a deep copy of `source` without keeping references on objects and arrays.
     * @param source - The value to clone.
     */ function clone(source) {
        if (isArray$1(source)) {
            return source.map(clone);
        }
        if (isObject$1(source)) {
            const target = Object.create(null);
            const keys = Object.keys(source);
            const klen = keys.length;
            let k = 0;
            for(; k < klen; ++k){
                target[keys[k]] = clone(source[keys[k]]);
            }
            return target;
        }
        return source;
    }
    function isValidKey(key) {
        return [
            '__proto__',
            'prototype',
            'constructor'
        ].indexOf(key) === -1;
    }
    /**
     * The default merger when Chart.helpers.merge is called without merger option.
     * Note(SB): also used by mergeConfig and mergeScaleConfig as fallback.
     * @private
     */ function _merger(key, target, source, options) {
        if (!isValidKey(key)) {
            return;
        }
        const tval = target[key];
        const sval = source[key];
        if (isObject$1(tval) && isObject$1(sval)) {
            // eslint-disable-next-line @typescript-eslint/no-use-before-define
            merge(tval, sval, options);
        } else {
            target[key] = clone(sval);
        }
    }
    function merge(target, source, options) {
        const sources = isArray$1(source) ? source : [
            source
        ];
        const ilen = sources.length;
        if (!isObject$1(target)) {
            return target;
        }
        options = options || {};
        const merger = options.merger || _merger;
        let current;
        for(let i = 0; i < ilen; ++i){
            current = sources[i];
            if (!isObject$1(current)) {
                continue;
            }
            const keys = Object.keys(current);
            for(let k = 0, klen = keys.length; k < klen; ++k){
                merger(keys[k], target, current, options);
            }
        }
        return target;
    }
    function mergeIf(target, source) {
        // eslint-disable-next-line @typescript-eslint/no-use-before-define
        return merge(target, source, {
            merger: _mergerIf
        });
    }
    /**
     * Merges source[key] in target[key] only if target[key] is undefined.
     * @private
     */ function _mergerIf(key, target, source) {
        if (!isValidKey(key)) {
            return;
        }
        const tval = target[key];
        const sval = source[key];
        if (isObject$1(tval) && isObject$1(sval)) {
            mergeIf(tval, sval);
        } else if (!Object.prototype.hasOwnProperty.call(target, key)) {
            target[key] = clone(sval);
        }
    }
    // resolveObjectKey resolver cache
    const keyResolvers = {
        // Chart.helpers.core resolveObjectKey should resolve empty key to root object
        '': (v)=>v,
        // default resolvers
        x: (o)=>o.x,
        y: (o)=>o.y
    };
    /**
     * @private
     */ function _splitKey(key) {
        const parts = key.split('.');
        const keys = [];
        let tmp = '';
        for (const part of parts){
            tmp += part;
            if (tmp.endsWith('\\')) {
                tmp = tmp.slice(0, -1) + '.';
            } else {
                keys.push(tmp);
                tmp = '';
            }
        }
        return keys;
    }
    function _getKeyResolver(key) {
        const keys = _splitKey(key);
        return (obj)=>{
            for (const k of keys){
                if (k === '') {
                    break;
                }
                obj = obj && obj[k];
            }
            return obj;
        };
    }
    function resolveObjectKey(obj, key) {
        const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));
        return resolver(obj);
    }
    /**
     * @private
     */ function _capitalize(str) {
        return str.charAt(0).toUpperCase() + str.slice(1);
    }
    const defined = (value)=>typeof value !== 'undefined';
    const isFunction$1 = (value)=>typeof value === 'function';
    // Adapted from https://stackoverflow.com/questions/31128855/comparing-ecma6-sets-for-equality#31129384
    const setsEqual = (a, b)=>{
        if (a.size !== b.size) {
            return false;
        }
        for (const item of a){
            if (!b.has(item)) {
                return false;
            }
        }
        return true;
    };
    /**
     * @param e - The event
     * @private
     */ function _isClickEvent(e) {
        return e.type === 'mouseup' || e.type === 'click' || e.type === 'contextmenu';
    }

    /**
     * @alias Chart.helpers.math
     * @namespace
     */ const PI = Math.PI;
    const TAU = 2 * PI;
    const PITAU = TAU + PI;
    const INFINITY = Number.POSITIVE_INFINITY;
    const RAD_PER_DEG = PI / 180;
    const HALF_PI = PI / 2;
    const QUARTER_PI = PI / 4;
    const TWO_THIRDS_PI = PI * 2 / 3;
    const log10 = Math.log10;
    const sign = Math.sign;
    function almostEquals(x, y, epsilon) {
        return Math.abs(x - y) < epsilon;
    }
    /**
     * Implementation of the nice number algorithm used in determining where axis labels will go
     */ function niceNum(range) {
        const roundedRange = Math.round(range);
        range = almostEquals(range, roundedRange, range / 1000) ? roundedRange : range;
        const niceRange = Math.pow(10, Math.floor(log10(range)));
        const fraction = range / niceRange;
        const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;
        return niceFraction * niceRange;
    }
    /**
     * Returns an array of factors sorted from 1 to sqrt(value)
     * @private
     */ function _factorize(value) {
        const result = [];
        const sqrt = Math.sqrt(value);
        let i;
        for(i = 1; i < sqrt; i++){
            if (value % i === 0) {
                result.push(i);
                result.push(value / i);
            }
        }
        if (sqrt === (sqrt | 0)) {
            result.push(sqrt);
        }
        result.sort((a, b)=>a - b).pop();
        return result;
    }
    function isNumber(n) {
        return !isNaN(parseFloat(n)) && isFinite(n);
    }
    function almostWhole(x, epsilon) {
        const rounded = Math.round(x);
        return rounded - epsilon <= x && rounded + epsilon >= x;
    }
    /**
     * @private
     */ function _setMinAndMaxByKey(array, target, property) {
        let i, ilen, value;
        for(i = 0, ilen = array.length; i < ilen; i++){
            value = array[i][property];
            if (!isNaN(value)) {
                target.min = Math.min(target.min, value);
                target.max = Math.max(target.max, value);
            }
        }
    }
    function toRadians(degrees) {
        return degrees * (PI / 180);
    }
    function toDegrees(radians) {
        return radians * (180 / PI);
    }
    /**
     * Returns the number of decimal places
     * i.e. the number of digits after the decimal point, of the value of this Number.
     * @param x - A number.
     * @returns The number of decimal places.
     * @private
     */ function _decimalPlaces(x) {
        if (!isNumberFinite(x)) {
            return;
        }
        let e = 1;
        let p = 0;
        while(Math.round(x * e) / e !== x){
            e *= 10;
            p++;
        }
        return p;
    }
    // Gets the angle from vertical upright to the point about a centre.
    function getAngleFromPoint(centrePoint, anglePoint) {
        const distanceFromXCenter = anglePoint.x - centrePoint.x;
        const distanceFromYCenter = anglePoint.y - centrePoint.y;
        const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
        let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
        if (angle < -0.5 * PI) {
            angle += TAU; // make sure the returned angle is in the range of (-PI/2, 3PI/2]
        }
        return {
            angle,
            distance: radialDistanceFromCenter
        };
    }
    function distanceBetweenPoints(pt1, pt2) {
        return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
    }
    /**
     * Shortest distance between angles, in either direction.
     * @private
     */ function _angleDiff(a, b) {
        return (a - b + PITAU) % TAU - PI;
    }
    /**
     * Normalize angle to be between 0 and 2*PI
     * @private
     */ function _normalizeAngle(a) {
        return (a % TAU + TAU) % TAU;
    }
    /**
     * @private
     */ function _angleBetween(angle, start, end, sameAngleIsFullCircle) {
        const a = _normalizeAngle(angle);
        const s = _normalizeAngle(start);
        const e = _normalizeAngle(end);
        const angleToStart = _normalizeAngle(s - a);
        const angleToEnd = _normalizeAngle(e - a);
        const startToAngle = _normalizeAngle(a - s);
        const endToAngle = _normalizeAngle(a - e);
        return a === s || a === e || sameAngleIsFullCircle && s === e || angleToStart > angleToEnd && startToAngle < endToAngle;
    }
    /**
     * Limit `value` between `min` and `max`
     * @param value
     * @param min
     * @param max
     * @private
     */ function _limitValue(value, min, max) {
        return Math.max(min, Math.min(max, value));
    }
    /**
     * @param {number} value
     * @private
     */ function _int16Range(value) {
        return _limitValue(value, -32768, 32767);
    }
    /**
     * @param value
     * @param start
     * @param end
     * @param [epsilon]
     * @private
     */ function _isBetween(value, start, end, epsilon = 1e-6) {
        return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;
    }

    function _lookup(table, value, cmp) {
        cmp = cmp || ((index)=>table[index] < value);
        let hi = table.length - 1;
        let lo = 0;
        let mid;
        while(hi - lo > 1){
            mid = lo + hi >> 1;
            if (cmp(mid)) {
                lo = mid;
            } else {
                hi = mid;
            }
        }
        return {
            lo,
            hi
        };
    }
    /**
     * Binary search
     * @param table - the table search. must be sorted!
     * @param key - property name for the value in each entry
     * @param value - value to find
     * @param last - lookup last index
     * @private
     */ const _lookupByKey = (table, key, value, last)=>_lookup(table, value, last ? (index)=>{
            const ti = table[index][key];
            return ti < value || ti === value && table[index + 1][key] === value;
        } : (index)=>table[index][key] < value);
    /**
     * Reverse binary search
     * @param table - the table search. must be sorted!
     * @param key - property name for the value in each entry
     * @param value - value to find
     * @private
     */ const _rlookupByKey = (table, key, value)=>_lookup(table, value, (index)=>table[index][key] >= value);
    /**
     * Return subset of `values` between `min` and `max` inclusive.
     * Values are assumed to be in sorted order.
     * @param values - sorted array of values
     * @param min - min value
     * @param max - max value
     */ function _filterBetween(values, min, max) {
        let start = 0;
        let end = values.length;
        while(start < end && values[start] < min){
            start++;
        }
        while(end > start && values[end - 1] > max){
            end--;
        }
        return start > 0 || end < values.length ? values.slice(start, end) : values;
    }
    const arrayEvents = [
        'push',
        'pop',
        'shift',
        'splice',
        'unshift'
    ];
    function listenArrayEvents(array, listener) {
        if (array._chartjs) {
            array._chartjs.listeners.push(listener);
            return;
        }
        Object.defineProperty(array, '_chartjs', {
            configurable: true,
            enumerable: false,
            value: {
                listeners: [
                    listener
                ]
            }
        });
        arrayEvents.forEach((key)=>{
            const method = '_onData' + _capitalize(key);
            const base = array[key];
            Object.defineProperty(array, key, {
                configurable: true,
                enumerable: false,
                value (...args) {
                    const res = base.apply(this, args);
                    array._chartjs.listeners.forEach((object)=>{
                        if (typeof object[method] === 'function') {
                            object[method](...args);
                        }
                    });
                    return res;
                }
            });
        });
    }
    function unlistenArrayEvents(array, listener) {
        const stub = array._chartjs;
        if (!stub) {
            return;
        }
        const listeners = stub.listeners;
        const index = listeners.indexOf(listener);
        if (index !== -1) {
            listeners.splice(index, 1);
        }
        if (listeners.length > 0) {
            return;
        }
        arrayEvents.forEach((key)=>{
            delete array[key];
        });
        delete array._chartjs;
    }
    /**
     * @param items
     */ function _arrayUnique(items) {
        const set = new Set(items);
        if (set.size === items.length) {
            return items;
        }
        return Array.from(set);
    }
    /**
    * Request animation polyfill
    */ const requestAnimFrame = function() {
        if (typeof window === 'undefined') {
            return function(callback) {
                return callback();
            };
        }
        return window.requestAnimationFrame;
    }();
    /**
     * Throttles calling `fn` once per animation frame
     * Latest arguments are used on the actual call
     */ function throttled(fn, thisArg) {
        let argsToUse = [];
        let ticking = false;
        return function(...args) {
            // Save the args for use later
            argsToUse = args;
            if (!ticking) {
                ticking = true;
                requestAnimFrame.call(window, ()=>{
                    ticking = false;
                    fn.apply(thisArg, argsToUse);
                });
            }
        };
    }
    /**
     * Debounces calling `fn` for `delay` ms
     */ function debounce(fn, delay) {
        let timeout;
        return function(...args) {
            if (delay) {
                clearTimeout(timeout);
                timeout = setTimeout(fn, delay, args);
            } else {
                fn.apply(this, args);
            }
            return delay;
        };
    }
    /**
     * Converts 'start' to 'left', 'end' to 'right' and others to 'center'
     * @private
     */ const _toLeftRightCenter = (align)=>align === 'start' ? 'left' : align === 'end' ? 'right' : 'center';
    /**
     * Returns `start`, `end` or `(start + end) / 2` depending on `align`. Defaults to `center`
     * @private
     */ const _alignStartEnd = (align, start, end)=>align === 'start' ? start : align === 'end' ? end : (start + end) / 2;
    /**
     * Returns `left`, `right` or `(left + right) / 2` depending on `align`. Defaults to `left`
     * @private
     */ const _textX = (align, left, right, rtl)=>{
        const check = rtl ? 'left' : 'right';
        return align === check ? right : align === 'center' ? (left + right) / 2 : left;
    };
    /**
     * Return start and count of visible points.
     * @private
     */ function _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {
        const pointCount = points.length;
        let start = 0;
        let count = pointCount;
        if (meta._sorted) {
            const { iScale , _parsed  } = meta;
            const axis = iScale.axis;
            const { min , max , minDefined , maxDefined  } = iScale.getUserBounds();
            if (minDefined) {
                start = _limitValue(Math.min(// @ts-expect-error Need to type _parsed
                _lookupByKey(_parsed, axis, min).lo, // @ts-expect-error Need to fix types on _lookupByKey
                animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo), 0, pointCount - 1);
            }
            if (maxDefined) {
                count = _limitValue(Math.max(// @ts-expect-error Need to type _parsed
                _lookupByKey(_parsed, iScale.axis, max, true).hi + 1, // @ts-expect-error Need to fix types on _lookupByKey
                animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max), true).hi + 1), start, pointCount) - start;
            } else {
                count = pointCount - start;
            }
        }
        return {
            start,
            count
        };
    }
    /**
     * Checks if the scale ranges have changed.
     * @param {object} meta - dataset meta.
     * @returns {boolean}
     * @private
     */ function _scaleRangesChanged(meta) {
        const { xScale , yScale , _scaleRanges  } = meta;
        const newRanges = {
            xmin: xScale.min,
            xmax: xScale.max,
            ymin: yScale.min,
            ymax: yScale.max
        };
        if (!_scaleRanges) {
            meta._scaleRanges = newRanges;
            return true;
        }
        const changed = _scaleRanges.xmin !== xScale.min || _scaleRanges.xmax !== xScale.max || _scaleRanges.ymin !== yScale.min || _scaleRanges.ymax !== yScale.max;
        Object.assign(_scaleRanges, newRanges);
        return changed;
    }

    const atEdge = (t)=>t === 0 || t === 1;
    const elasticIn = (t, s, p)=>-(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));
    const elasticOut = (t, s, p)=>Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;
    /**
     * Easing functions adapted from Robert Penner's easing equations.
     * @namespace Chart.helpers.easing.effects
     * @see http://www.robertpenner.com/easing/
     */ const effects = {
        linear: (t)=>t,
        easeInQuad: (t)=>t * t,
        easeOutQuad: (t)=>-t * (t - 2),
        easeInOutQuad: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1),
        easeInCubic: (t)=>t * t * t,
        easeOutCubic: (t)=>(t -= 1) * t * t + 1,
        easeInOutCubic: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2),
        easeInQuart: (t)=>t * t * t * t,
        easeOutQuart: (t)=>-((t -= 1) * t * t * t - 1),
        easeInOutQuart: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2),
        easeInQuint: (t)=>t * t * t * t * t,
        easeOutQuint: (t)=>(t -= 1) * t * t * t * t + 1,
        easeInOutQuint: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2),
        easeInSine: (t)=>-Math.cos(t * HALF_PI) + 1,
        easeOutSine: (t)=>Math.sin(t * HALF_PI),
        easeInOutSine: (t)=>-0.5 * (Math.cos(PI * t) - 1),
        easeInExpo: (t)=>t === 0 ? 0 : Math.pow(2, 10 * (t - 1)),
        easeOutExpo: (t)=>t === 1 ? 1 : -Math.pow(2, -10 * t) + 1,
        easeInOutExpo: (t)=>atEdge(t) ? t : t < 0.5 ? 0.5 * Math.pow(2, 10 * (t * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),
        easeInCirc: (t)=>t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1),
        easeOutCirc: (t)=>Math.sqrt(1 - (t -= 1) * t),
        easeInOutCirc: (t)=>(t /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),
        easeInElastic: (t)=>atEdge(t) ? t : elasticIn(t, 0.075, 0.3),
        easeOutElastic: (t)=>atEdge(t) ? t : elasticOut(t, 0.075, 0.3),
        easeInOutElastic (t) {
            const s = 0.1125;
            const p = 0.45;
            return atEdge(t) ? t : t < 0.5 ? 0.5 * elasticIn(t * 2, s, p) : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);
        },
        easeInBack (t) {
            const s = 1.70158;
            return t * t * ((s + 1) * t - s);
        },
        easeOutBack (t) {
            const s = 1.70158;
            return (t -= 1) * t * ((s + 1) * t + s) + 1;
        },
        easeInOutBack (t) {
            let s = 1.70158;
            if ((t /= 0.5) < 1) {
                return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));
            }
            return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);
        },
        easeInBounce: (t)=>1 - effects.easeOutBounce(1 - t),
        easeOutBounce (t) {
            const m = 7.5625;
            const d = 2.75;
            if (t < 1 / d) {
                return m * t * t;
            }
            if (t < 2 / d) {
                return m * (t -= 1.5 / d) * t + 0.75;
            }
            if (t < 2.5 / d) {
                return m * (t -= 2.25 / d) * t + 0.9375;
            }
            return m * (t -= 2.625 / d) * t + 0.984375;
        },
        easeInOutBounce: (t)=>t < 0.5 ? effects.easeInBounce(t * 2) * 0.5 : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5
    };

    function isPatternOrGradient(value) {
        if (value && typeof value === 'object') {
            const type = value.toString();
            return type === '[object CanvasPattern]' || type === '[object CanvasGradient]';
        }
        return false;
    }
    function color(value) {
        return isPatternOrGradient(value) ? value : new Color(value);
    }
    function getHoverColor(value) {
        return isPatternOrGradient(value) ? value : new Color(value).saturate(0.5).darken(0.1).hexString();
    }

    const numbers = [
        'x',
        'y',
        'borderWidth',
        'radius',
        'tension'
    ];
    const colors = [
        'color',
        'borderColor',
        'backgroundColor'
    ];
    function applyAnimationsDefaults(defaults) {
        defaults.set('animation', {
            delay: undefined,
            duration: 1000,
            easing: 'easeOutQuart',
            fn: undefined,
            from: undefined,
            loop: undefined,
            to: undefined,
            type: undefined
        });
        defaults.describe('animation', {
            _fallback: false,
            _indexable: false,
            _scriptable: (name)=>name !== 'onProgress' && name !== 'onComplete' && name !== 'fn'
        });
        defaults.set('animations', {
            colors: {
                type: 'color',
                properties: colors
            },
            numbers: {
                type: 'number',
                properties: numbers
            }
        });
        defaults.describe('animations', {
            _fallback: 'animation'
        });
        defaults.set('transitions', {
            active: {
                animation: {
                    duration: 400
                }
            },
            resize: {
                animation: {
                    duration: 0
                }
            },
            show: {
                animations: {
                    colors: {
                        from: 'transparent'
                    },
                    visible: {
                        type: 'boolean',
                        duration: 0
                    }
                }
            },
            hide: {
                animations: {
                    colors: {
                        to: 'transparent'
                    },
                    visible: {
                        type: 'boolean',
                        easing: 'linear',
                        fn: (v)=>v | 0
                    }
                }
            }
        });
    }

    function applyLayoutsDefaults(defaults) {
        defaults.set('layout', {
            autoPadding: true,
            padding: {
                top: 0,
                right: 0,
                bottom: 0,
                left: 0
            }
        });
    }

    const intlCache = new Map();
    function getNumberFormat(locale, options) {
        options = options || {};
        const cacheKey = locale + JSON.stringify(options);
        let formatter = intlCache.get(cacheKey);
        if (!formatter) {
            formatter = new Intl.NumberFormat(locale, options);
            intlCache.set(cacheKey, formatter);
        }
        return formatter;
    }
    function formatNumber(num, locale, options) {
        return getNumberFormat(locale, options).format(num);
    }

    const formatters = {
     values (value) {
            return isArray$1(value) ?  value : '' + value;
        },
     numeric (tickValue, index, ticks) {
            if (tickValue === 0) {
                return '0';
            }
            const locale = this.chart.options.locale;
            let notation;
            let delta = tickValue;
            if (ticks.length > 1) {
                const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));
                if (maxTick < 1e-4 || maxTick > 1e+15) {
                    notation = 'scientific';
                }
                delta = calculateDelta(tickValue, ticks);
            }
            const logDelta = log10(Math.abs(delta));
            const numDecimal = isNaN(logDelta) ? 1 : Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);
            const options = {
                notation,
                minimumFractionDigits: numDecimal,
                maximumFractionDigits: numDecimal
            };
            Object.assign(options, this.options.ticks.format);
            return formatNumber(tickValue, locale, options);
        },
     logarithmic (tickValue, index, ticks) {
            if (tickValue === 0) {
                return '0';
            }
            const remain = ticks[index].significand || tickValue / Math.pow(10, Math.floor(log10(tickValue)));
            if ([
                1,
                2,
                3,
                5,
                10,
                15
            ].includes(remain) || index > 0.8 * ticks.length) {
                return formatters.numeric.call(this, tickValue, index, ticks);
            }
            return '';
        }
    };
    function calculateDelta(tickValue, ticks) {
        let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;
        if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {
            delta = tickValue - Math.floor(tickValue);
        }
        return delta;
    }
     var Ticks = {
        formatters
    };

    function applyScaleDefaults(defaults) {
        defaults.set('scale', {
            display: true,
            offset: false,
            reverse: false,
            beginAtZero: false,
     bounds: 'ticks',
            clip: true,
     grace: 0,
            grid: {
                display: true,
                lineWidth: 1,
                drawOnChartArea: true,
                drawTicks: true,
                tickLength: 8,
                tickWidth: (_ctx, options)=>options.lineWidth,
                tickColor: (_ctx, options)=>options.color,
                offset: false
            },
            border: {
                display: true,
                dash: [],
                dashOffset: 0.0,
                width: 1
            },
            title: {
                display: false,
                text: '',
                padding: {
                    top: 4,
                    bottom: 4
                }
            },
            ticks: {
                minRotation: 0,
                maxRotation: 50,
                mirror: false,
                textStrokeWidth: 0,
                textStrokeColor: '',
                padding: 3,
                display: true,
                autoSkip: true,
                autoSkipPadding: 3,
                labelOffset: 0,
                callback: Ticks.formatters.values,
                minor: {},
                major: {},
                align: 'center',
                crossAlign: 'near',
                showLabelBackdrop: false,
                backdropColor: 'rgba(255, 255, 255, 0.75)',
                backdropPadding: 2
            }
        });
        defaults.route('scale.ticks', 'color', '', 'color');
        defaults.route('scale.grid', 'color', '', 'borderColor');
        defaults.route('scale.border', 'color', '', 'borderColor');
        defaults.route('scale.title', 'color', '', 'color');
        defaults.describe('scale', {
            _fallback: false,
            _scriptable: (name)=>!name.startsWith('before') && !name.startsWith('after') && name !== 'callback' && name !== 'parser',
            _indexable: (name)=>name !== 'borderDash' && name !== 'tickBorderDash' && name !== 'dash'
        });
        defaults.describe('scales', {
            _fallback: 'scale'
        });
        defaults.describe('scale.ticks', {
            _scriptable: (name)=>name !== 'backdropPadding' && name !== 'callback',
            _indexable: (name)=>name !== 'backdropPadding'
        });
    }

    const overrides = Object.create(null);
    const descriptors = Object.create(null);
     function getScope$1(node, key) {
        if (!key) {
            return node;
        }
        const keys = key.split('.');
        for(let i = 0, n = keys.length; i < n; ++i){
            const k = keys[i];
            node = node[k] || (node[k] = Object.create(null));
        }
        return node;
    }
    function set(root, scope, values) {
        if (typeof scope === 'string') {
            return merge(getScope$1(root, scope), values);
        }
        return merge(getScope$1(root, ''), scope);
    }
     class Defaults {
        constructor(_descriptors, _appliers){
            this.animation = undefined;
            this.backgroundColor = 'rgba(0,0,0,0.1)';
            this.borderColor = 'rgba(0,0,0,0.1)';
            this.color = '#666';
            this.datasets = {};
            this.devicePixelRatio = (context)=>context.chart.platform.getDevicePixelRatio();
            this.elements = {};
            this.events = [
                'mousemove',
                'mouseout',
                'click',
                'touchstart',
                'touchmove'
            ];
            this.font = {
                family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
                size: 12,
                style: 'normal',
                lineHeight: 1.2,
                weight: null
            };
            this.hover = {};
            this.hoverBackgroundColor = (ctx, options)=>getHoverColor(options.backgroundColor);
            this.hoverBorderColor = (ctx, options)=>getHoverColor(options.borderColor);
            this.hoverColor = (ctx, options)=>getHoverColor(options.color);
            this.indexAxis = 'x';
            this.interaction = {
                mode: 'nearest',
                intersect: true,
                includeInvisible: false
            };
            this.maintainAspectRatio = true;
            this.onHover = null;
            this.onClick = null;
            this.parsing = true;
            this.plugins = {};
            this.responsive = true;
            this.scale = undefined;
            this.scales = {};
            this.showLine = true;
            this.drawActiveElementsOnTop = true;
            this.describe(_descriptors);
            this.apply(_appliers);
        }
     set(scope, values) {
            return set(this, scope, values);
        }
     get(scope) {
            return getScope$1(this, scope);
        }
     describe(scope, values) {
            return set(descriptors, scope, values);
        }
        override(scope, values) {
            return set(overrides, scope, values);
        }
     route(scope, name, targetScope, targetName) {
            const scopeObject = getScope$1(this, scope);
            const targetScopeObject = getScope$1(this, targetScope);
            const privateName = '_' + name;
            Object.defineProperties(scopeObject, {
                [privateName]: {
                    value: scopeObject[name],
                    writable: true
                },
                [name]: {
                    enumerable: true,
                    get () {
                        const local = this[privateName];
                        const target = targetScopeObject[targetName];
                        if (isObject$1(local)) {
                            return Object.assign({}, target, local);
                        }
                        return valueOrDefault(local, target);
                    },
                    set (value) {
                        this[privateName] = value;
                    }
                }
            });
        }
        apply(appliers) {
            appliers.forEach((apply)=>apply(this));
        }
    }
    var defaults$1 = /* #__PURE__ */ new Defaults({
        _scriptable: (name)=>!name.startsWith('on'),
        _indexable: (name)=>name !== 'events',
        hover: {
            _fallback: 'interaction'
        },
        interaction: {
            _scriptable: false,
            _indexable: false
        }
    }, [
        applyAnimationsDefaults,
        applyLayoutsDefaults,
        applyScaleDefaults
    ]);

    /**
     * Converts the given font object into a CSS font string.
     * @param font - A font object.
     * @return The CSS font string. See https://developer.mozilla.org/en-US/docs/Web/CSS/font
     * @private
     */ function toFontString(font) {
        if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {
            return null;
        }
        return (font.style ? font.style + ' ' : '') + (font.weight ? font.weight + ' ' : '') + font.size + 'px ' + font.family;
    }
    /**
     * @private
     */ function _measureText(ctx, data, gc, longest, string) {
        let textWidth = data[string];
        if (!textWidth) {
            textWidth = data[string] = ctx.measureText(string).width;
            gc.push(string);
        }
        if (textWidth > longest) {
            longest = textWidth;
        }
        return longest;
    }
    /**
     * @private
     */ // eslint-disable-next-line complexity
    function _longestText(ctx, font, arrayOfThings, cache) {
        cache = cache || {};
        let data = cache.data = cache.data || {};
        let gc = cache.garbageCollect = cache.garbageCollect || [];
        if (cache.font !== font) {
            data = cache.data = {};
            gc = cache.garbageCollect = [];
            cache.font = font;
        }
        ctx.save();
        ctx.font = font;
        let longest = 0;
        const ilen = arrayOfThings.length;
        let i, j, jlen, thing, nestedThing;
        for(i = 0; i < ilen; i++){
            thing = arrayOfThings[i];
            // Undefined strings and arrays should not be measured
            if (thing !== undefined && thing !== null && !isArray$1(thing)) {
                longest = _measureText(ctx, data, gc, longest, thing);
            } else if (isArray$1(thing)) {
                // if it is an array lets measure each element
                // to do maybe simplify this function a bit so we can do this more recursively?
                for(j = 0, jlen = thing.length; j < jlen; j++){
                    nestedThing = thing[j];
                    // Undefined strings and arrays should not be measured
                    if (nestedThing !== undefined && nestedThing !== null && !isArray$1(nestedThing)) {
                        longest = _measureText(ctx, data, gc, longest, nestedThing);
                    }
                }
            }
        }
        ctx.restore();
        const gcLen = gc.length / 2;
        if (gcLen > arrayOfThings.length) {
            for(i = 0; i < gcLen; i++){
                delete data[gc[i]];
            }
            gc.splice(0, gcLen);
        }
        return longest;
    }
    /**
     * Returns the aligned pixel value to avoid anti-aliasing blur
     * @param chart - The chart instance.
     * @param pixel - A pixel value.
     * @param width - The width of the element.
     * @returns The aligned pixel value.
     * @private
     */ function _alignPixel(chart, pixel, width) {
        const devicePixelRatio = chart.currentDevicePixelRatio;
        const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;
        return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
    }
    /**
     * Clears the entire canvas.
     */ function clearCanvas(canvas, ctx) {
        if (!ctx && !canvas) {
            return;
        }
        ctx = ctx || canvas.getContext('2d');
        ctx.save();
        // canvas.width and canvas.height do not consider the canvas transform,
        // while clearRect does
        ctx.resetTransform();
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.restore();
    }
    function drawPoint(ctx, options, x, y) {
        // eslint-disable-next-line @typescript-eslint/no-use-before-define
        drawPointLegend(ctx, options, x, y, null);
    }
    // eslint-disable-next-line complexity
    function drawPointLegend(ctx, options, x, y, w) {
        let type, xOffset, yOffset, size, cornerRadius, width, xOffsetW, yOffsetW;
        const style = options.pointStyle;
        const rotation = options.rotation;
        const radius = options.radius;
        let rad = (rotation || 0) * RAD_PER_DEG;
        if (style && typeof style === 'object') {
            type = style.toString();
            if (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rad);
                ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);
                ctx.restore();
                return;
            }
        }
        if (isNaN(radius) || radius <= 0) {
            return;
        }
        ctx.beginPath();
        switch(style){
            // Default includes circle
            default:
                if (w) {
                    ctx.ellipse(x, y, w / 2, radius, 0, 0, TAU);
                } else {
                    ctx.arc(x, y, radius, 0, TAU);
                }
                ctx.closePath();
                break;
            case 'triangle':
                width = w ? w / 2 : radius;
                ctx.moveTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
                rad += TWO_THIRDS_PI;
                ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
                rad += TWO_THIRDS_PI;
                ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
                ctx.closePath();
                break;
            case 'rectRounded':
                // NOTE: the rounded rect implementation changed to use `arc` instead of
                // `quadraticCurveTo` since it generates better results when rect is
                // almost a circle. 0.516 (instead of 0.5) produces results with visually
                // closer proportion to the previous impl and it is inscribed in the
                // circle with `radius`. For more details, see the following PRs:
                // https://github.com/chartjs/Chart.js/issues/5597
                // https://github.com/chartjs/Chart.js/issues/5858
                cornerRadius = radius * 0.516;
                size = radius - cornerRadius;
                xOffset = Math.cos(rad + QUARTER_PI) * size;
                xOffsetW = Math.cos(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);
                yOffset = Math.sin(rad + QUARTER_PI) * size;
                yOffsetW = Math.sin(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);
                ctx.arc(x - xOffsetW, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
                ctx.arc(x + yOffsetW, y - xOffset, cornerRadius, rad - HALF_PI, rad);
                ctx.arc(x + xOffsetW, y + yOffset, cornerRadius, rad, rad + HALF_PI);
                ctx.arc(x - yOffsetW, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
                ctx.closePath();
                break;
            case 'rect':
                if (!rotation) {
                    size = Math.SQRT1_2 * radius;
                    width = w ? w / 2 : size;
                    ctx.rect(x - width, y - size, 2 * width, 2 * size);
                    break;
                }
                rad += QUARTER_PI;
            /* falls through */ case 'rectRot':
                xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
                xOffset = Math.cos(rad) * radius;
                yOffset = Math.sin(rad) * radius;
                yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
                ctx.moveTo(x - xOffsetW, y - yOffset);
                ctx.lineTo(x + yOffsetW, y - xOffset);
                ctx.lineTo(x + xOffsetW, y + yOffset);
                ctx.lineTo(x - yOffsetW, y + xOffset);
                ctx.closePath();
                break;
            case 'crossRot':
                rad += QUARTER_PI;
            /* falls through */ case 'cross':
                xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
                xOffset = Math.cos(rad) * radius;
                yOffset = Math.sin(rad) * radius;
                yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
                ctx.moveTo(x - xOffsetW, y - yOffset);
                ctx.lineTo(x + xOffsetW, y + yOffset);
                ctx.moveTo(x + yOffsetW, y - xOffset);
                ctx.lineTo(x - yOffsetW, y + xOffset);
                break;
            case 'star':
                xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
                xOffset = Math.cos(rad) * radius;
                yOffset = Math.sin(rad) * radius;
                yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
                ctx.moveTo(x - xOffsetW, y - yOffset);
                ctx.lineTo(x + xOffsetW, y + yOffset);
                ctx.moveTo(x + yOffsetW, y - xOffset);
                ctx.lineTo(x - yOffsetW, y + xOffset);
                rad += QUARTER_PI;
                xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
                xOffset = Math.cos(rad) * radius;
                yOffset = Math.sin(rad) * radius;
                yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
                ctx.moveTo(x - xOffsetW, y - yOffset);
                ctx.lineTo(x + xOffsetW, y + yOffset);
                ctx.moveTo(x + yOffsetW, y - xOffset);
                ctx.lineTo(x - yOffsetW, y + xOffset);
                break;
            case 'line':
                xOffset = w ? w / 2 : Math.cos(rad) * radius;
                yOffset = Math.sin(rad) * radius;
                ctx.moveTo(x - xOffset, y - yOffset);
                ctx.lineTo(x + xOffset, y + yOffset);
                break;
            case 'dash':
                ctx.moveTo(x, y);
                ctx.lineTo(x + Math.cos(rad) * (w ? w / 2 : radius), y + Math.sin(rad) * radius);
                break;
            case false:
                ctx.closePath();
                break;
        }
        ctx.fill();
        if (options.borderWidth > 0) {
            ctx.stroke();
        }
    }
    /**
     * Returns true if the point is inside the rectangle
     * @param point - The point to test
     * @param area - The rectangle
     * @param margin - allowed margin
     * @private
     */ function _isPointInArea(point, area, margin) {
        margin = margin || 0.5; // margin - default is to match rounded decimals
        return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;
    }
    function clipArea(ctx, area) {
        ctx.save();
        ctx.beginPath();
        ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
        ctx.clip();
    }
    function unclipArea(ctx) {
        ctx.restore();
    }
    /**
     * @private
     */ function _steppedLineTo(ctx, previous, target, flip, mode) {
        if (!previous) {
            return ctx.lineTo(target.x, target.y);
        }
        if (mode === 'middle') {
            const midpoint = (previous.x + target.x) / 2.0;
            ctx.lineTo(midpoint, previous.y);
            ctx.lineTo(midpoint, target.y);
        } else if (mode === 'after' !== !!flip) {
            ctx.lineTo(previous.x, target.y);
        } else {
            ctx.lineTo(target.x, previous.y);
        }
        ctx.lineTo(target.x, target.y);
    }
    /**
     * @private
     */ function _bezierCurveTo(ctx, previous, target, flip) {
        if (!previous) {
            return ctx.lineTo(target.x, target.y);
        }
        ctx.bezierCurveTo(flip ? previous.cp1x : previous.cp2x, flip ? previous.cp1y : previous.cp2y, flip ? target.cp2x : target.cp1x, flip ? target.cp2y : target.cp1y, target.x, target.y);
    }
    function setRenderOpts(ctx, opts) {
        if (opts.translation) {
            ctx.translate(opts.translation[0], opts.translation[1]);
        }
        if (!isNullOrUndef(opts.rotation)) {
            ctx.rotate(opts.rotation);
        }
        if (opts.color) {
            ctx.fillStyle = opts.color;
        }
        if (opts.textAlign) {
            ctx.textAlign = opts.textAlign;
        }
        if (opts.textBaseline) {
            ctx.textBaseline = opts.textBaseline;
        }
    }
    function decorateText(ctx, x, y, line, opts) {
        if (opts.strikethrough || opts.underline) {
            /**
         * Now that IE11 support has been dropped, we can use more
         * of the TextMetrics object. The actual bounding boxes
         * are unflagged in Chrome, Firefox, Edge, and Safari so they
         * can be safely used.
         * See https://developer.mozilla.org/en-US/docs/Web/API/TextMetrics#Browser_compatibility
         */ const metrics = ctx.measureText(line);
            const left = x - metrics.actualBoundingBoxLeft;
            const right = x + metrics.actualBoundingBoxRight;
            const top = y - metrics.actualBoundingBoxAscent;
            const bottom = y + metrics.actualBoundingBoxDescent;
            const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;
            ctx.strokeStyle = ctx.fillStyle;
            ctx.beginPath();
            ctx.lineWidth = opts.decorationWidth || 2;
            ctx.moveTo(left, yDecoration);
            ctx.lineTo(right, yDecoration);
            ctx.stroke();
        }
    }
    function drawBackdrop(ctx, opts) {
        const oldColor = ctx.fillStyle;
        ctx.fillStyle = opts.color;
        ctx.fillRect(opts.left, opts.top, opts.width, opts.height);
        ctx.fillStyle = oldColor;
    }
    /**
     * Render text onto the canvas
     */ function renderText(ctx, text, x, y, font, opts = {}) {
        const lines = isArray$1(text) ? text : [
            text
        ];
        const stroke = opts.strokeWidth > 0 && opts.strokeColor !== '';
        let i, line;
        ctx.save();
        ctx.font = font.string;
        setRenderOpts(ctx, opts);
        for(i = 0; i < lines.length; ++i){
            line = lines[i];
            if (opts.backdrop) {
                drawBackdrop(ctx, opts.backdrop);
            }
            if (stroke) {
                if (opts.strokeColor) {
                    ctx.strokeStyle = opts.strokeColor;
                }
                if (!isNullOrUndef(opts.strokeWidth)) {
                    ctx.lineWidth = opts.strokeWidth;
                }
                ctx.strokeText(line, x, y, opts.maxWidth);
            }
            ctx.fillText(line, x, y, opts.maxWidth);
            decorateText(ctx, x, y, line, opts);
            y += Number(font.lineHeight);
        }
        ctx.restore();
    }
    /**
     * Add a path of a rectangle with rounded corners to the current sub-path
     * @param ctx - Context
     * @param rect - Bounding rect
     */ function addRoundedRectPath(ctx, rect) {
        const { x , y , w , h , radius  } = rect;
        // top left arc
        ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, 1.5 * PI, PI, true);
        // line from top left to bottom left
        ctx.lineTo(x, y + h - radius.bottomLeft);
        // bottom left arc
        ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);
        // line from bottom left to bottom right
        ctx.lineTo(x + w - radius.bottomRight, y + h);
        // bottom right arc
        ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);
        // line from bottom right to top right
        ctx.lineTo(x + w, y + radius.topRight);
        // top right arc
        ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);
        // line from top right to top left
        ctx.lineTo(x + radius.topLeft, y);
    }

    const LINE_HEIGHT = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/;
    const FONT_STYLE = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;
    /**
     * @alias Chart.helpers.options
     * @namespace
     */ /**
     * Converts the given line height `value` in pixels for a specific font `size`.
     * @param value - The lineHeight to parse (eg. 1.6, '14px', '75%', '1.6em').
     * @param size - The font size (in pixels) used to resolve relative `value`.
     * @returns The effective line height in pixels (size * 1.2 if value is invalid).
     * @see https://developer.mozilla.org/en-US/docs/Web/CSS/line-height
     * @since 2.7.0
     */ function toLineHeight(value, size) {
        const matches = ('' + value).match(LINE_HEIGHT);
        if (!matches || matches[1] === 'normal') {
            return size * 1.2;
        }
        value = +matches[2];
        switch(matches[3]){
            case 'px':
                return value;
            case '%':
                value /= 100;
                break;
        }
        return size * value;
    }
    const numberOrZero = (v)=>+v || 0;
    function _readValueToProps(value, props) {
        const ret = {};
        const objProps = isObject$1(props);
        const keys = objProps ? Object.keys(props) : props;
        const read = isObject$1(value) ? objProps ? (prop)=>valueOrDefault(value[prop], value[props[prop]]) : (prop)=>value[prop] : ()=>value;
        for (const prop of keys){
            ret[prop] = numberOrZero(read(prop));
        }
        return ret;
    }
    /**
     * Converts the given value into a TRBL object.
     * @param value - If a number, set the value to all TRBL component,
     *  else, if an object, use defined properties and sets undefined ones to 0.
     *  x / y are shorthands for same value for left/right and top/bottom.
     * @returns The padding values (top, right, bottom, left)
     * @since 3.0.0
     */ function toTRBL(value) {
        return _readValueToProps(value, {
            top: 'y',
            right: 'x',
            bottom: 'y',
            left: 'x'
        });
    }
    /**
     * Converts the given value into a TRBL corners object (similar with css border-radius).
     * @param value - If a number, set the value to all TRBL corner components,
     *  else, if an object, use defined properties and sets undefined ones to 0.
     * @returns The TRBL corner values (topLeft, topRight, bottomLeft, bottomRight)
     * @since 3.0.0
     */ function toTRBLCorners(value) {
        return _readValueToProps(value, [
            'topLeft',
            'topRight',
            'bottomLeft',
            'bottomRight'
        ]);
    }
    /**
     * Converts the given value into a padding object with pre-computed width/height.
     * @param value - If a number, set the value to all TRBL component,
     *  else, if an object, use defined properties and sets undefined ones to 0.
     *  x / y are shorthands for same value for left/right and top/bottom.
     * @returns The padding values (top, right, bottom, left, width, height)
     * @since 2.7.0
     */ function toPadding(value) {
        const obj = toTRBL(value);
        obj.width = obj.left + obj.right;
        obj.height = obj.top + obj.bottom;
        return obj;
    }
    /**
     * Parses font options and returns the font object.
     * @param options - A object that contains font options to be parsed.
     * @param fallback - A object that contains fallback font options.
     * @return The font object.
     * @private
     */ function toFont(options, fallback) {
        options = options || {};
        fallback = fallback || defaults$1.font;
        let size = valueOrDefault(options.size, fallback.size);
        if (typeof size === 'string') {
            size = parseInt(size, 10);
        }
        let style = valueOrDefault(options.style, fallback.style);
        if (style && !('' + style).match(FONT_STYLE)) {
            console.warn('Invalid font style specified: "' + style + '"');
            style = undefined;
        }
        const font = {
            family: valueOrDefault(options.family, fallback.family),
            lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),
            size,
            style,
            weight: valueOrDefault(options.weight, fallback.weight),
            string: ''
        };
        font.string = toFontString(font);
        return font;
    }
    /**
     * Evaluates the given `inputs` sequentially and returns the first defined value.
     * @param inputs - An array of values, falling back to the last value.
     * @param context - If defined and the current value is a function, the value
     * is called with `context` as first argument and the result becomes the new input.
     * @param index - If defined and the current value is an array, the value
     * at `index` become the new input.
     * @param info - object to return information about resolution in
     * @param info.cacheable - Will be set to `false` if option is not cacheable.
     * @since 2.7.0
     */ function resolve(inputs, context, index, info) {
        let cacheable = true;
        let i, ilen, value;
        for(i = 0, ilen = inputs.length; i < ilen; ++i){
            value = inputs[i];
            if (value === undefined) {
                continue;
            }
            if (context !== undefined && typeof value === 'function') {
                value = value(context);
                cacheable = false;
            }
            if (index !== undefined && isArray$1(value)) {
                value = value[index % value.length];
                cacheable = false;
            }
            if (value !== undefined) {
                if (info && !cacheable) {
                    info.cacheable = false;
                }
                return value;
            }
        }
    }
    /**
     * @param minmax
     * @param grace
     * @param beginAtZero
     * @private
     */ function _addGrace(minmax, grace, beginAtZero) {
        const { min , max  } = minmax;
        const change = toDimension(grace, (max - min) / 2);
        const keepZero = (value, add)=>beginAtZero && value === 0 ? 0 : value + add;
        return {
            min: keepZero(min, -Math.abs(change)),
            max: keepZero(max, change)
        };
    }
    function createContext(parentContext, context) {
        return Object.assign(Object.create(parentContext), context);
    }

    /**
     * Creates a Proxy for resolving raw values for options.
     * @param scopes - The option scopes to look for values, in resolution order
     * @param prefixes - The prefixes for values, in resolution order.
     * @param rootScopes - The root option scopes
     * @param fallback - Parent scopes fallback
     * @param getTarget - callback for getting the target for changed values
     * @returns Proxy
     * @private
     */ function _createResolver(scopes, prefixes = [
        ''
    ], rootScopes, fallback, getTarget = ()=>scopes[0]) {
        const finalRootScopes = rootScopes || scopes;
        if (typeof fallback === 'undefined') {
            fallback = _resolve('_fallback', scopes);
        }
        const cache = {
            [Symbol.toStringTag]: 'Object',
            _cacheable: true,
            _scopes: scopes,
            _rootScopes: finalRootScopes,
            _fallback: fallback,
            _getTarget: getTarget,
            override: (scope)=>_createResolver([
                    scope,
                    ...scopes
                ], prefixes, finalRootScopes, fallback)
        };
        return new Proxy(cache, {
            /**
         * A trap for the delete operator.
         */ deleteProperty (target, prop) {
                delete target[prop]; // remove from cache
                delete target._keys; // remove cached keys
                delete scopes[0][prop]; // remove from top level scope
                return true;
            },
            /**
         * A trap for getting property values.
         */ get (target, prop) {
                return _cached(target, prop, ()=>_resolveWithPrefixes(prop, prefixes, scopes, target));
            },
            /**
         * A trap for Object.getOwnPropertyDescriptor.
         * Also used by Object.hasOwnProperty.
         */ getOwnPropertyDescriptor (target, prop) {
                return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);
            },
            /**
         * A trap for Object.getPrototypeOf.
         */ getPrototypeOf () {
                return Reflect.getPrototypeOf(scopes[0]);
            },
            /**
         * A trap for the in operator.
         */ has (target, prop) {
                return getKeysFromAllScopes(target).includes(prop);
            },
            /**
         * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
         */ ownKeys (target) {
                return getKeysFromAllScopes(target);
            },
            /**
         * A trap for setting property values.
         */ set (target, prop, value) {
                const storage = target._storage || (target._storage = getTarget());
                target[prop] = storage[prop] = value; // set to top level scope + cache
                delete target._keys; // remove cached keys
                return true;
            }
        });
    }
    /**
     * Returns an Proxy for resolving option values with context.
     * @param proxy - The Proxy returned by `_createResolver`
     * @param context - Context object for scriptable/indexable options
     * @param subProxy - The proxy provided for scriptable options
     * @param descriptorDefaults - Defaults for descriptors
     * @private
     */ function _attachContext(proxy, context, subProxy, descriptorDefaults) {
        const cache = {
            _cacheable: false,
            _proxy: proxy,
            _context: context,
            _subProxy: subProxy,
            _stack: new Set(),
            _descriptors: _descriptors(proxy, descriptorDefaults),
            setContext: (ctx)=>_attachContext(proxy, ctx, subProxy, descriptorDefaults),
            override: (scope)=>_attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)
        };
        return new Proxy(cache, {
            /**
         * A trap for the delete operator.
         */ deleteProperty (target, prop) {
                delete target[prop]; // remove from cache
                delete proxy[prop]; // remove from proxy
                return true;
            },
            /**
         * A trap for getting property values.
         */ get (target, prop, receiver) {
                return _cached(target, prop, ()=>_resolveWithContext(target, prop, receiver));
            },
            /**
         * A trap for Object.getOwnPropertyDescriptor.
         * Also used by Object.hasOwnProperty.
         */ getOwnPropertyDescriptor (target, prop) {
                return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? {
                    enumerable: true,
                    configurable: true
                } : undefined : Reflect.getOwnPropertyDescriptor(proxy, prop);
            },
            /**
         * A trap for Object.getPrototypeOf.
         */ getPrototypeOf () {
                return Reflect.getPrototypeOf(proxy);
            },
            /**
         * A trap for the in operator.
         */ has (target, prop) {
                return Reflect.has(proxy, prop);
            },
            /**
         * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
         */ ownKeys () {
                return Reflect.ownKeys(proxy);
            },
            /**
         * A trap for setting property values.
         */ set (target, prop, value) {
                proxy[prop] = value; // set to proxy
                delete target[prop]; // remove from cache
                return true;
            }
        });
    }
    /**
     * @private
     */ function _descriptors(proxy, defaults = {
        scriptable: true,
        indexable: true
    }) {
        const { _scriptable =defaults.scriptable , _indexable =defaults.indexable , _allKeys =defaults.allKeys  } = proxy;
        return {
            allKeys: _allKeys,
            scriptable: _scriptable,
            indexable: _indexable,
            isScriptable: isFunction$1(_scriptable) ? _scriptable : ()=>_scriptable,
            isIndexable: isFunction$1(_indexable) ? _indexable : ()=>_indexable
        };
    }
    const readKey = (prefix, name)=>prefix ? prefix + _capitalize(name) : name;
    const needsSubResolver = (prop, value)=>isObject$1(value) && prop !== 'adapters' && (Object.getPrototypeOf(value) === null || value.constructor === Object);
    function _cached(target, prop, resolve) {
        if (Object.prototype.hasOwnProperty.call(target, prop) || prop === 'constructor') {
            return target[prop];
        }
        const value = resolve();
        // cache the resolved value
        target[prop] = value;
        return value;
    }
    function _resolveWithContext(target, prop, receiver) {
        const { _proxy , _context , _subProxy , _descriptors: descriptors  } = target;
        let value = _proxy[prop]; // resolve from proxy
        // resolve with context
        if (isFunction$1(value) && descriptors.isScriptable(prop)) {
            value = _resolveScriptable(prop, value, target, receiver);
        }
        if (isArray$1(value) && value.length) {
            value = _resolveArray(prop, value, target, descriptors.isIndexable);
        }
        if (needsSubResolver(prop, value)) {
            // if the resolved value is an object, create a sub resolver for it
            value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors);
        }
        return value;
    }
    function _resolveScriptable(prop, getValue, target, receiver) {
        const { _proxy , _context , _subProxy , _stack  } = target;
        if (_stack.has(prop)) {
            throw new Error('Recursion detected: ' + Array.from(_stack).join('->') + '->' + prop);
        }
        _stack.add(prop);
        let value = getValue(_context, _subProxy || receiver);
        _stack.delete(prop);
        if (needsSubResolver(prop, value)) {
            // When scriptable option returns an object, create a resolver on that.
            value = createSubResolver(_proxy._scopes, _proxy, prop, value);
        }
        return value;
    }
    function _resolveArray(prop, value, target, isIndexable) {
        const { _proxy , _context , _subProxy , _descriptors: descriptors  } = target;
        if (typeof _context.index !== 'undefined' && isIndexable(prop)) {
            return value[_context.index % value.length];
        } else if (isObject$1(value[0])) {
            // Array of objects, return array or resolvers
            const arr = value;
            const scopes = _proxy._scopes.filter((s)=>s !== arr);
            value = [];
            for (const item of arr){
                const resolver = createSubResolver(scopes, _proxy, prop, item);
                value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors));
            }
        }
        return value;
    }
    function resolveFallback(fallback, prop, value) {
        return isFunction$1(fallback) ? fallback(prop, value) : fallback;
    }
    const getScope = (key, parent)=>key === true ? parent : typeof key === 'string' ? resolveObjectKey(parent, key) : undefined;
    function addScopes(set, parentScopes, key, parentFallback, value) {
        for (const parent of parentScopes){
            const scope = getScope(key, parent);
            if (scope) {
                set.add(scope);
                const fallback = resolveFallback(scope._fallback, key, value);
                if (typeof fallback !== 'undefined' && fallback !== key && fallback !== parentFallback) {
                    // When we reach the descriptor that defines a new _fallback, return that.
                    // The fallback will resume to that new scope.
                    return fallback;
                }
            } else if (scope === false && typeof parentFallback !== 'undefined' && key !== parentFallback) {
                // Fallback to `false` results to `false`, when falling back to different key.
                // For example `interaction` from `hover` or `plugins.tooltip` and `animation` from `animations`
                return null;
            }
        }
        return false;
    }
    function createSubResolver(parentScopes, resolver, prop, value) {
        const rootScopes = resolver._rootScopes;
        const fallback = resolveFallback(resolver._fallback, prop, value);
        const allScopes = [
            ...parentScopes,
            ...rootScopes
        ];
        const set = new Set();
        set.add(value);
        let key = addScopesFromKey(set, allScopes, prop, fallback || prop, value);
        if (key === null) {
            return false;
        }
        if (typeof fallback !== 'undefined' && fallback !== prop) {
            key = addScopesFromKey(set, allScopes, fallback, key, value);
            if (key === null) {
                return false;
            }
        }
        return _createResolver(Array.from(set), [
            ''
        ], rootScopes, fallback, ()=>subGetTarget(resolver, prop, value));
    }
    function addScopesFromKey(set, allScopes, key, fallback, item) {
        while(key){
            key = addScopes(set, allScopes, key, fallback, item);
        }
        return key;
    }
    function subGetTarget(resolver, prop, value) {
        const parent = resolver._getTarget();
        if (!(prop in parent)) {
            parent[prop] = {};
        }
        const target = parent[prop];
        if (isArray$1(target) && isObject$1(value)) {
            // For array of objects, the object is used to store updated values
            return value;
        }
        return target || {};
    }
    function _resolveWithPrefixes(prop, prefixes, scopes, proxy) {
        let value;
        for (const prefix of prefixes){
            value = _resolve(readKey(prefix, prop), scopes);
            if (typeof value !== 'undefined') {
                return needsSubResolver(prop, value) ? createSubResolver(scopes, proxy, prop, value) : value;
            }
        }
    }
    function _resolve(key, scopes) {
        for (const scope of scopes){
            if (!scope) {
                continue;
            }
            const value = scope[key];
            if (typeof value !== 'undefined') {
                return value;
            }
        }
    }
    function getKeysFromAllScopes(target) {
        let keys = target._keys;
        if (!keys) {
            keys = target._keys = resolveKeysFromAllScopes(target._scopes);
        }
        return keys;
    }
    function resolveKeysFromAllScopes(scopes) {
        const set = new Set();
        for (const scope of scopes){
            for (const key of Object.keys(scope).filter((k)=>!k.startsWith('_'))){
                set.add(key);
            }
        }
        return Array.from(set);
    }
    function _parseObjectDataRadialScale(meta, data, start, count) {
        const { iScale  } = meta;
        const { key ='r'  } = this._parsing;
        const parsed = new Array(count);
        let i, ilen, index, item;
        for(i = 0, ilen = count; i < ilen; ++i){
            index = i + start;
            item = data[index];
            parsed[i] = {
                r: iScale.parse(resolveObjectKey(item, key), index)
            };
        }
        return parsed;
    }

    const EPSILON = Number.EPSILON || 1e-14;
    const getPoint = (points, i)=>i < points.length && !points[i].skip && points[i];
    const getValueAxis = (indexAxis)=>indexAxis === 'x' ? 'y' : 'x';
    function splineCurve(firstPoint, middlePoint, afterPoint, t) {
        // Props to Rob Spencer at scaled innovation for his post on splining between points
        // http://scaledinnovation.com/analytics/splines/aboutSplines.html
        // This function must also respect "skipped" points
        const previous = firstPoint.skip ? middlePoint : firstPoint;
        const current = middlePoint;
        const next = afterPoint.skip ? middlePoint : afterPoint;
        const d01 = distanceBetweenPoints(current, previous);
        const d12 = distanceBetweenPoints(next, current);
        let s01 = d01 / (d01 + d12);
        let s12 = d12 / (d01 + d12);
        // If all points are the same, s01 & s02 will be inf
        s01 = isNaN(s01) ? 0 : s01;
        s12 = isNaN(s12) ? 0 : s12;
        const fa = t * s01; // scaling factor for triangle Ta
        const fb = t * s12;
        return {
            previous: {
                x: current.x - fa * (next.x - previous.x),
                y: current.y - fa * (next.y - previous.y)
            },
            next: {
                x: current.x + fb * (next.x - previous.x),
                y: current.y + fb * (next.y - previous.y)
            }
        };
    }
    /**
     * Adjust tangents to ensure monotonic properties
     */ function monotoneAdjust(points, deltaK, mK) {
        const pointsLen = points.length;
        let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;
        let pointAfter = getPoint(points, 0);
        for(let i = 0; i < pointsLen - 1; ++i){
            pointCurrent = pointAfter;
            pointAfter = getPoint(points, i + 1);
            if (!pointCurrent || !pointAfter) {
                continue;
            }
            if (almostEquals(deltaK[i], 0, EPSILON)) {
                mK[i] = mK[i + 1] = 0;
                continue;
            }
            alphaK = mK[i] / deltaK[i];
            betaK = mK[i + 1] / deltaK[i];
            squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
            if (squaredMagnitude <= 9) {
                continue;
            }
            tauK = 3 / Math.sqrt(squaredMagnitude);
            mK[i] = alphaK * tauK * deltaK[i];
            mK[i + 1] = betaK * tauK * deltaK[i];
        }
    }
    function monotoneCompute(points, mK, indexAxis = 'x') {
        const valueAxis = getValueAxis(indexAxis);
        const pointsLen = points.length;
        let delta, pointBefore, pointCurrent;
        let pointAfter = getPoint(points, 0);
        for(let i = 0; i < pointsLen; ++i){
            pointBefore = pointCurrent;
            pointCurrent = pointAfter;
            pointAfter = getPoint(points, i + 1);
            if (!pointCurrent) {
                continue;
            }
            const iPixel = pointCurrent[indexAxis];
            const vPixel = pointCurrent[valueAxis];
            if (pointBefore) {
                delta = (iPixel - pointBefore[indexAxis]) / 3;
                pointCurrent[`cp1${indexAxis}`] = iPixel - delta;
                pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];
            }
            if (pointAfter) {
                delta = (pointAfter[indexAxis] - iPixel) / 3;
                pointCurrent[`cp2${indexAxis}`] = iPixel + delta;
                pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];
            }
        }
    }
    /**
     * This function calculates Bzier control points in a similar way than |splineCurve|,
     * but preserves monotonicity of the provided data and ensures no local extremums are added
     * between the dataset discrete points due to the interpolation.
     * See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation
     */ function splineCurveMonotone(points, indexAxis = 'x') {
        const valueAxis = getValueAxis(indexAxis);
        const pointsLen = points.length;
        const deltaK = Array(pointsLen).fill(0);
        const mK = Array(pointsLen);
        // Calculate slopes (deltaK) and initialize tangents (mK)
        let i, pointBefore, pointCurrent;
        let pointAfter = getPoint(points, 0);
        for(i = 0; i < pointsLen; ++i){
            pointBefore = pointCurrent;
            pointCurrent = pointAfter;
            pointAfter = getPoint(points, i + 1);
            if (!pointCurrent) {
                continue;
            }
            if (pointAfter) {
                const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];
                // In the case of two points that appear at the same x pixel, slopeDeltaX is 0
                deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;
            }
            mK[i] = !pointBefore ? deltaK[i] : !pointAfter ? deltaK[i - 1] : sign(deltaK[i - 1]) !== sign(deltaK[i]) ? 0 : (deltaK[i - 1] + deltaK[i]) / 2;
        }
        monotoneAdjust(points, deltaK, mK);
        monotoneCompute(points, mK, indexAxis);
    }
    function capControlPoint(pt, min, max) {
        return Math.max(Math.min(pt, max), min);
    }
    function capBezierPoints(points, area) {
        let i, ilen, point, inArea, inAreaPrev;
        let inAreaNext = _isPointInArea(points[0], area);
        for(i = 0, ilen = points.length; i < ilen; ++i){
            inAreaPrev = inArea;
            inArea = inAreaNext;
            inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);
            if (!inArea) {
                continue;
            }
            point = points[i];
            if (inAreaPrev) {
                point.cp1x = capControlPoint(point.cp1x, area.left, area.right);
                point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);
            }
            if (inAreaNext) {
                point.cp2x = capControlPoint(point.cp2x, area.left, area.right);
                point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);
            }
        }
    }
    /**
     * @private
     */ function _updateBezierControlPoints(points, options, area, loop, indexAxis) {
        let i, ilen, point, controlPoints;
        // Only consider points that are drawn in case the spanGaps option is used
        if (options.spanGaps) {
            points = points.filter((pt)=>!pt.skip);
        }
        if (options.cubicInterpolationMode === 'monotone') {
            splineCurveMonotone(points, indexAxis);
        } else {
            let prev = loop ? points[points.length - 1] : points[0];
            for(i = 0, ilen = points.length; i < ilen; ++i){
                point = points[i];
                controlPoints = splineCurve(prev, point, points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen], options.tension);
                point.cp1x = controlPoints.previous.x;
                point.cp1y = controlPoints.previous.y;
                point.cp2x = controlPoints.next.x;
                point.cp2y = controlPoints.next.y;
                prev = point;
            }
        }
        if (options.capBezierPoints) {
            capBezierPoints(points, area);
        }
    }

    /**
     * Note: typedefs are auto-exported, so use a made-up `dom` namespace where
     * necessary to avoid duplicates with `export * from './helpers`; see
     * https://github.com/microsoft/TypeScript/issues/46011
     * @typedef { import('../core/core.controller.js').default } dom.Chart
     * @typedef { import('../../types').ChartEvent } ChartEvent
     */ /**
     * @private
     */ function _isDomSupported() {
        return typeof window !== 'undefined' && typeof document !== 'undefined';
    }
    /**
     * @private
     */ function _getParentNode(domNode) {
        let parent = domNode.parentNode;
        if (parent && parent.toString() === '[object ShadowRoot]') {
            parent = parent.host;
        }
        return parent;
    }
    /**
     * convert max-width/max-height values that may be percentages into a number
     * @private
     */ function parseMaxStyle(styleValue, node, parentProperty) {
        let valueInPixels;
        if (typeof styleValue === 'string') {
            valueInPixels = parseInt(styleValue, 10);
            if (styleValue.indexOf('%') !== -1) {
                // percentage * size in dimension
                valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
            }
        } else {
            valueInPixels = styleValue;
        }
        return valueInPixels;
    }
    const getComputedStyle = (element)=>element.ownerDocument.defaultView.getComputedStyle(element, null);
    function getStyle(el, property) {
        return getComputedStyle(el).getPropertyValue(property);
    }
    const positions = [
        'top',
        'right',
        'bottom',
        'left'
    ];
    function getPositionedStyle(styles, style, suffix) {
        const result = {};
        suffix = suffix ? '-' + suffix : '';
        for(let i = 0; i < 4; i++){
            const pos = positions[i];
            result[pos] = parseFloat(styles[style + '-' + pos + suffix]) || 0;
        }
        result.width = result.left + result.right;
        result.height = result.top + result.bottom;
        return result;
    }
    const useOffsetPos = (x, y, target)=>(x > 0 || y > 0) && (!target || !target.shadowRoot);
    /**
     * @param e
     * @param canvas
     * @returns Canvas position
     */ function getCanvasPosition(e, canvas) {
        const touches = e.touches;
        const source = touches && touches.length ? touches[0] : e;
        const { offsetX , offsetY  } = source;
        let box = false;
        let x, y;
        if (useOffsetPos(offsetX, offsetY, e.target)) {
            x = offsetX;
            y = offsetY;
        } else {
            const rect = canvas.getBoundingClientRect();
            x = source.clientX - rect.left;
            y = source.clientY - rect.top;
            box = true;
        }
        return {
            x,
            y,
            box
        };
    }
    /**
     * Gets an event's x, y coordinates, relative to the chart area
     * @param event
     * @param chart
     * @returns x and y coordinates of the event
     */ function getRelativePosition(event, chart) {
        if ('native' in event) {
            return event;
        }
        const { canvas , currentDevicePixelRatio  } = chart;
        const style = getComputedStyle(canvas);
        const borderBox = style.boxSizing === 'border-box';
        const paddings = getPositionedStyle(style, 'padding');
        const borders = getPositionedStyle(style, 'border', 'width');
        const { x , y , box  } = getCanvasPosition(event, canvas);
        const xOffset = paddings.left + (box && borders.left);
        const yOffset = paddings.top + (box && borders.top);
        let { width , height  } = chart;
        if (borderBox) {
            width -= paddings.width + borders.width;
            height -= paddings.height + borders.height;
        }
        return {
            x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),
            y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)
        };
    }
    function getContainerSize(canvas, width, height) {
        let maxWidth, maxHeight;
        if (width === undefined || height === undefined) {
            const container = canvas && _getParentNode(canvas);
            if (!container) {
                width = canvas.clientWidth;
                height = canvas.clientHeight;
            } else {
                const rect = container.getBoundingClientRect(); // this is the border box of the container
                const containerStyle = getComputedStyle(container);
                const containerBorder = getPositionedStyle(containerStyle, 'border', 'width');
                const containerPadding = getPositionedStyle(containerStyle, 'padding');
                width = rect.width - containerPadding.width - containerBorder.width;
                height = rect.height - containerPadding.height - containerBorder.height;
                maxWidth = parseMaxStyle(containerStyle.maxWidth, container, 'clientWidth');
                maxHeight = parseMaxStyle(containerStyle.maxHeight, container, 'clientHeight');
            }
        }
        return {
            width,
            height,
            maxWidth: maxWidth || INFINITY,
            maxHeight: maxHeight || INFINITY
        };
    }
    const round1 = (v)=>Math.round(v * 10) / 10;
    // eslint-disable-next-line complexity
    function getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {
        const style = getComputedStyle(canvas);
        const margins = getPositionedStyle(style, 'margin');
        const maxWidth = parseMaxStyle(style.maxWidth, canvas, 'clientWidth') || INFINITY;
        const maxHeight = parseMaxStyle(style.maxHeight, canvas, 'clientHeight') || INFINITY;
        const containerSize = getContainerSize(canvas, bbWidth, bbHeight);
        let { width , height  } = containerSize;
        if (style.boxSizing === 'content-box') {
            const borders = getPositionedStyle(style, 'border', 'width');
            const paddings = getPositionedStyle(style, 'padding');
            width -= paddings.width + borders.width;
            height -= paddings.height + borders.height;
        }
        width = Math.max(0, width - margins.width);
        height = Math.max(0, aspectRatio ? width / aspectRatio : height - margins.height);
        width = round1(Math.min(width, maxWidth, containerSize.maxWidth));
        height = round1(Math.min(height, maxHeight, containerSize.maxHeight));
        if (width && !height) {
            // https://github.com/chartjs/Chart.js/issues/4659
            // If the canvas has width, but no height, default to aspectRatio of 2 (canvas default)
            height = round1(width / 2);
        }
        const maintainHeight = bbWidth !== undefined || bbHeight !== undefined;
        if (maintainHeight && aspectRatio && containerSize.height && height > containerSize.height) {
            height = containerSize.height;
            width = round1(Math.floor(height * aspectRatio));
        }
        return {
            width,
            height
        };
    }
    /**
     * @param chart
     * @param forceRatio
     * @param forceStyle
     * @returns True if the canvas context size or transformation has changed.
     */ function retinaScale(chart, forceRatio, forceStyle) {
        const pixelRatio = forceRatio || 1;
        const deviceHeight = Math.floor(chart.height * pixelRatio);
        const deviceWidth = Math.floor(chart.width * pixelRatio);
        chart.height = Math.floor(chart.height);
        chart.width = Math.floor(chart.width);
        const canvas = chart.canvas;
        // If no style has been set on the canvas, the render size is used as display size,
        // making the chart visually bigger, so let's enforce it to the "correct" values.
        // See https://github.com/chartjs/Chart.js/issues/3575
        if (canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width)) {
            canvas.style.height = `${chart.height}px`;
            canvas.style.width = `${chart.width}px`;
        }
        if (chart.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) {
            chart.currentDevicePixelRatio = pixelRatio;
            canvas.height = deviceHeight;
            canvas.width = deviceWidth;
            chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
            return true;
        }
        return false;
    }
    /**
     * Detects support for options object argument in addEventListener.
     * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support
     * @private
     */ const supportsEventListenerOptions = function() {
        let passiveSupported = false;
        try {
            const options = {
                get passive () {
                    passiveSupported = true;
                    return false;
                }
            };
            if (_isDomSupported()) {
                window.addEventListener('test', null, options);
                window.removeEventListener('test', null, options);
            }
        } catch (e) {
        // continue regardless of error
        }
        return passiveSupported;
    }();
    /**
     * The "used" size is the final value of a dimension property after all calculations have
     * been performed. This method uses the computed style of `element` but returns undefined
     * if the computed style is not expressed in pixels. That can happen in some cases where
     * `element` has a size relative to its parent and this last one is not yet displayed,
     * for example because of `display: none` on a parent node.
     * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value
     * @returns Size in pixels or undefined if unknown.
     */ function readUsedSize(element, property) {
        const value = getStyle(element, property);
        const matches = value && value.match(/^(\d+)(\.\d+)?px$/);
        return matches ? +matches[1] : undefined;
    }

    /**
     * @private
     */ function _pointInLine(p1, p2, t, mode) {
        return {
            x: p1.x + t * (p2.x - p1.x),
            y: p1.y + t * (p2.y - p1.y)
        };
    }
    /**
     * @private
     */ function _steppedInterpolation(p1, p2, t, mode) {
        return {
            x: p1.x + t * (p2.x - p1.x),
            y: mode === 'middle' ? t < 0.5 ? p1.y : p2.y : mode === 'after' ? t < 1 ? p1.y : p2.y : t > 0 ? p2.y : p1.y
        };
    }
    /**
     * @private
     */ function _bezierInterpolation(p1, p2, t, mode) {
        const cp1 = {
            x: p1.cp2x,
            y: p1.cp2y
        };
        const cp2 = {
            x: p2.cp1x,
            y: p2.cp1y
        };
        const a = _pointInLine(p1, cp1, t);
        const b = _pointInLine(cp1, cp2, t);
        const c = _pointInLine(cp2, p2, t);
        const d = _pointInLine(a, b, t);
        const e = _pointInLine(b, c, t);
        return _pointInLine(d, e, t);
    }

    const getRightToLeftAdapter = function(rectX, width) {
        return {
            x (x) {
                return rectX + rectX + width - x;
            },
            setWidth (w) {
                width = w;
            },
            textAlign (align) {
                if (align === 'center') {
                    return align;
                }
                return align === 'right' ? 'left' : 'right';
            },
            xPlus (x, value) {
                return x - value;
            },
            leftForLtr (x, itemWidth) {
                return x - itemWidth;
            }
        };
    };
    const getLeftToRightAdapter = function() {
        return {
            x (x) {
                return x;
            },
            setWidth (w) {},
            textAlign (align) {
                return align;
            },
            xPlus (x, value) {
                return x + value;
            },
            leftForLtr (x, _itemWidth) {
                return x;
            }
        };
    };
    function getRtlAdapter(rtl, rectX, width) {
        return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();
    }
    function overrideTextDirection(ctx, direction) {
        let style, original;
        if (direction === 'ltr' || direction === 'rtl') {
            style = ctx.canvas.style;
            original = [
                style.getPropertyValue('direction'),
                style.getPropertyPriority('direction')
            ];
            style.setProperty('direction', direction, 'important');
            ctx.prevTextDirection = original;
        }
    }
    function restoreTextDirection(ctx, original) {
        if (original !== undefined) {
            delete ctx.prevTextDirection;
            ctx.canvas.style.setProperty('direction', original[0], original[1]);
        }
    }

    function propertyFn(property) {
        if (property === 'angle') {
            return {
                between: _angleBetween,
                compare: _angleDiff,
                normalize: _normalizeAngle
            };
        }
        return {
            between: _isBetween,
            compare: (a, b)=>a - b,
            normalize: (x)=>x
        };
    }
    function normalizeSegment({ start , end , count , loop , style  }) {
        return {
            start: start % count,
            end: end % count,
            loop: loop && (end - start + 1) % count === 0,
            style
        };
    }
    function getSegment(segment, points, bounds) {
        const { property , start: startBound , end: endBound  } = bounds;
        const { between , normalize  } = propertyFn(property);
        const count = points.length;
        let { start , end , loop  } = segment;
        let i, ilen;
        if (loop) {
            start += count;
            end += count;
            for(i = 0, ilen = count; i < ilen; ++i){
                if (!between(normalize(points[start % count][property]), startBound, endBound)) {
                    break;
                }
                start--;
                end--;
            }
            start %= count;
            end %= count;
        }
        if (end < start) {
            end += count;
        }
        return {
            start,
            end,
            loop,
            style: segment.style
        };
    }
     function _boundSegment(segment, points, bounds) {
        if (!bounds) {
            return [
                segment
            ];
        }
        const { property , start: startBound , end: endBound  } = bounds;
        const count = points.length;
        const { compare , between , normalize  } = propertyFn(property);
        const { start , end , loop , style  } = getSegment(segment, points, bounds);
        const result = [];
        let inside = false;
        let subStart = null;
        let value, point, prevValue;
        const startIsBefore = ()=>between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;
        const endIsBefore = ()=>compare(endBound, value) === 0 || between(endBound, prevValue, value);
        const shouldStart = ()=>inside || startIsBefore();
        const shouldStop = ()=>!inside || endIsBefore();
        for(let i = start, prev = start; i <= end; ++i){
            point = points[i % count];
            if (point.skip) {
                continue;
            }
            value = normalize(point[property]);
            if (value === prevValue) {
                continue;
            }
            inside = between(value, startBound, endBound);
            if (subStart === null && shouldStart()) {
                subStart = compare(value, startBound) === 0 ? i : prev;
            }
            if (subStart !== null && shouldStop()) {
                result.push(normalizeSegment({
                    start: subStart,
                    end: i,
                    loop,
                    count,
                    style
                }));
                subStart = null;
            }
            prev = i;
            prevValue = value;
        }
        if (subStart !== null) {
            result.push(normalizeSegment({
                start: subStart,
                end,
                loop,
                count,
                style
            }));
        }
        return result;
    }
     function _boundSegments(line, bounds) {
        const result = [];
        const segments = line.segments;
        for(let i = 0; i < segments.length; i++){
            const sub = _boundSegment(segments[i], line.points, bounds);
            if (sub.length) {
                result.push(...sub);
            }
        }
        return result;
    }
     function findStartAndEnd(points, count, loop, spanGaps) {
        let start = 0;
        let end = count - 1;
        if (loop && !spanGaps) {
            while(start < count && !points[start].skip){
                start++;
            }
        }
        while(start < count && points[start].skip){
            start++;
        }
        start %= count;
        if (loop) {
            end += start;
        }
        while(end > start && points[end % count].skip){
            end--;
        }
        end %= count;
        return {
            start,
            end
        };
    }
     function solidSegments(points, start, max, loop) {
        const count = points.length;
        const result = [];
        let last = start;
        let prev = points[start];
        let end;
        for(end = start + 1; end <= max; ++end){
            const cur = points[end % count];
            if (cur.skip || cur.stop) {
                if (!prev.skip) {
                    loop = false;
                    result.push({
                        start: start % count,
                        end: (end - 1) % count,
                        loop
                    });
                    start = last = cur.stop ? end : null;
                }
            } else {
                last = end;
                if (prev.skip) {
                    start = end;
                }
            }
            prev = cur;
        }
        if (last !== null) {
            result.push({
                start: start % count,
                end: last % count,
                loop
            });
        }
        return result;
    }
     function _computeSegments(line, segmentOptions) {
        const points = line.points;
        const spanGaps = line.options.spanGaps;
        const count = points.length;
        if (!count) {
            return [];
        }
        const loop = !!line._loop;
        const { start , end  } = findStartAndEnd(points, count, loop, spanGaps);
        if (spanGaps === true) {
            return splitByStyles(line, [
                {
                    start,
                    end,
                    loop
                }
            ], points, segmentOptions);
        }
        const max = end < start ? end + count : end;
        const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;
        return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);
    }
     function splitByStyles(line, segments, points, segmentOptions) {
        if (!segmentOptions || !segmentOptions.setContext || !points) {
            return segments;
        }
        return doSplitByStyles(line, segments, points, segmentOptions);
    }
     function doSplitByStyles(line, segments, points, segmentOptions) {
        const chartContext = line._chart.getContext();
        const baseStyle = readStyle(line.options);
        const { _datasetIndex: datasetIndex , options: { spanGaps  }  } = line;
        const count = points.length;
        const result = [];
        let prevStyle = baseStyle;
        let start = segments[0].start;
        let i = start;
        function addStyle(s, e, l, st) {
            const dir = spanGaps ? -1 : 1;
            if (s === e) {
                return;
            }
            s += count;
            while(points[s % count].skip){
                s -= dir;
            }
            while(points[e % count].skip){
                e += dir;
            }
            if (s % count !== e % count) {
                result.push({
                    start: s % count,
                    end: e % count,
                    loop: l,
                    style: st
                });
                prevStyle = st;
                start = e % count;
            }
        }
        for (const segment of segments){
            start = spanGaps ? start : segment.start;
            let prev = points[start % count];
            let style;
            for(i = start + 1; i <= segment.end; i++){
                const pt = points[i % count];
                style = readStyle(segmentOptions.setContext(createContext(chartContext, {
                    type: 'segment',
                    p0: prev,
                    p1: pt,
                    p0DataIndex: (i - 1) % count,
                    p1DataIndex: i % count,
                    datasetIndex
                })));
                if (styleChanged(style, prevStyle)) {
                    addStyle(start, i - 1, segment.loop, prevStyle);
                }
                prev = pt;
                prevStyle = style;
            }
            if (start < i - 1) {
                addStyle(start, i - 1, segment.loop, prevStyle);
            }
        }
        return result;
    }
    function readStyle(options) {
        return {
            backgroundColor: options.backgroundColor,
            borderCapStyle: options.borderCapStyle,
            borderDash: options.borderDash,
            borderDashOffset: options.borderDashOffset,
            borderJoinStyle: options.borderJoinStyle,
            borderWidth: options.borderWidth,
            borderColor: options.borderColor
        };
    }
    function styleChanged(style, prevStyle) {
        if (!prevStyle) {
            return false;
        }
        const cache = [];
        const replacer = function(key, value) {
            if (!isPatternOrGradient(value)) {
                return value;
            }
            if (!cache.includes(value)) {
                cache.push(value);
            }
            return cache.indexOf(value);
        };
        return JSON.stringify(style, replacer) !== JSON.stringify(prevStyle, replacer);
    }

    /*!
     * Chart.js v4.4.7
     * https://www.chartjs.org
     * (c) 2024 Chart.js Contributors
     * Released under the MIT License
     */

    class Animator {
        constructor(){
            this._request = null;
            this._charts = new Map();
            this._running = false;
            this._lastDate = undefined;
        }
     _notify(chart, anims, date, type) {
            const callbacks = anims.listeners[type];
            const numSteps = anims.duration;
            callbacks.forEach((fn)=>fn({
                    chart,
                    initial: anims.initial,
                    numSteps,
                    currentStep: Math.min(date - anims.start, numSteps)
                }));
        }
     _refresh() {
            if (this._request) {
                return;
            }
            this._running = true;
            this._request = requestAnimFrame.call(window, ()=>{
                this._update();
                this._request = null;
                if (this._running) {
                    this._refresh();
                }
            });
        }
     _update(date = Date.now()) {
            let remaining = 0;
            this._charts.forEach((anims, chart)=>{
                if (!anims.running || !anims.items.length) {
                    return;
                }
                const items = anims.items;
                let i = items.length - 1;
                let draw = false;
                let item;
                for(; i >= 0; --i){
                    item = items[i];
                    if (item._active) {
                        if (item._total > anims.duration) {
                            anims.duration = item._total;
                        }
                        item.tick(date);
                        draw = true;
                    } else {
                        items[i] = items[items.length - 1];
                        items.pop();
                    }
                }
                if (draw) {
                    chart.draw();
                    this._notify(chart, anims, date, 'progress');
                }
                if (!items.length) {
                    anims.running = false;
                    this._notify(chart, anims, date, 'complete');
                    anims.initial = false;
                }
                remaining += items.length;
            });
            this._lastDate = date;
            if (remaining === 0) {
                this._running = false;
            }
        }
     _getAnims(chart) {
            const charts = this._charts;
            let anims = charts.get(chart);
            if (!anims) {
                anims = {
                    running: false,
                    initial: true,
                    items: [],
                    listeners: {
                        complete: [],
                        progress: []
                    }
                };
                charts.set(chart, anims);
            }
            return anims;
        }
     listen(chart, event, cb) {
            this._getAnims(chart).listeners[event].push(cb);
        }
     add(chart, items) {
            if (!items || !items.length) {
                return;
            }
            this._getAnims(chart).items.push(...items);
        }
     has(chart) {
            return this._getAnims(chart).items.length > 0;
        }
     start(chart) {
            const anims = this._charts.get(chart);
            if (!anims) {
                return;
            }
            anims.running = true;
            anims.start = Date.now();
            anims.duration = anims.items.reduce((acc, cur)=>Math.max(acc, cur._duration), 0);
            this._refresh();
        }
        running(chart) {
            if (!this._running) {
                return false;
            }
            const anims = this._charts.get(chart);
            if (!anims || !anims.running || !anims.items.length) {
                return false;
            }
            return true;
        }
     stop(chart) {
            const anims = this._charts.get(chart);
            if (!anims || !anims.items.length) {
                return;
            }
            const items = anims.items;
            let i = items.length - 1;
            for(; i >= 0; --i){
                items[i].cancel();
            }
            anims.items = [];
            this._notify(chart, anims, Date.now(), 'complete');
        }
     remove(chart) {
            return this._charts.delete(chart);
        }
    }
    var animator = /* #__PURE__ */ new Animator();

    const transparent = 'transparent';
    const interpolators = {
        boolean (from, to, factor) {
            return factor > 0.5 ? to : from;
        },
     color (from, to, factor) {
            const c0 = color(from || transparent);
            const c1 = c0.valid && color(to || transparent);
            return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to;
        },
        number (from, to, factor) {
            return from + (to - from) * factor;
        }
    };
    class Animation {
        constructor(cfg, target, prop, to){
            const currentValue = target[prop];
            to = resolve([
                cfg.to,
                to,
                currentValue,
                cfg.from
            ]);
            const from = resolve([
                cfg.from,
                currentValue,
                to
            ]);
            this._active = true;
            this._fn = cfg.fn || interpolators[cfg.type || typeof from];
            this._easing = effects[cfg.easing] || effects.linear;
            this._start = Math.floor(Date.now() + (cfg.delay || 0));
            this._duration = this._total = Math.floor(cfg.duration);
            this._loop = !!cfg.loop;
            this._target = target;
            this._prop = prop;
            this._from = from;
            this._to = to;
            this._promises = undefined;
        }
        active() {
            return this._active;
        }
        update(cfg, to, date) {
            if (this._active) {
                this._notify(false);
                const currentValue = this._target[this._prop];
                const elapsed = date - this._start;
                const remain = this._duration - elapsed;
                this._start = date;
                this._duration = Math.floor(Math.max(remain, cfg.duration));
                this._total += elapsed;
                this._loop = !!cfg.loop;
                this._to = resolve([
                    cfg.to,
                    to,
                    currentValue,
                    cfg.from
                ]);
                this._from = resolve([
                    cfg.from,
                    currentValue,
                    to
                ]);
            }
        }
        cancel() {
            if (this._active) {
                this.tick(Date.now());
                this._active = false;
                this._notify(false);
            }
        }
        tick(date) {
            const elapsed = date - this._start;
            const duration = this._duration;
            const prop = this._prop;
            const from = this._from;
            const loop = this._loop;
            const to = this._to;
            let factor;
            this._active = from !== to && (loop || elapsed < duration);
            if (!this._active) {
                this._target[prop] = to;
                this._notify(true);
                return;
            }
            if (elapsed < 0) {
                this._target[prop] = from;
                return;
            }
            factor = elapsed / duration % 2;
            factor = loop && factor > 1 ? 2 - factor : factor;
            factor = this._easing(Math.min(1, Math.max(0, factor)));
            this._target[prop] = this._fn(from, to, factor);
        }
        wait() {
            const promises = this._promises || (this._promises = []);
            return new Promise((res, rej)=>{
                promises.push({
                    res,
                    rej
                });
            });
        }
        _notify(resolved) {
            const method = resolved ? 'res' : 'rej';
            const promises = this._promises || [];
            for(let i = 0; i < promises.length; i++){
                promises[i][method]();
            }
        }
    }

    class Animations {
        constructor(chart, config){
            this._chart = chart;
            this._properties = new Map();
            this.configure(config);
        }
        configure(config) {
            if (!isObject$1(config)) {
                return;
            }
            const animationOptions = Object.keys(defaults$1.animation);
            const animatedProps = this._properties;
            Object.getOwnPropertyNames(config).forEach((key)=>{
                const cfg = config[key];
                if (!isObject$1(cfg)) {
                    return;
                }
                const resolved = {};
                for (const option of animationOptions){
                    resolved[option] = cfg[option];
                }
                (isArray$1(cfg.properties) && cfg.properties || [
                    key
                ]).forEach((prop)=>{
                    if (prop === key || !animatedProps.has(prop)) {
                        animatedProps.set(prop, resolved);
                    }
                });
            });
        }
     _animateOptions(target, values) {
            const newOptions = values.options;
            const options = resolveTargetOptions(target, newOptions);
            if (!options) {
                return [];
            }
            const animations = this._createAnimations(options, newOptions);
            if (newOptions.$shared) {
                awaitAll(target.options.$animations, newOptions).then(()=>{
                    target.options = newOptions;
                }, ()=>{
                });
            }
            return animations;
        }
     _createAnimations(target, values) {
            const animatedProps = this._properties;
            const animations = [];
            const running = target.$animations || (target.$animations = {});
            const props = Object.keys(values);
            const date = Date.now();
            let i;
            for(i = props.length - 1; i >= 0; --i){
                const prop = props[i];
                if (prop.charAt(0) === '$') {
                    continue;
                }
                if (prop === 'options') {
                    animations.push(...this._animateOptions(target, values));
                    continue;
                }
                const value = values[prop];
                let animation = running[prop];
                const cfg = animatedProps.get(prop);
                if (animation) {
                    if (cfg && animation.active()) {
                        animation.update(cfg, value, date);
                        continue;
                    } else {
                        animation.cancel();
                    }
                }
                if (!cfg || !cfg.duration) {
                    target[prop] = value;
                    continue;
                }
                running[prop] = animation = new Animation(cfg, target, prop, value);
                animations.push(animation);
            }
            return animations;
        }
     update(target, values) {
            if (this._properties.size === 0) {
                Object.assign(target, values);
                return;
            }
            const animations = this._createAnimations(target, values);
            if (animations.length) {
                animator.add(this._chart, animations);
                return true;
            }
        }
    }
    function awaitAll(animations, properties) {
        const running = [];
        const keys = Object.keys(properties);
        for(let i = 0; i < keys.length; i++){
            const anim = animations[keys[i]];
            if (anim && anim.active()) {
                running.push(anim.wait());
            }
        }
        return Promise.all(running);
    }
    function resolveTargetOptions(target, newOptions) {
        if (!newOptions) {
            return;
        }
        let options = target.options;
        if (!options) {
            target.options = newOptions;
            return;
        }
        if (options.$shared) {
            target.options = options = Object.assign({}, options, {
                $shared: false,
                $animations: {}
            });
        }
        return options;
    }

    function scaleClip(scale, allowedOverflow) {
        const opts = scale && scale.options || {};
        const reverse = opts.reverse;
        const min = opts.min === undefined ? allowedOverflow : 0;
        const max = opts.max === undefined ? allowedOverflow : 0;
        return {
            start: reverse ? max : min,
            end: reverse ? min : max
        };
    }
    function defaultClip(xScale, yScale, allowedOverflow) {
        if (allowedOverflow === false) {
            return false;
        }
        const x = scaleClip(xScale, allowedOverflow);
        const y = scaleClip(yScale, allowedOverflow);
        return {
            top: y.end,
            right: x.end,
            bottom: y.start,
            left: x.start
        };
    }
    function toClip(value) {
        let t, r, b, l;
        if (isObject$1(value)) {
            t = value.top;
            r = value.right;
            b = value.bottom;
            l = value.left;
        } else {
            t = r = b = l = value;
        }
        return {
            top: t,
            right: r,
            bottom: b,
            left: l,
            disabled: value === false
        };
    }
    function getSortedDatasetIndices(chart, filterVisible) {
        const keys = [];
        const metasets = chart._getSortedDatasetMetas(filterVisible);
        let i, ilen;
        for(i = 0, ilen = metasets.length; i < ilen; ++i){
            keys.push(metasets[i].index);
        }
        return keys;
    }
    function applyStack(stack, value, dsIndex, options = {}) {
        const keys = stack.keys;
        const singleMode = options.mode === 'single';
        let i, ilen, datasetIndex, otherValue;
        if (value === null) {
            return;
        }
        let found = false;
        for(i = 0, ilen = keys.length; i < ilen; ++i){
            datasetIndex = +keys[i];
            if (datasetIndex === dsIndex) {
                found = true;
                if (options.all) {
                    continue;
                }
                break;
            }
            otherValue = stack.values[datasetIndex];
            if (isNumberFinite(otherValue) && (singleMode || value === 0 || sign(value) === sign(otherValue))) {
                value += otherValue;
            }
        }
        if (!found && !options.all) {
            return 0;
        }
        return value;
    }
    function convertObjectDataToArray(data, meta) {
        const { iScale , vScale  } = meta;
        const iAxisKey = iScale.axis === 'x' ? 'x' : 'y';
        const vAxisKey = vScale.axis === 'x' ? 'x' : 'y';
        const keys = Object.keys(data);
        const adata = new Array(keys.length);
        let i, ilen, key;
        for(i = 0, ilen = keys.length; i < ilen; ++i){
            key = keys[i];
            adata[i] = {
                [iAxisKey]: key,
                [vAxisKey]: data[key]
            };
        }
        return adata;
    }
    function isStacked(scale, meta) {
        const stacked = scale && scale.options.stacked;
        return stacked || stacked === undefined && meta.stack !== undefined;
    }
    function getStackKey(indexScale, valueScale, meta) {
        return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;
    }
    function getUserBounds(scale) {
        const { min , max , minDefined , maxDefined  } = scale.getUserBounds();
        return {
            min: minDefined ? min : Number.NEGATIVE_INFINITY,
            max: maxDefined ? max : Number.POSITIVE_INFINITY
        };
    }
    function getOrCreateStack(stacks, stackKey, indexValue) {
        const subStack = stacks[stackKey] || (stacks[stackKey] = {});
        return subStack[indexValue] || (subStack[indexValue] = {});
    }
    function getLastIndexInStack(stack, vScale, positive, type) {
        for (const meta of vScale.getMatchingVisibleMetas(type).reverse()){
            const value = stack[meta.index];
            if (positive && value > 0 || !positive && value < 0) {
                return meta.index;
            }
        }
        return null;
    }
    function updateStacks(controller, parsed) {
        const { chart , _cachedMeta: meta  } = controller;
        const stacks = chart._stacks || (chart._stacks = {});
        const { iScale , vScale , index: datasetIndex  } = meta;
        const iAxis = iScale.axis;
        const vAxis = vScale.axis;
        const key = getStackKey(iScale, vScale, meta);
        const ilen = parsed.length;
        let stack;
        for(let i = 0; i < ilen; ++i){
            const item = parsed[i];
            const { [iAxis]: index , [vAxis]: value  } = item;
            const itemStacks = item._stacks || (item._stacks = {});
            stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index);
            stack[datasetIndex] = value;
            stack._top = getLastIndexInStack(stack, vScale, true, meta.type);
            stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);
            const visualValues = stack._visualValues || (stack._visualValues = {});
            visualValues[datasetIndex] = value;
        }
    }
    function getFirstScaleId(chart, axis) {
        const scales = chart.scales;
        return Object.keys(scales).filter((key)=>scales[key].axis === axis).shift();
    }
    function createDatasetContext(parent, index) {
        return createContext(parent, {
            active: false,
            dataset: undefined,
            datasetIndex: index,
            index,
            mode: 'default',
            type: 'dataset'
        });
    }
    function createDataContext(parent, index, element) {
        return createContext(parent, {
            active: false,
            dataIndex: index,
            parsed: undefined,
            raw: undefined,
            element,
            index,
            mode: 'default',
            type: 'data'
        });
    }
    function clearStacks(meta, items) {
        const datasetIndex = meta.controller.index;
        const axis = meta.vScale && meta.vScale.axis;
        if (!axis) {
            return;
        }
        items = items || meta._parsed;
        for (const parsed of items){
            const stacks = parsed._stacks;
            if (!stacks || stacks[axis] === undefined || stacks[axis][datasetIndex] === undefined) {
                return;
            }
            delete stacks[axis][datasetIndex];
            if (stacks[axis]._visualValues !== undefined && stacks[axis]._visualValues[datasetIndex] !== undefined) {
                delete stacks[axis]._visualValues[datasetIndex];
            }
        }
    }
    const isDirectUpdateMode = (mode)=>mode === 'reset' || mode === 'none';
    const cloneIfNotShared = (cached, shared)=>shared ? cached : Object.assign({}, cached);
    const createStack = (canStack, meta, chart)=>canStack && !meta.hidden && meta._stacked && {
            keys: getSortedDatasetIndices(chart, true),
            values: null
        };
    class DatasetController {
     static defaults = {};
     static datasetElementType = null;
     static dataElementType = null;
     constructor(chart, datasetIndex){
            this.chart = chart;
            this._ctx = chart.ctx;
            this.index = datasetIndex;
            this._cachedDataOpts = {};
            this._cachedMeta = this.getMeta();
            this._type = this._cachedMeta.type;
            this.options = undefined;
             this._parsing = false;
            this._data = undefined;
            this._objectData = undefined;
            this._sharedOptions = undefined;
            this._drawStart = undefined;
            this._drawCount = undefined;
            this.enableOptionSharing = false;
            this.supportsDecimation = false;
            this.$context = undefined;
            this._syncList = [];
            this.datasetElementType = new.target.datasetElementType;
            this.dataElementType = new.target.dataElementType;
            this.initialize();
        }
        initialize() {
            const meta = this._cachedMeta;
            this.configure();
            this.linkScales();
            meta._stacked = isStacked(meta.vScale, meta);
            this.addElements();
            if (this.options.fill && !this.chart.isPluginEnabled('filler')) {
                console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options");
            }
        }
        updateIndex(datasetIndex) {
            if (this.index !== datasetIndex) {
                clearStacks(this._cachedMeta);
            }
            this.index = datasetIndex;
        }
        linkScales() {
            const chart = this.chart;
            const meta = this._cachedMeta;
            const dataset = this.getDataset();
            const chooseId = (axis, x, y, r)=>axis === 'x' ? x : axis === 'r' ? r : y;
            const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, 'x'));
            const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, 'y'));
            const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, 'r'));
            const indexAxis = meta.indexAxis;
            const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);
            const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);
            meta.xScale = this.getScaleForId(xid);
            meta.yScale = this.getScaleForId(yid);
            meta.rScale = this.getScaleForId(rid);
            meta.iScale = this.getScaleForId(iid);
            meta.vScale = this.getScaleForId(vid);
        }
        getDataset() {
            return this.chart.data.datasets[this.index];
        }
        getMeta() {
            return this.chart.getDatasetMeta(this.index);
        }
     getScaleForId(scaleID) {
            return this.chart.scales[scaleID];
        }
     _getOtherScale(scale) {
            const meta = this._cachedMeta;
            return scale === meta.iScale ? meta.vScale : meta.iScale;
        }
        reset() {
            this._update('reset');
        }
     _destroy() {
            const meta = this._cachedMeta;
            if (this._data) {
                unlistenArrayEvents(this._data, this);
            }
            if (meta._stacked) {
                clearStacks(meta);
            }
        }
     _dataCheck() {
            const dataset = this.getDataset();
            const data = dataset.data || (dataset.data = []);
            const _data = this._data;
            if (isObject$1(data)) {
                const meta = this._cachedMeta;
                this._data = convertObjectDataToArray(data, meta);
            } else if (_data !== data) {
                if (_data) {
                    unlistenArrayEvents(_data, this);
                    const meta = this._cachedMeta;
                    clearStacks(meta);
                    meta._parsed = [];
                }
                if (data && Object.isExtensible(data)) {
                    listenArrayEvents(data, this);
                }
                this._syncList = [];
                this._data = data;
            }
        }
        addElements() {
            const meta = this._cachedMeta;
            this._dataCheck();
            if (this.datasetElementType) {
                meta.dataset = new this.datasetElementType();
            }
        }
        buildOrUpdateElements(resetNewElements) {
            const meta = this._cachedMeta;
            const dataset = this.getDataset();
            let stackChanged = false;
            this._dataCheck();
            const oldStacked = meta._stacked;
            meta._stacked = isStacked(meta.vScale, meta);
            if (meta.stack !== dataset.stack) {
                stackChanged = true;
                clearStacks(meta);
                meta.stack = dataset.stack;
            }
            this._resyncElements(resetNewElements);
            if (stackChanged || oldStacked !== meta._stacked) {
                updateStacks(this, meta._parsed);
                meta._stacked = isStacked(meta.vScale, meta);
            }
        }
     configure() {
            const config = this.chart.config;
            const scopeKeys = config.datasetScopeKeys(this._type);
            const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);
            this.options = config.createResolver(scopes, this.getContext());
            this._parsing = this.options.parsing;
            this._cachedDataOpts = {};
        }
     parse(start, count) {
            const { _cachedMeta: meta , _data: data  } = this;
            const { iScale , _stacked  } = meta;
            const iAxis = iScale.axis;
            let sorted = start === 0 && count === data.length ? true : meta._sorted;
            let prev = start > 0 && meta._parsed[start - 1];
            let i, cur, parsed;
            if (this._parsing === false) {
                meta._parsed = data;
                meta._sorted = true;
                parsed = data;
            } else {
                if (isArray$1(data[start])) {
                    parsed = this.parseArrayData(meta, data, start, count);
                } else if (isObject$1(data[start])) {
                    parsed = this.parseObjectData(meta, data, start, count);
                } else {
                    parsed = this.parsePrimitiveData(meta, data, start, count);
                }
                const isNotInOrderComparedToPrev = ()=>cur[iAxis] === null || prev && cur[iAxis] < prev[iAxis];
                for(i = 0; i < count; ++i){
                    meta._parsed[i + start] = cur = parsed[i];
                    if (sorted) {
                        if (isNotInOrderComparedToPrev()) {
                            sorted = false;
                        }
                        prev = cur;
                    }
                }
                meta._sorted = sorted;
            }
            if (_stacked) {
                updateStacks(this, parsed);
            }
        }
     parsePrimitiveData(meta, data, start, count) {
            const { iScale , vScale  } = meta;
            const iAxis = iScale.axis;
            const vAxis = vScale.axis;
            const labels = iScale.getLabels();
            const singleScale = iScale === vScale;
            const parsed = new Array(count);
            let i, ilen, index;
            for(i = 0, ilen = count; i < ilen; ++i){
                index = i + start;
                parsed[i] = {
                    [iAxis]: singleScale || iScale.parse(labels[index], index),
                    [vAxis]: vScale.parse(data[index], index)
                };
            }
            return parsed;
        }
     parseArrayData(meta, data, start, count) {
            const { xScale , yScale  } = meta;
            const parsed = new Array(count);
            let i, ilen, index, item;
            for(i = 0, ilen = count; i < ilen; ++i){
                index = i + start;
                item = data[index];
                parsed[i] = {
                    x: xScale.parse(item[0], index),
                    y: yScale.parse(item[1], index)
                };
            }
            return parsed;
        }
     parseObjectData(meta, data, start, count) {
            const { xScale , yScale  } = meta;
            const { xAxisKey ='x' , yAxisKey ='y'  } = this._parsing;
            const parsed = new Array(count);
            let i, ilen, index, item;
            for(i = 0, ilen = count; i < ilen; ++i){
                index = i + start;
                item = data[index];
                parsed[i] = {
                    x: xScale.parse(resolveObjectKey(item, xAxisKey), index),
                    y: yScale.parse(resolveObjectKey(item, yAxisKey), index)
                };
            }
            return parsed;
        }
     getParsed(index) {
            return this._cachedMeta._parsed[index];
        }
     getDataElement(index) {
            return this._cachedMeta.data[index];
        }
     applyStack(scale, parsed, mode) {
            const chart = this.chart;
            const meta = this._cachedMeta;
            const value = parsed[scale.axis];
            const stack = {
                keys: getSortedDatasetIndices(chart, true),
                values: parsed._stacks[scale.axis]._visualValues
            };
            return applyStack(stack, value, meta.index, {
                mode
            });
        }
     updateRangeFromParsed(range, scale, parsed, stack) {
            const parsedValue = parsed[scale.axis];
            let value = parsedValue === null ? NaN : parsedValue;
            const values = stack && parsed._stacks[scale.axis];
            if (stack && values) {
                stack.values = values;
                value = applyStack(stack, parsedValue, this._cachedMeta.index);
            }
            range.min = Math.min(range.min, value);
            range.max = Math.max(range.max, value);
        }
     getMinMax(scale, canStack) {
            const meta = this._cachedMeta;
            const _parsed = meta._parsed;
            const sorted = meta._sorted && scale === meta.iScale;
            const ilen = _parsed.length;
            const otherScale = this._getOtherScale(scale);
            const stack = createStack(canStack, meta, this.chart);
            const range = {
                min: Number.POSITIVE_INFINITY,
                max: Number.NEGATIVE_INFINITY
            };
            const { min: otherMin , max: otherMax  } = getUserBounds(otherScale);
            let i, parsed;
            function _skip() {
                parsed = _parsed[i];
                const otherValue = parsed[otherScale.axis];
                return !isNumberFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;
            }
            for(i = 0; i < ilen; ++i){
                if (_skip()) {
                    continue;
                }
                this.updateRangeFromParsed(range, scale, parsed, stack);
                if (sorted) {
                    break;
                }
            }
            if (sorted) {
                for(i = ilen - 1; i >= 0; --i){
                    if (_skip()) {
                        continue;
                    }
                    this.updateRangeFromParsed(range, scale, parsed, stack);
                    break;
                }
            }
            return range;
        }
        getAllParsedValues(scale) {
            const parsed = this._cachedMeta._parsed;
            const values = [];
            let i, ilen, value;
            for(i = 0, ilen = parsed.length; i < ilen; ++i){
                value = parsed[i][scale.axis];
                if (isNumberFinite(value)) {
                    values.push(value);
                }
            }
            return values;
        }
     getMaxOverflow() {
            return false;
        }
     getLabelAndValue(index) {
            const meta = this._cachedMeta;
            const iScale = meta.iScale;
            const vScale = meta.vScale;
            const parsed = this.getParsed(index);
            return {
                label: iScale ? '' + iScale.getLabelForValue(parsed[iScale.axis]) : '',
                value: vScale ? '' + vScale.getLabelForValue(parsed[vScale.axis]) : ''
            };
        }
     _update(mode) {
            const meta = this._cachedMeta;
            this.update(mode || 'default');
            meta._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));
        }
     update(mode) {}
        draw() {
            const ctx = this._ctx;
            const chart = this.chart;
            const meta = this._cachedMeta;
            const elements = meta.data || [];
            const area = chart.chartArea;
            const active = [];
            const start = this._drawStart || 0;
            const count = this._drawCount || elements.length - start;
            const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;
            let i;
            if (meta.dataset) {
                meta.dataset.draw(ctx, area, start, count);
            }
            for(i = start; i < start + count; ++i){
                const element = elements[i];
                if (element.hidden) {
                    continue;
                }
                if (element.active && drawActiveElementsOnTop) {
                    active.push(element);
                } else {
                    element.draw(ctx, area);
                }
            }
            for(i = 0; i < active.length; ++i){
                active[i].draw(ctx, area);
            }
        }
     getStyle(index, active) {
            const mode = active ? 'active' : 'default';
            return index === undefined && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode) : this.resolveDataElementOptions(index || 0, mode);
        }
     getContext(index, active, mode) {
            const dataset = this.getDataset();
            let context;
            if (index >= 0 && index < this._cachedMeta.data.length) {
                const element = this._cachedMeta.data[index];
                context = element.$context || (element.$context = createDataContext(this.getContext(), index, element));
                context.parsed = this.getParsed(index);
                context.raw = dataset.data[index];
                context.index = context.dataIndex = index;
            } else {
                context = this.$context || (this.$context = createDatasetContext(this.chart.getContext(), this.index));
                context.dataset = dataset;
                context.index = context.datasetIndex = this.index;
            }
            context.active = !!active;
            context.mode = mode;
            return context;
        }
     resolveDatasetElementOptions(mode) {
            return this._resolveElementOptions(this.datasetElementType.id, mode);
        }
     resolveDataElementOptions(index, mode) {
            return this._resolveElementOptions(this.dataElementType.id, mode, index);
        }
     _resolveElementOptions(elementType, mode = 'default', index) {
            const active = mode === 'active';
            const cache = this._cachedDataOpts;
            const cacheKey = elementType + '-' + mode;
            const cached = cache[cacheKey];
            const sharing = this.enableOptionSharing && defined(index);
            if (cached) {
                return cloneIfNotShared(cached, sharing);
            }
            const config = this.chart.config;
            const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);
            const prefixes = active ? [
                `${elementType}Hover`,
                'hover',
                elementType,
                ''
            ] : [
                elementType,
                ''
            ];
            const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
            const names = Object.keys(defaults$1.elements[elementType]);
            const context = ()=>this.getContext(index, active, mode);
            const values = config.resolveNamedOptions(scopes, names, context, prefixes);
            if (values.$shared) {
                values.$shared = sharing;
                cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));
            }
            return values;
        }
     _resolveAnimations(index, transition, active) {
            const chart = this.chart;
            const cache = this._cachedDataOpts;
            const cacheKey = `animation-${transition}`;
            const cached = cache[cacheKey];
            if (cached) {
                return cached;
            }
            let options;
            if (chart.options.animation !== false) {
                const config = this.chart.config;
                const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);
                const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
                options = config.createResolver(scopes, this.getContext(index, active, transition));
            }
            const animations = new Animations(chart, options && options.animations);
            if (options && options._cacheable) {
                cache[cacheKey] = Object.freeze(animations);
            }
            return animations;
        }
     getSharedOptions(options) {
            if (!options.$shared) {
                return;
            }
            return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));
        }
     includeOptions(mode, sharedOptions) {
            return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;
        }
     _getSharedOptions(start, mode) {
            const firstOpts = this.resolveDataElementOptions(start, mode);
            const previouslySharedOptions = this._sharedOptions;
            const sharedOptions = this.getSharedOptions(firstOpts);
            const includeOptions = this.includeOptions(mode, sharedOptions) || sharedOptions !== previouslySharedOptions;
            this.updateSharedOptions(sharedOptions, mode, firstOpts);
            return {
                sharedOptions,
                includeOptions
            };
        }
     updateElement(element, index, properties, mode) {
            if (isDirectUpdateMode(mode)) {
                Object.assign(element, properties);
            } else {
                this._resolveAnimations(index, mode).update(element, properties);
            }
        }
     updateSharedOptions(sharedOptions, mode, newOptions) {
            if (sharedOptions && !isDirectUpdateMode(mode)) {
                this._resolveAnimations(undefined, mode).update(sharedOptions, newOptions);
            }
        }
     _setStyle(element, index, mode, active) {
            element.active = active;
            const options = this.getStyle(index, active);
            this._resolveAnimations(index, mode, active).update(element, {
                options: !active && this.getSharedOptions(options) || options
            });
        }
        removeHoverStyle(element, datasetIndex, index) {
            this._setStyle(element, index, 'active', false);
        }
        setHoverStyle(element, datasetIndex, index) {
            this._setStyle(element, index, 'active', true);
        }
     _removeDatasetHoverStyle() {
            const element = this._cachedMeta.dataset;
            if (element) {
                this._setStyle(element, undefined, 'active', false);
            }
        }
     _setDatasetHoverStyle() {
            const element = this._cachedMeta.dataset;
            if (element) {
                this._setStyle(element, undefined, 'active', true);
            }
        }
     _resyncElements(resetNewElements) {
            const data = this._data;
            const elements = this._cachedMeta.data;
            for (const [method, arg1, arg2] of this._syncList){
                this[method](arg1, arg2);
            }
            this._syncList = [];
            const numMeta = elements.length;
            const numData = data.length;
            const count = Math.min(numData, numMeta);
            if (count) {
                this.parse(0, count);
            }
            if (numData > numMeta) {
                this._insertElements(numMeta, numData - numMeta, resetNewElements);
            } else if (numData < numMeta) {
                this._removeElements(numData, numMeta - numData);
            }
        }
     _insertElements(start, count, resetNewElements = true) {
            const meta = this._cachedMeta;
            const data = meta.data;
            const end = start + count;
            let i;
            const move = (arr)=>{
                arr.length += count;
                for(i = arr.length - 1; i >= end; i--){
                    arr[i] = arr[i - count];
                }
            };
            move(data);
            for(i = start; i < end; ++i){
                data[i] = new this.dataElementType();
            }
            if (this._parsing) {
                move(meta._parsed);
            }
            this.parse(start, count);
            if (resetNewElements) {
                this.updateElements(data, start, count, 'reset');
            }
        }
        updateElements(element, start, count, mode) {}
     _removeElements(start, count) {
            const meta = this._cachedMeta;
            if (this._parsing) {
                const removed = meta._parsed.splice(start, count);
                if (meta._stacked) {
                    clearStacks(meta, removed);
                }
            }
            meta.data.splice(start, count);
        }
     _sync(args) {
            if (this._parsing) {
                this._syncList.push(args);
            } else {
                const [method, arg1, arg2] = args;
                this[method](arg1, arg2);
            }
            this.chart._dataChanges.push([
                this.index,
                ...args
            ]);
        }
        _onDataPush() {
            const count = arguments.length;
            this._sync([
                '_insertElements',
                this.getDataset().data.length - count,
                count
            ]);
        }
        _onDataPop() {
            this._sync([
                '_removeElements',
                this._cachedMeta.data.length - 1,
                1
            ]);
        }
        _onDataShift() {
            this._sync([
                '_removeElements',
                0,
                1
            ]);
        }
        _onDataSplice(start, count) {
            if (count) {
                this._sync([
                    '_removeElements',
                    start,
                    count
                ]);
            }
            const newCount = arguments.length - 2;
            if (newCount) {
                this._sync([
                    '_insertElements',
                    start,
                    newCount
                ]);
            }
        }
        _onDataUnshift() {
            this._sync([
                '_insertElements',
                0,
                arguments.length
            ]);
        }
    }

    function getAllScaleValues(scale, type) {
        if (!scale._cache.$bar) {
            const visibleMetas = scale.getMatchingVisibleMetas(type);
            let values = [];
            for(let i = 0, ilen = visibleMetas.length; i < ilen; i++){
                values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));
            }
            scale._cache.$bar = _arrayUnique(values.sort((a, b)=>a - b));
        }
        return scale._cache.$bar;
    }
     function computeMinSampleSize(meta) {
        const scale = meta.iScale;
        const values = getAllScaleValues(scale, meta.type);
        let min = scale._length;
        let i, ilen, curr, prev;
        const updateMinAndPrev = ()=>{
            if (curr === 32767 || curr === -32768) {
                return;
            }
            if (defined(prev)) {
                min = Math.min(min, Math.abs(curr - prev) || min);
            }
            prev = curr;
        };
        for(i = 0, ilen = values.length; i < ilen; ++i){
            curr = scale.getPixelForValue(values[i]);
            updateMinAndPrev();
        }
        prev = undefined;
        for(i = 0, ilen = scale.ticks.length; i < ilen; ++i){
            curr = scale.getPixelForTick(i);
            updateMinAndPrev();
        }
        return min;
    }
     function computeFitCategoryTraits(index, ruler, options, stackCount) {
        const thickness = options.barThickness;
        let size, ratio;
        if (isNullOrUndef(thickness)) {
            size = ruler.min * options.categoryPercentage;
            ratio = options.barPercentage;
        } else {
            size = thickness * stackCount;
            ratio = 1;
        }
        return {
            chunk: size / stackCount,
            ratio,
            start: ruler.pixels[index] - size / 2
        };
    }
     function computeFlexCategoryTraits(index, ruler, options, stackCount) {
        const pixels = ruler.pixels;
        const curr = pixels[index];
        let prev = index > 0 ? pixels[index - 1] : null;
        let next = index < pixels.length - 1 ? pixels[index + 1] : null;
        const percent = options.categoryPercentage;
        if (prev === null) {
            prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
        }
        if (next === null) {
            next = curr + curr - prev;
        }
        const start = curr - (curr - Math.min(prev, next)) / 2 * percent;
        const size = Math.abs(next - prev) / 2 * percent;
        return {
            chunk: size / stackCount,
            ratio: options.barPercentage,
            start
        };
    }
    function parseFloatBar(entry, item, vScale, i) {
        const startValue = vScale.parse(entry[0], i);
        const endValue = vScale.parse(entry[1], i);
        const min = Math.min(startValue, endValue);
        const max = Math.max(startValue, endValue);
        let barStart = min;
        let barEnd = max;
        if (Math.abs(min) > Math.abs(max)) {
            barStart = max;
            barEnd = min;
        }
        item[vScale.axis] = barEnd;
        item._custom = {
            barStart,
            barEnd,
            start: startValue,
            end: endValue,
            min,
            max
        };
    }
    function parseValue(entry, item, vScale, i) {
        if (isArray$1(entry)) {
            parseFloatBar(entry, item, vScale, i);
        } else {
            item[vScale.axis] = vScale.parse(entry, i);
        }
        return item;
    }
    function parseArrayOrPrimitive(meta, data, start, count) {
        const iScale = meta.iScale;
        const vScale = meta.vScale;
        const labels = iScale.getLabels();
        const singleScale = iScale === vScale;
        const parsed = [];
        let i, ilen, item, entry;
        for(i = start, ilen = start + count; i < ilen; ++i){
            entry = data[i];
            item = {};
            item[iScale.axis] = singleScale || iScale.parse(labels[i], i);
            parsed.push(parseValue(entry, item, vScale, i));
        }
        return parsed;
    }
    function isFloatBar(custom) {
        return custom && custom.barStart !== undefined && custom.barEnd !== undefined;
    }
    function barSign(size, vScale, actualBase) {
        if (size !== 0) {
            return sign(size);
        }
        return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);
    }
    function borderProps(properties) {
        let reverse, start, end, top, bottom;
        if (properties.horizontal) {
            reverse = properties.base > properties.x;
            start = 'left';
            end = 'right';
        } else {
            reverse = properties.base < properties.y;
            start = 'bottom';
            end = 'top';
        }
        if (reverse) {
            top = 'end';
            bottom = 'start';
        } else {
            top = 'start';
            bottom = 'end';
        }
        return {
            start,
            end,
            reverse,
            top,
            bottom
        };
    }
    function setBorderSkipped(properties, options, stack, index) {
        let edge = options.borderSkipped;
        const res = {};
        if (!edge) {
            properties.borderSkipped = res;
            return;
        }
        if (edge === true) {
            properties.borderSkipped = {
                top: true,
                right: true,
                bottom: true,
                left: true
            };
            return;
        }
        const { start , end , reverse , top , bottom  } = borderProps(properties);
        if (edge === 'middle' && stack) {
            properties.enableBorderRadius = true;
            if ((stack._top || 0) === index) {
                edge = top;
            } else if ((stack._bottom || 0) === index) {
                edge = bottom;
            } else {
                res[parseEdge(bottom, start, end, reverse)] = true;
                edge = top;
            }
        }
        res[parseEdge(edge, start, end, reverse)] = true;
        properties.borderSkipped = res;
    }
    function parseEdge(edge, a, b, reverse) {
        if (reverse) {
            edge = swap(edge, a, b);
            edge = startEnd(edge, b, a);
        } else {
            edge = startEnd(edge, a, b);
        }
        return edge;
    }
    function swap(orig, v1, v2) {
        return orig === v1 ? v2 : orig === v2 ? v1 : orig;
    }
    function startEnd(v, start, end) {
        return v === 'start' ? start : v === 'end' ? end : v;
    }
    function setInflateAmount(properties, { inflateAmount  }, ratio) {
        properties.inflateAmount = inflateAmount === 'auto' ? ratio === 1 ? 0.33 : 0 : inflateAmount;
    }
    class BarController extends DatasetController {
        static id = 'bar';
     static defaults = {
            datasetElementType: false,
            dataElementType: 'bar',
            categoryPercentage: 0.8,
            barPercentage: 0.9,
            grouped: true,
            animations: {
                numbers: {
                    type: 'number',
                    properties: [
                        'x',
                        'y',
                        'base',
                        'width',
                        'height'
                    ]
                }
            }
        };
     static overrides = {
            scales: {
                _index_: {
                    type: 'category',
                    offset: true,
                    grid: {
                        offset: true
                    }
                },
                _value_: {
                    type: 'linear',
                    beginAtZero: true
                }
            }
        };
     parsePrimitiveData(meta, data, start, count) {
            return parseArrayOrPrimitive(meta, data, start, count);
        }
     parseArrayData(meta, data, start, count) {
            return parseArrayOrPrimitive(meta, data, start, count);
        }
     parseObjectData(meta, data, start, count) {
            const { iScale , vScale  } = meta;
            const { xAxisKey ='x' , yAxisKey ='y'  } = this._parsing;
            const iAxisKey = iScale.axis === 'x' ? xAxisKey : yAxisKey;
            const vAxisKey = vScale.axis === 'x' ? xAxisKey : yAxisKey;
            const parsed = [];
            let i, ilen, item, obj;
            for(i = start, ilen = start + count; i < ilen; ++i){
                obj = data[i];
                item = {};
                item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i);
                parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i));
            }
            return parsed;
        }
     updateRangeFromParsed(range, scale, parsed, stack) {
            super.updateRangeFromParsed(range, scale, parsed, stack);
            const custom = parsed._custom;
            if (custom && scale === this._cachedMeta.vScale) {
                range.min = Math.min(range.min, custom.min);
                range.max = Math.max(range.max, custom.max);
            }
        }
     getMaxOverflow() {
            return 0;
        }
     getLabelAndValue(index) {
            const meta = this._cachedMeta;
            const { iScale , vScale  } = meta;
            const parsed = this.getParsed(index);
            const custom = parsed._custom;
            const value = isFloatBar(custom) ? '[' + custom.start + ', ' + custom.end + ']' : '' + vScale.getLabelForValue(parsed[vScale.axis]);
            return {
                label: '' + iScale.getLabelForValue(parsed[iScale.axis]),
                value
            };
        }
        initialize() {
            this.enableOptionSharing = true;
            super.initialize();
            const meta = this._cachedMeta;
            meta.stack = this.getDataset().stack;
        }
        update(mode) {
            const meta = this._cachedMeta;
            this.updateElements(meta.data, 0, meta.data.length, mode);
        }
        updateElements(bars, start, count, mode) {
            const reset = mode === 'reset';
            const { index , _cachedMeta: { vScale  }  } = this;
            const base = vScale.getBasePixel();
            const horizontal = vScale.isHorizontal();
            const ruler = this._getRuler();
            const { sharedOptions , includeOptions  } = this._getSharedOptions(start, mode);
            for(let i = start; i < start + count; i++){
                const parsed = this.getParsed(i);
                const vpixels = reset || isNullOrUndef(parsed[vScale.axis]) ? {
                    base,
                    head: base
                } : this._calculateBarValuePixels(i);
                const ipixels = this._calculateBarIndexPixels(i, ruler);
                const stack = (parsed._stacks || {})[vScale.axis];
                const properties = {
                    horizontal,
                    base: vpixels.base,
                    enableBorderRadius: !stack || isFloatBar(parsed._custom) || index === stack._top || index === stack._bottom,
                    x: horizontal ? vpixels.head : ipixels.center,
                    y: horizontal ? ipixels.center : vpixels.head,
                    height: horizontal ? ipixels.size : Math.abs(vpixels.size),
                    width: horizontal ? Math.abs(vpixels.size) : ipixels.size
                };
                if (includeOptions) {
                    properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? 'active' : mode);
                }
                const options = properties.options || bars[i].options;
                setBorderSkipped(properties, options, stack, index);
                setInflateAmount(properties, options, ruler.ratio);
                this.updateElement(bars[i], i, properties, mode);
            }
        }
     _getStacks(last, dataIndex) {
            const { iScale  } = this._cachedMeta;
            const metasets = iScale.getMatchingVisibleMetas(this._type).filter((meta)=>meta.controller.options.grouped);
            const stacked = iScale.options.stacked;
            const stacks = [];
            const currentParsed = this._cachedMeta.controller.getParsed(dataIndex);
            const iScaleValue = currentParsed && currentParsed[iScale.axis];
            const skipNull = (meta)=>{
                const parsed = meta._parsed.find((item)=>item[iScale.axis] === iScaleValue);
                const val = parsed && parsed[meta.vScale.axis];
                if (isNullOrUndef(val) || isNaN(val)) {
                    return true;
                }
            };
            for (const meta of metasets){
                if (dataIndex !== undefined && skipNull(meta)) {
                    continue;
                }
                if (stacked === false || stacks.indexOf(meta.stack) === -1 || stacked === undefined && meta.stack === undefined) {
                    stacks.push(meta.stack);
                }
                if (meta.index === last) {
                    break;
                }
            }
            if (!stacks.length) {
                stacks.push(undefined);
            }
            return stacks;
        }
     _getStackCount(index) {
            return this._getStacks(undefined, index).length;
        }
     _getStackIndex(datasetIndex, name, dataIndex) {
            const stacks = this._getStacks(datasetIndex, dataIndex);
            const index = name !== undefined ? stacks.indexOf(name) : -1;
            return index === -1 ? stacks.length - 1 : index;
        }
     _getRuler() {
            const opts = this.options;
            const meta = this._cachedMeta;
            const iScale = meta.iScale;
            const pixels = [];
            let i, ilen;
            for(i = 0, ilen = meta.data.length; i < ilen; ++i){
                pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));
            }
            const barThickness = opts.barThickness;
            const min = barThickness || computeMinSampleSize(meta);
            return {
                min,
                pixels,
                start: iScale._startPixel,
                end: iScale._endPixel,
                stackCount: this._getStackCount(),
                scale: iScale,
                grouped: opts.grouped,
                ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage
            };
        }
     _calculateBarValuePixels(index) {
            const { _cachedMeta: { vScale , _stacked , index: datasetIndex  } , options: { base: baseValue , minBarLength  }  } = this;
            const actualBase = baseValue || 0;
            const parsed = this.getParsed(index);
            const custom = parsed._custom;
            const floating = isFloatBar(custom);
            let value = parsed[vScale.axis];
            let start = 0;
            let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;
            let head, size;
            if (length !== value) {
                start = length - value;
                length = value;
            }
            if (floating) {
                value = custom.barStart;
                length = custom.barEnd - custom.barStart;
                if (value !== 0 && sign(value) !== sign(custom.barEnd)) {
                    start = 0;
                }
                start += value;
            }
            const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start;
            let base = vScale.getPixelForValue(startValue);
            if (this.chart.getDataVisibility(index)) {
                head = vScale.getPixelForValue(start + length);
            } else {
                head = base;
            }
            size = head - base;
            if (Math.abs(size) < minBarLength) {
                size = barSign(size, vScale, actualBase) * minBarLength;
                if (value === actualBase) {
                    base -= size / 2;
                }
                const startPixel = vScale.getPixelForDecimal(0);
                const endPixel = vScale.getPixelForDecimal(1);
                const min = Math.min(startPixel, endPixel);
                const max = Math.max(startPixel, endPixel);
                base = Math.max(Math.min(base, max), min);
                head = base + size;
                if (_stacked && !floating) {
                    parsed._stacks[vScale.axis]._visualValues[datasetIndex] = vScale.getValueForPixel(head) - vScale.getValueForPixel(base);
                }
            }
            if (base === vScale.getPixelForValue(actualBase)) {
                const halfGrid = sign(size) * vScale.getLineWidthForValue(actualBase) / 2;
                base += halfGrid;
                size -= halfGrid;
            }
            return {
                size,
                base,
                head,
                center: head + size / 2
            };
        }
     _calculateBarIndexPixels(index, ruler) {
            const scale = ruler.scale;
            const options = this.options;
            const skipNull = options.skipNull;
            const maxBarThickness = valueOrDefault(options.maxBarThickness, Infinity);
            let center, size;
            if (ruler.grouped) {
                const stackCount = skipNull ? this._getStackCount(index) : ruler.stackCount;
                const range = options.barThickness === 'flex' ? computeFlexCategoryTraits(index, ruler, options, stackCount) : computeFitCategoryTraits(index, ruler, options, stackCount);
                const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index : undefined);
                center = range.start + range.chunk * stackIndex + range.chunk / 2;
                size = Math.min(maxBarThickness, range.chunk * range.ratio);
            } else {
                center = scale.getPixelForValue(this.getParsed(index)[scale.axis], index);
                size = Math.min(maxBarThickness, ruler.min * ruler.ratio);
            }
            return {
                base: center - size / 2,
                head: center + size / 2,
                center,
                size
            };
        }
        draw() {
            const meta = this._cachedMeta;
            const vScale = meta.vScale;
            const rects = meta.data;
            const ilen = rects.length;
            let i = 0;
            for(; i < ilen; ++i){
                if (this.getParsed(i)[vScale.axis] !== null && !rects[i].hidden) {
                    rects[i].draw(this._ctx);
                }
            }
        }
    }

    class BubbleController extends DatasetController {
        static id = 'bubble';
     static defaults = {
            datasetElementType: false,
            dataElementType: 'point',
            animations: {
                numbers: {
                    type: 'number',
                    properties: [
                        'x',
                        'y',
                        'borderWidth',
                        'radius'
                    ]
                }
            }
        };
     static overrides = {
            scales: {
                x: {
                    type: 'linear'
                },
                y: {
                    type: 'linear'
                }
            }
        };
        initialize() {
            this.enableOptionSharing = true;
            super.initialize();
        }
     parsePrimitiveData(meta, data, start, count) {
            const parsed = super.parsePrimitiveData(meta, data, start, count);
            for(let i = 0; i < parsed.length; i++){
                parsed[i]._custom = this.resolveDataElementOptions(i + start).radius;
            }
            return parsed;
        }
     parseArrayData(meta, data, start, count) {
            const parsed = super.parseArrayData(meta, data, start, count);
            for(let i = 0; i < parsed.length; i++){
                const item = data[start + i];
                parsed[i]._custom = valueOrDefault(item[2], this.resolveDataElementOptions(i + start).radius);
            }
            return parsed;
        }
     parseObjectData(meta, data, start, count) {
            const parsed = super.parseObjectData(meta, data, start, count);
            for(let i = 0; i < parsed.length; i++){
                const item = data[start + i];
                parsed[i]._custom = valueOrDefault(item && item.r && +item.r, this.resolveDataElementOptions(i + start).radius);
            }
            return parsed;
        }
     getMaxOverflow() {
            const data = this._cachedMeta.data;
            let max = 0;
            for(let i = data.length - 1; i >= 0; --i){
                max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);
            }
            return max > 0 && max;
        }
     getLabelAndValue(index) {
            const meta = this._cachedMeta;
            const labels = this.chart.data.labels || [];
            const { xScale , yScale  } = meta;
            const parsed = this.getParsed(index);
            const x = xScale.getLabelForValue(parsed.x);
            const y = yScale.getLabelForValue(parsed.y);
            const r = parsed._custom;
            return {
                label: labels[index] || '',
                value: '(' + x + ', ' + y + (r ? ', ' + r : '') + ')'
            };
        }
        update(mode) {
            const points = this._cachedMeta.data;
            this.updateElements(points, 0, points.length, mode);
        }
        updateElements(points, start, count, mode) {
            const reset = mode === 'reset';
            const { iScale , vScale  } = this._cachedMeta;
            const { sharedOptions , includeOptions  } = this._getSharedOptions(start, mode);
            const iAxis = iScale.axis;
            const vAxis = vScale.axis;
            for(let i = start; i < start + count; i++){
                const point = points[i];
                const parsed = !reset && this.getParsed(i);
                const properties = {};
                const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);
                const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);
                properties.skip = isNaN(iPixel) || isNaN(vPixel);
                if (includeOptions) {
                    properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);
                    if (reset) {
                        properties.options.radius = 0;
                    }
                }
                this.updateElement(point, i, properties, mode);
            }
        }
     resolveDataElementOptions(index, mode) {
            const parsed = this.getParsed(index);
            let values = super.resolveDataElementOptions(index, mode);
            if (values.$shared) {
                values = Object.assign({}, values, {
                    $shared: false
                });
            }
            const radius = values.radius;
            if (mode !== 'active') {
                values.radius = 0;
            }
            values.radius += valueOrDefault(parsed && parsed._custom, radius);
            return values;
        }
    }

    function getRatioAndOffset(rotation, circumference, cutout) {
        let ratioX = 1;
        let ratioY = 1;
        let offsetX = 0;
        let offsetY = 0;
        if (circumference < TAU) {
            const startAngle = rotation;
            const endAngle = startAngle + circumference;
            const startX = Math.cos(startAngle);
            const startY = Math.sin(startAngle);
            const endX = Math.cos(endAngle);
            const endY = Math.sin(endAngle);
            const calcMax = (angle, a, b)=>_angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);
            const calcMin = (angle, a, b)=>_angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);
            const maxX = calcMax(0, startX, endX);
            const maxY = calcMax(HALF_PI, startY, endY);
            const minX = calcMin(PI, startX, endX);
            const minY = calcMin(PI + HALF_PI, startY, endY);
            ratioX = (maxX - minX) / 2;
            ratioY = (maxY - minY) / 2;
            offsetX = -(maxX + minX) / 2;
            offsetY = -(maxY + minY) / 2;
        }
        return {
            ratioX,
            ratioY,
            offsetX,
            offsetY
        };
    }
    class DoughnutController extends DatasetController {
        static id = 'doughnut';
     static defaults = {
            datasetElementType: false,
            dataElementType: 'arc',
            animation: {
                animateRotate: true,
                animateScale: false
            },
            animations: {
                numbers: {
                    type: 'number',
                    properties: [
                        'circumference',
                        'endAngle',
                        'innerRadius',
                        'outerRadius',
                        'startAngle',
                        'x',
                        'y',
                        'offset',
                        'borderWidth',
                        'spacing'
                    ]
                }
            },
            cutout: '50%',
            rotation: 0,
            circumference: 360,
            radius: '100%',
            spacing: 0,
            indexAxis: 'r'
        };
        static descriptors = {
            _scriptable: (name)=>name !== 'spacing',
            _indexable: (name)=>name !== 'spacing' && !name.startsWith('borderDash') && !name.startsWith('hoverBorderDash')
        };
     static overrides = {
            aspectRatio: 1,
            plugins: {
                legend: {
                    labels: {
                        generateLabels (chart) {
                            const data = chart.data;
                            if (data.labels.length && data.datasets.length) {
                                const { labels: { pointStyle , color  }  } = chart.legend.options;
                                return data.labels.map((label, i)=>{
                                    const meta = chart.getDatasetMeta(0);
                                    const style = meta.controller.getStyle(i);
                                    return {
                                        text: label,
                                        fillStyle: style.backgroundColor,
                                        strokeStyle: style.borderColor,
                                        fontColor: color,
                                        lineWidth: style.borderWidth,
                                        pointStyle: pointStyle,
                                        hidden: !chart.getDataVisibility(i),
                                        index: i
                                    };
                                });
                            }
                            return [];
                        }
                    },
                    onClick (e, legendItem, legend) {
                        legend.chart.toggleDataVisibility(legendItem.index);
                        legend.chart.update();
                    }
                }
            }
        };
        constructor(chart, datasetIndex){
            super(chart, datasetIndex);
            this.enableOptionSharing = true;
            this.innerRadius = undefined;
            this.outerRadius = undefined;
            this.offsetX = undefined;
            this.offsetY = undefined;
        }
        linkScales() {}
     parse(start, count) {
            const data = this.getDataset().data;
            const meta = this._cachedMeta;
            if (this._parsing === false) {
                meta._parsed = data;
            } else {
                let getter = (i)=>+data[i];
                if (isObject$1(data[start])) {
                    const { key ='value'  } = this._parsing;
                    getter = (i)=>+resolveObjectKey(data[i], key);
                }
                let i, ilen;
                for(i = start, ilen = start + count; i < ilen; ++i){
                    meta._parsed[i] = getter(i);
                }
            }
        }
     _getRotation() {
            return toRadians(this.options.rotation - 90);
        }
     _getCircumference() {
            return toRadians(this.options.circumference);
        }
     _getRotationExtents() {
            let min = TAU;
            let max = -TAU;
            for(let i = 0; i < this.chart.data.datasets.length; ++i){
                if (this.chart.isDatasetVisible(i) && this.chart.getDatasetMeta(i).type === this._type) {
                    const controller = this.chart.getDatasetMeta(i).controller;
                    const rotation = controller._getRotation();
                    const circumference = controller._getCircumference();
                    min = Math.min(min, rotation);
                    max = Math.max(max, rotation + circumference);
                }
            }
            return {
                rotation: min,
                circumference: max - min
            };
        }
     update(mode) {
            const chart = this.chart;
            const { chartArea  } = chart;
            const meta = this._cachedMeta;
            const arcs = meta.data;
            const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;
            const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);
            const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);
            const chartWeight = this._getRingWeight(this.index);
            const { circumference , rotation  } = this._getRotationExtents();
            const { ratioX , ratioY , offsetX , offsetY  } = getRatioAndOffset(rotation, circumference, cutout);
            const maxWidth = (chartArea.width - spacing) / ratioX;
            const maxHeight = (chartArea.height - spacing) / ratioY;
            const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);
            const outerRadius = toDimension(this.options.radius, maxRadius);
            const innerRadius = Math.max(outerRadius * cutout, 0);
            const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();
            this.offsetX = offsetX * outerRadius;
            this.offsetY = offsetY * outerRadius;
            meta.total = this.calculateTotal();
            this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);
            this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);
            this.updateElements(arcs, 0, arcs.length, mode);
        }
     _circumference(i, reset) {
            const opts = this.options;
            const meta = this._cachedMeta;
            const circumference = this._getCircumference();
            if (reset && opts.animation.animateRotate || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) {
                return 0;
            }
            return this.calculateCircumference(meta._parsed[i] * circumference / TAU);
        }
        updateElements(arcs, start, count, mode) {
            const reset = mode === 'reset';
            const chart = this.chart;
            const chartArea = chart.chartArea;
            const opts = chart.options;
            const animationOpts = opts.animation;
            const centerX = (chartArea.left + chartArea.right) / 2;
            const centerY = (chartArea.top + chartArea.bottom) / 2;
            const animateScale = reset && animationOpts.animateScale;
            const innerRadius = animateScale ? 0 : this.innerRadius;
            const outerRadius = animateScale ? 0 : this.outerRadius;
            const { sharedOptions , includeOptions  } = this._getSharedOptions(start, mode);
            let startAngle = this._getRotation();
            let i;
            for(i = 0; i < start; ++i){
                startAngle += this._circumference(i, reset);
            }
            for(i = start; i < start + count; ++i){
                const circumference = this._circumference(i, reset);
                const arc = arcs[i];
                const properties = {
                    x: centerX + this.offsetX,
                    y: centerY + this.offsetY,
                    startAngle,
                    endAngle: startAngle + circumference,
                    circumference,
                    outerRadius,
                    innerRadius
                };
                if (includeOptions) {
                    properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? 'active' : mode);
                }
                startAngle += circumference;
                this.updateElement(arc, i, properties, mode);
            }
        }
        calculateTotal() {
            const meta = this._cachedMeta;
            const metaData = meta.data;
            let total = 0;
            let i;
            for(i = 0; i < metaData.length; i++){
                const value = meta._parsed[i];
                if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {
                    total += Math.abs(value);
                }
            }
            return total;
        }
        calculateCircumference(value) {
            const total = this._cachedMeta.total;
            if (total > 0 && !isNaN(value)) {
                return TAU * (Math.abs(value) / total);
            }
            return 0;
        }
        getLabelAndValue(index) {
            const meta = this._cachedMeta;
            const chart = this.chart;
            const labels = chart.data.labels || [];
            const value = formatNumber(meta._parsed[index], chart.options.locale);
            return {
                label: labels[index] || '',
                value
            };
        }
        getMaxBorderWidth(arcs) {
            let max = 0;
            const chart = this.chart;
            let i, ilen, meta, controller, options;
            if (!arcs) {
                for(i = 0, ilen = chart.data.datasets.length; i < ilen; ++i){
                    if (chart.isDatasetVisible(i)) {
                        meta = chart.getDatasetMeta(i);
                        arcs = meta.data;
                        controller = meta.controller;
                        break;
                    }
                }
            }
            if (!arcs) {
                return 0;
            }
            for(i = 0, ilen = arcs.length; i < ilen; ++i){
                options = controller.resolveDataElementOptions(i);
                if (options.borderAlign !== 'inner') {
                    max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);
                }
            }
            return max;
        }
        getMaxOffset(arcs) {
            let max = 0;
            for(let i = 0, ilen = arcs.length; i < ilen; ++i){
                const options = this.resolveDataElementOptions(i);
                max = Math.max(max, options.offset || 0, options.hoverOffset || 0);
            }
            return max;
        }
     _getRingWeightOffset(datasetIndex) {
            let ringWeightOffset = 0;
            for(let i = 0; i < datasetIndex; ++i){
                if (this.chart.isDatasetVisible(i)) {
                    ringWeightOffset += this._getRingWeight(i);
                }
            }
            return ringWeightOffset;
        }
     _getRingWeight(datasetIndex) {
            return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);
        }
     _getVisibleDatasetWeightTotal() {
            return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
        }
    }

    class LineController extends DatasetController {
        static id = 'line';
     static defaults = {
            datasetElementType: 'line',
            dataElementType: 'point',
            showLine: true,
            spanGaps: false
        };
     static overrides = {
            scales: {
                _index_: {
                    type: 'category'
                },
                _value_: {
                    type: 'linear'
                }
            }
        };
        initialize() {
            this.enableOptionSharing = true;
            this.supportsDecimation = true;
            super.initialize();
        }
        update(mode) {
            const meta = this._cachedMeta;
            const { dataset: line , data: points = [] , _dataset  } = meta;
            const animationsDisabled = this.chart._animationsDisabled;
            let { start , count  } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
            this._drawStart = start;
            this._drawCount = count;
            if (_scaleRangesChanged(meta)) {
                start = 0;
                count = points.length;
            }
            line._chart = this.chart;
            line._datasetIndex = this.index;
            line._decimated = !!_dataset._decimated;
            line.points = points;
            const options = this.resolveDatasetElementOptions(mode);
            if (!this.options.showLine) {
                options.borderWidth = 0;
            }
            options.segment = this.options.segment;
            this.updateElement(line, undefined, {
                animated: !animationsDisabled,
                options
            }, mode);
            this.updateElements(points, start, count, mode);
        }
        updateElements(points, start, count, mode) {
            const reset = mode === 'reset';
            const { iScale , vScale , _stacked , _dataset  } = this._cachedMeta;
            const { sharedOptions , includeOptions  } = this._getSharedOptions(start, mode);
            const iAxis = iScale.axis;
            const vAxis = vScale.axis;
            const { spanGaps , segment  } = this.options;
            const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
            const directUpdate = this.chart._animationsDisabled || reset || mode === 'none';
            const end = start + count;
            const pointsCount = points.length;
            let prevParsed = start > 0 && this.getParsed(start - 1);
            for(let i = 0; i < pointsCount; ++i){
                const point = points[i];
                const properties = directUpdate ? point : {};
                if (i < start || i >= end) {
                    properties.skip = true;
                    continue;
                }
                const parsed = this.getParsed(i);
                const nullData = isNullOrUndef(parsed[vAxis]);
                const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
                const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
                properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
                properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
                if (segment) {
                    properties.parsed = parsed;
                    properties.raw = _dataset.data[i];
                }
                if (includeOptions) {
                    properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);
                }
                if (!directUpdate) {
                    this.updateElement(point, i, properties, mode);
                }
                prevParsed = parsed;
            }
        }
     getMaxOverflow() {
            const meta = this._cachedMeta;
            const dataset = meta.dataset;
            const border = dataset.options && dataset.options.borderWidth || 0;
            const data = meta.data || [];
            if (!data.length) {
                return border;
            }
            const firstPoint = data[0].size(this.resolveDataElementOptions(0));
            const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
            return Math.max(border, firstPoint, lastPoint) / 2;
        }
        draw() {
            const meta = this._cachedMeta;
            meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);
            super.draw();
        }
    }

    class PolarAreaController extends DatasetController {
        static id = 'polarArea';
     static defaults = {
            dataElementType: 'arc',
            animation: {
                animateRotate: true,
                animateScale: true
            },
            animations: {
                numbers: {
                    type: 'number',
                    properties: [
                        'x',
                        'y',
                        'startAngle',
                        'endAngle',
                        'innerRadius',
                        'outerRadius'
                    ]
                }
            },
            indexAxis: 'r',
            startAngle: 0
        };
     static overrides = {
            aspectRatio: 1,
            plugins: {
                legend: {
                    labels: {
                        generateLabels (chart) {
                            const data = chart.data;
                            if (data.labels.length && data.datasets.length) {
                                const { labels: { pointStyle , color  }  } = chart.legend.options;
                                return data.labels.map((label, i)=>{
                                    const meta = chart.getDatasetMeta(0);
                                    const style = meta.controller.getStyle(i);
                                    return {
                                        text: label,
                                        fillStyle: style.backgroundColor,
                                        strokeStyle: style.borderColor,
                                        fontColor: color,
                                        lineWidth: style.borderWidth,
                                        pointStyle: pointStyle,
                                        hidden: !chart.getDataVisibility(i),
                                        index: i
                                    };
                                });
                            }
                            return [];
                        }
                    },
                    onClick (e, legendItem, legend) {
                        legend.chart.toggleDataVisibility(legendItem.index);
                        legend.chart.update();
                    }
                }
            },
            scales: {
                r: {
                    type: 'radialLinear',
                    angleLines: {
                        display: false
                    },
                    beginAtZero: true,
                    grid: {
                        circular: true
                    },
                    pointLabels: {
                        display: false
                    },
                    startAngle: 0
                }
            }
        };
        constructor(chart, datasetIndex){
            super(chart, datasetIndex);
            this.innerRadius = undefined;
            this.outerRadius = undefined;
        }
        getLabelAndValue(index) {
            const meta = this._cachedMeta;
            const chart = this.chart;
            const labels = chart.data.labels || [];
            const value = formatNumber(meta._parsed[index].r, chart.options.locale);
            return {
                label: labels[index] || '',
                value
            };
        }
        parseObjectData(meta, data, start, count) {
            return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);
        }
        update(mode) {
            const arcs = this._cachedMeta.data;
            this._updateRadius();
            this.updateElements(arcs, 0, arcs.length, mode);
        }
     getMinMax() {
            const meta = this._cachedMeta;
            const range = {
                min: Number.POSITIVE_INFINITY,
                max: Number.NEGATIVE_INFINITY
            };
            meta.data.forEach((element, index)=>{
                const parsed = this.getParsed(index).r;
                if (!isNaN(parsed) && this.chart.getDataVisibility(index)) {
                    if (parsed < range.min) {
                        range.min = parsed;
                    }
                    if (parsed > range.max) {
                        range.max = parsed;
                    }
                }
            });
            return range;
        }
     _updateRadius() {
            const chart = this.chart;
            const chartArea = chart.chartArea;
            const opts = chart.options;
            const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
            const outerRadius = Math.max(minSize / 2, 0);
            const innerRadius = Math.max(opts.cutoutPercentage ? outerRadius / 100 * opts.cutoutPercentage : 1, 0);
            const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();
            this.outerRadius = outerRadius - radiusLength * this.index;
            this.innerRadius = this.outerRadius - radiusLength;
        }
        updateElements(arcs, start, count, mode) {
            const reset = mode === 'reset';
            const chart = this.chart;
            const opts = chart.options;
            const animationOpts = opts.animation;
            const scale = this._cachedMeta.rScale;
            const centerX = scale.xCenter;
            const centerY = scale.yCenter;
            const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * PI;
            let angle = datasetStartAngle;
            let i;
            const defaultAngle = 360 / this.countVisibleElements();
            for(i = 0; i < start; ++i){
                angle += this._computeAngle(i, mode, defaultAngle);
            }
            for(i = start; i < start + count; i++){
                const arc = arcs[i];
                let startAngle = angle;
                let endAngle = angle + this._computeAngle(i, mode, defaultAngle);
                let outerRadius = chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(this.getParsed(i).r) : 0;
                angle = endAngle;
                if (reset) {
                    if (animationOpts.animateScale) {
                        outerRadius = 0;
                    }
                    if (animationOpts.animateRotate) {
                        startAngle = endAngle = datasetStartAngle;
                    }
                }
                const properties = {
                    x: centerX,
                    y: centerY,
                    innerRadius: 0,
                    outerRadius,
                    startAngle,
                    endAngle,
                    options: this.resolveDataElementOptions(i, arc.active ? 'active' : mode)
                };
                this.updateElement(arc, i, properties, mode);
            }
        }
        countVisibleElements() {
            const meta = this._cachedMeta;
            let count = 0;
            meta.data.forEach((element, index)=>{
                if (!isNaN(this.getParsed(index).r) && this.chart.getDataVisibility(index)) {
                    count++;
                }
            });
            return count;
        }
     _computeAngle(index, mode, defaultAngle) {
            return this.chart.getDataVisibility(index) ? toRadians(this.resolveDataElementOptions(index, mode).angle || defaultAngle) : 0;
        }
    }

    class PieController extends DoughnutController {
        static id = 'pie';
     static defaults = {
            cutout: 0,
            rotation: 0,
            circumference: 360,
            radius: '100%'
        };
    }

    class RadarController extends DatasetController {
        static id = 'radar';
     static defaults = {
            datasetElementType: 'line',
            dataElementType: 'point',
            indexAxis: 'r',
            showLine: true,
            elements: {
                line: {
                    fill: 'start'
                }
            }
        };
     static overrides = {
            aspectRatio: 1,
            scales: {
                r: {
                    type: 'radialLinear'
                }
            }
        };
     getLabelAndValue(index) {
            const vScale = this._cachedMeta.vScale;
            const parsed = this.getParsed(index);
            return {
                label: vScale.getLabels()[index],
                value: '' + vScale.getLabelForValue(parsed[vScale.axis])
            };
        }
        parseObjectData(meta, data, start, count) {
            return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);
        }
        update(mode) {
            const meta = this._cachedMeta;
            const line = meta.dataset;
            const points = meta.data || [];
            const labels = meta.iScale.getLabels();
            line.points = points;
            if (mode !== 'resize') {
                const options = this.resolveDatasetElementOptions(mode);
                if (!this.options.showLine) {
                    options.borderWidth = 0;
                }
                const properties = {
                    _loop: true,
                    _fullLoop: labels.length === points.length,
                    options
                };
                this.updateElement(line, undefined, properties, mode);
            }
            this.updateElements(points, 0, points.length, mode);
        }
        updateElements(points, start, count, mode) {
            const scale = this._cachedMeta.rScale;
            const reset = mode === 'reset';
            for(let i = start; i < start + count; i++){
                const point = points[i];
                const options = this.resolveDataElementOptions(i, point.active ? 'active' : mode);
                const pointPosition = scale.getPointPositionForValue(i, this.getParsed(i).r);
                const x = reset ? scale.xCenter : pointPosition.x;
                const y = reset ? scale.yCenter : pointPosition.y;
                const properties = {
                    x,
                    y,
                    angle: pointPosition.angle,
                    skip: isNaN(x) || isNaN(y),
                    options
                };
                this.updateElement(point, i, properties, mode);
            }
        }
    }

    class ScatterController extends DatasetController {
        static id = 'scatter';
     static defaults = {
            datasetElementType: false,
            dataElementType: 'point',
            showLine: false,
            fill: false
        };
     static overrides = {
            interaction: {
                mode: 'point'
            },
            scales: {
                x: {
                    type: 'linear'
                },
                y: {
                    type: 'linear'
                }
            }
        };
     getLabelAndValue(index) {
            const meta = this._cachedMeta;
            const labels = this.chart.data.labels || [];
            const { xScale , yScale  } = meta;
            const parsed = this.getParsed(index);
            const x = xScale.getLabelForValue(parsed.x);
            const y = yScale.getLabelForValue(parsed.y);
            return {
                label: labels[index] || '',
                value: '(' + x + ', ' + y + ')'
            };
        }
        update(mode) {
            const meta = this._cachedMeta;
            const { data: points = []  } = meta;
            const animationsDisabled = this.chart._animationsDisabled;
            let { start , count  } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
            this._drawStart = start;
            this._drawCount = count;
            if (_scaleRangesChanged(meta)) {
                start = 0;
                count = points.length;
            }
            if (this.options.showLine) {
                if (!this.datasetElementType) {
                    this.addElements();
                }
                const { dataset: line , _dataset  } = meta;
                line._chart = this.chart;
                line._datasetIndex = this.index;
                line._decimated = !!_dataset._decimated;
                line.points = points;
                const options = this.resolveDatasetElementOptions(mode);
                options.segment = this.options.segment;
                this.updateElement(line, undefined, {
                    animated: !animationsDisabled,
                    options
                }, mode);
            } else if (this.datasetElementType) {
                delete meta.dataset;
                this.datasetElementType = false;
            }
            this.updateElements(points, start, count, mode);
        }
        addElements() {
            const { showLine  } = this.options;
            if (!this.datasetElementType && showLine) {
                this.datasetElementType = this.chart.registry.getElement('line');
            }
            super.addElements();
        }
        updateElements(points, start, count, mode) {
            const reset = mode === 'reset';
            const { iScale , vScale , _stacked , _dataset  } = this._cachedMeta;
            const firstOpts = this.resolveDataElementOptions(start, mode);
            const sharedOptions = this.getSharedOptions(firstOpts);
            const includeOptions = this.includeOptions(mode, sharedOptions);
            const iAxis = iScale.axis;
            const vAxis = vScale.axis;
            const { spanGaps , segment  } = this.options;
            const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
            const directUpdate = this.chart._animationsDisabled || reset || mode === 'none';
            let prevParsed = start > 0 && this.getParsed(start - 1);
            for(let i = start; i < start + count; ++i){
                const point = points[i];
                const parsed = this.getParsed(i);
                const properties = directUpdate ? point : {};
                const nullData = isNullOrUndef(parsed[vAxis]);
                const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
                const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
                properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
                properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
                if (segment) {
                    properties.parsed = parsed;
                    properties.raw = _dataset.data[i];
                }
                if (includeOptions) {
                    properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);
                }
                if (!directUpdate) {
                    this.updateElement(point, i, properties, mode);
                }
                prevParsed = parsed;
            }
            this.updateSharedOptions(sharedOptions, mode, firstOpts);
        }
     getMaxOverflow() {
            const meta = this._cachedMeta;
            const data = meta.data || [];
            if (!this.options.showLine) {
                let max = 0;
                for(let i = data.length - 1; i >= 0; --i){
                    max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);
                }
                return max > 0 && max;
            }
            const dataset = meta.dataset;
            const border = dataset.options && dataset.options.borderWidth || 0;
            if (!data.length) {
                return border;
            }
            const firstPoint = data[0].size(this.resolveDataElementOptions(0));
            const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
            return Math.max(border, firstPoint, lastPoint) / 2;
        }
    }

    var controllers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    BarController: BarController,
    BubbleController: BubbleController,
    DoughnutController: DoughnutController,
    LineController: LineController,
    PieController: PieController,
    PolarAreaController: PolarAreaController,
    RadarController: RadarController,
    ScatterController: ScatterController
    });

    /**
     * @namespace Chart._adapters
     * @since 2.8.0
     * @private
     */ function abstract() {
        throw new Error('This method is not implemented: Check that a complete date adapter is provided.');
    }
    /**
     * Date adapter (current used by the time scale)
     * @namespace Chart._adapters._date
     * @memberof Chart._adapters
     * @private
     */ class DateAdapterBase {
        /**
       * Override default date adapter methods.
       * Accepts type parameter to define options type.
       * @example
       * Chart._adapters._date.override<{myAdapterOption: string}>({
       *   init() {
       *     console.log(this.options.myAdapterOption);
       *   }
       * })
       */ static override(members) {
            Object.assign(DateAdapterBase.prototype, members);
        }
        options;
        constructor(options){
            this.options = options || {};
        }
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        init() {}
        formats() {
            return abstract();
        }
        parse() {
            return abstract();
        }
        format() {
            return abstract();
        }
        add() {
            return abstract();
        }
        diff() {
            return abstract();
        }
        startOf() {
            return abstract();
        }
        endOf() {
            return abstract();
        }
    }
    var adapters = {
        _date: DateAdapterBase
    };

    function binarySearch(metaset, axis, value, intersect) {
        const { controller , data , _sorted  } = metaset;
        const iScale = controller._cachedMeta.iScale;
        if (iScale && axis === iScale.axis && axis !== 'r' && _sorted && data.length) {
            const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;
            if (!intersect) {
                return lookupMethod(data, axis, value);
            } else if (controller._sharedOptions) {
                const el = data[0];
                const range = typeof el.getRange === 'function' && el.getRange(axis);
                if (range) {
                    const start = lookupMethod(data, axis, value - range);
                    const end = lookupMethod(data, axis, value + range);
                    return {
                        lo: start.lo,
                        hi: end.hi
                    };
                }
            }
        }
        return {
            lo: 0,
            hi: data.length - 1
        };
    }
     function evaluateInteractionItems(chart, axis, position, handler, intersect) {
        const metasets = chart.getSortedVisibleDatasetMetas();
        const value = position[axis];
        for(let i = 0, ilen = metasets.length; i < ilen; ++i){
            const { index , data  } = metasets[i];
            const { lo , hi  } = binarySearch(metasets[i], axis, value, intersect);
            for(let j = lo; j <= hi; ++j){
                const element = data[j];
                if (!element.skip) {
                    handler(element, index, j);
                }
            }
        }
    }
     function getDistanceMetricForAxis(axis) {
        const useX = axis.indexOf('x') !== -1;
        const useY = axis.indexOf('y') !== -1;
        return function(pt1, pt2) {
            const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
            const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
            return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
        };
    }
     function getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {
        const items = [];
        if (!includeInvisible && !chart.isPointInArea(position)) {
            return items;
        }
        const evaluationFunc = function(element, datasetIndex, index) {
            if (!includeInvisible && !_isPointInArea(element, chart.chartArea, 0)) {
                return;
            }
            if (element.inRange(position.x, position.y, useFinalPosition)) {
                items.push({
                    element,
                    datasetIndex,
                    index
                });
            }
        };
        evaluateInteractionItems(chart, axis, position, evaluationFunc, true);
        return items;
    }
     function getNearestRadialItems(chart, position, axis, useFinalPosition) {
        let items = [];
        function evaluationFunc(element, datasetIndex, index) {
            const { startAngle , endAngle  } = element.getProps([
                'startAngle',
                'endAngle'
            ], useFinalPosition);
            const { angle  } = getAngleFromPoint(element, {
                x: position.x,
                y: position.y
            });
            if (_angleBetween(angle, startAngle, endAngle)) {
                items.push({
                    element,
                    datasetIndex,
                    index
                });
            }
        }
        evaluateInteractionItems(chart, axis, position, evaluationFunc);
        return items;
    }
     function getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
        let items = [];
        const distanceMetric = getDistanceMetricForAxis(axis);
        let minDistance = Number.POSITIVE_INFINITY;
        function evaluationFunc(element, datasetIndex, index) {
            const inRange = element.inRange(position.x, position.y, useFinalPosition);
            if (intersect && !inRange) {
                return;
            }
            const center = element.getCenterPoint(useFinalPosition);
            const pointInArea = !!includeInvisible || chart.isPointInArea(center);
            if (!pointInArea && !inRange) {
                return;
            }
            const distance = distanceMetric(position, center);
            if (distance < minDistance) {
                items = [
                    {
                        element,
                        datasetIndex,
                        index
                    }
                ];
                minDistance = distance;
            } else if (distance === minDistance) {
                items.push({
                    element,
                    datasetIndex,
                    index
                });
            }
        }
        evaluateInteractionItems(chart, axis, position, evaluationFunc);
        return items;
    }
     function getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
        if (!includeInvisible && !chart.isPointInArea(position)) {
            return [];
        }
        return axis === 'r' && !intersect ? getNearestRadialItems(chart, position, axis, useFinalPosition) : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible);
    }
     function getAxisItems(chart, position, axis, intersect, useFinalPosition) {
        const items = [];
        const rangeMethod = axis === 'x' ? 'inXRange' : 'inYRange';
        let intersectsItem = false;
        evaluateInteractionItems(chart, axis, position, (element, datasetIndex, index)=>{
            if (element[rangeMethod] && element[rangeMethod](position[axis], useFinalPosition)) {
                items.push({
                    element,
                    datasetIndex,
                    index
                });
                intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);
            }
        });
        if (intersect && !intersectsItem) {
            return [];
        }
        return items;
    }
     var Interaction = {
        evaluateInteractionItems,
        modes: {
     index (chart, e, options, useFinalPosition) {
                const position = getRelativePosition(e, chart);
                const axis = options.axis || 'x';
                const includeInvisible = options.includeInvisible || false;
                const items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
                const elements = [];
                if (!items.length) {
                    return [];
                }
                chart.getSortedVisibleDatasetMetas().forEach((meta)=>{
                    const index = items[0].index;
                    const element = meta.data[index];
                    if (element && !element.skip) {
                        elements.push({
                            element,
                            datasetIndex: meta.index,
                            index
                        });
                    }
                });
                return elements;
            },
     dataset (chart, e, options, useFinalPosition) {
                const position = getRelativePosition(e, chart);
                const axis = options.axis || 'xy';
                const includeInvisible = options.includeInvisible || false;
                let items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
                if (items.length > 0) {
                    const datasetIndex = items[0].datasetIndex;
                    const data = chart.getDatasetMeta(datasetIndex).data;
                    items = [];
                    for(let i = 0; i < data.length; ++i){
                        items.push({
                            element: data[i],
                            datasetIndex,
                            index: i
                        });
                    }
                }
                return items;
            },
     point (chart, e, options, useFinalPosition) {
                const position = getRelativePosition(e, chart);
                const axis = options.axis || 'xy';
                const includeInvisible = options.includeInvisible || false;
                return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);
            },
     nearest (chart, e, options, useFinalPosition) {
                const position = getRelativePosition(e, chart);
                const axis = options.axis || 'xy';
                const includeInvisible = options.includeInvisible || false;
                return getNearestItems(chart, position, axis, options.intersect, useFinalPosition, includeInvisible);
            },
     x (chart, e, options, useFinalPosition) {
                const position = getRelativePosition(e, chart);
                return getAxisItems(chart, position, 'x', options.intersect, useFinalPosition);
            },
     y (chart, e, options, useFinalPosition) {
                const position = getRelativePosition(e, chart);
                return getAxisItems(chart, position, 'y', options.intersect, useFinalPosition);
            }
        }
    };

    const STATIC_POSITIONS = [
        'left',
        'top',
        'right',
        'bottom'
    ];
    function filterByPosition(array, position) {
        return array.filter((v)=>v.pos === position);
    }
    function filterDynamicPositionByAxis(array, axis) {
        return array.filter((v)=>STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);
    }
    function sortByWeight(array, reverse) {
        return array.sort((a, b)=>{
            const v0 = reverse ? b : a;
            const v1 = reverse ? a : b;
            return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;
        });
    }
    function wrapBoxes(boxes) {
        const layoutBoxes = [];
        let i, ilen, box, pos, stack, stackWeight;
        for(i = 0, ilen = (boxes || []).length; i < ilen; ++i){
            box = boxes[i];
            ({ position: pos , options: { stack , stackWeight =1  }  } = box);
            layoutBoxes.push({
                index: i,
                box,
                pos,
                horizontal: box.isHorizontal(),
                weight: box.weight,
                stack: stack && pos + stack,
                stackWeight
            });
        }
        return layoutBoxes;
    }
    function buildStacks(layouts) {
        const stacks = {};
        for (const wrap of layouts){
            const { stack , pos , stackWeight  } = wrap;
            if (!stack || !STATIC_POSITIONS.includes(pos)) {
                continue;
            }
            const _stack = stacks[stack] || (stacks[stack] = {
                count: 0,
                placed: 0,
                weight: 0,
                size: 0
            });
            _stack.count++;
            _stack.weight += stackWeight;
        }
        return stacks;
    }
     function setLayoutDims(layouts, params) {
        const stacks = buildStacks(layouts);
        const { vBoxMaxWidth , hBoxMaxHeight  } = params;
        let i, ilen, layout;
        for(i = 0, ilen = layouts.length; i < ilen; ++i){
            layout = layouts[i];
            const { fullSize  } = layout.box;
            const stack = stacks[layout.stack];
            const factor = stack && layout.stackWeight / stack.weight;
            if (layout.horizontal) {
                layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;
                layout.height = hBoxMaxHeight;
            } else {
                layout.width = vBoxMaxWidth;
                layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;
            }
        }
        return stacks;
    }
    function buildLayoutBoxes(boxes) {
        const layoutBoxes = wrapBoxes(boxes);
        const fullSize = sortByWeight(layoutBoxes.filter((wrap)=>wrap.box.fullSize), true);
        const left = sortByWeight(filterByPosition(layoutBoxes, 'left'), true);
        const right = sortByWeight(filterByPosition(layoutBoxes, 'right'));
        const top = sortByWeight(filterByPosition(layoutBoxes, 'top'), true);
        const bottom = sortByWeight(filterByPosition(layoutBoxes, 'bottom'));
        const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, 'x');
        const centerVertical = filterDynamicPositionByAxis(layoutBoxes, 'y');
        return {
            fullSize,
            leftAndTop: left.concat(top),
            rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),
            chartArea: filterByPosition(layoutBoxes, 'chartArea'),
            vertical: left.concat(right).concat(centerVertical),
            horizontal: top.concat(bottom).concat(centerHorizontal)
        };
    }
    function getCombinedMax(maxPadding, chartArea, a, b) {
        return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);
    }
    function updateMaxPadding(maxPadding, boxPadding) {
        maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
        maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
        maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
        maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
    }
    function updateDims(chartArea, params, layout, stacks) {
        const { pos , box  } = layout;
        const maxPadding = chartArea.maxPadding;
        if (!isObject$1(pos)) {
            if (layout.size) {
                chartArea[pos] -= layout.size;
            }
            const stack = stacks[layout.stack] || {
                size: 0,
                count: 1
            };
            stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);
            layout.size = stack.size / stack.count;
            chartArea[pos] += layout.size;
        }
        if (box.getPadding) {
            updateMaxPadding(maxPadding, box.getPadding());
        }
        const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, 'left', 'right'));
        const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, 'top', 'bottom'));
        const widthChanged = newWidth !== chartArea.w;
        const heightChanged = newHeight !== chartArea.h;
        chartArea.w = newWidth;
        chartArea.h = newHeight;
        return layout.horizontal ? {
            same: widthChanged,
            other: heightChanged
        } : {
            same: heightChanged,
            other: widthChanged
        };
    }
    function handleMaxPadding(chartArea) {
        const maxPadding = chartArea.maxPadding;
        function updatePos(pos) {
            const change = Math.max(maxPadding[pos] - chartArea[pos], 0);
            chartArea[pos] += change;
            return change;
        }
        chartArea.y += updatePos('top');
        chartArea.x += updatePos('left');
        updatePos('right');
        updatePos('bottom');
    }
    function getMargins(horizontal, chartArea) {
        const maxPadding = chartArea.maxPadding;
        function marginForPositions(positions) {
            const margin = {
                left: 0,
                top: 0,
                right: 0,
                bottom: 0
            };
            positions.forEach((pos)=>{
                margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
            });
            return margin;
        }
        return horizontal ? marginForPositions([
            'left',
            'right'
        ]) : marginForPositions([
            'top',
            'bottom'
        ]);
    }
    function fitBoxes(boxes, chartArea, params, stacks) {
        const refitBoxes = [];
        let i, ilen, layout, box, refit, changed;
        for(i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i){
            layout = boxes[i];
            box = layout.box;
            box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));
            const { same , other  } = updateDims(chartArea, params, layout, stacks);
            refit |= same && refitBoxes.length;
            changed = changed || other;
            if (!box.fullSize) {
                refitBoxes.push(layout);
            }
        }
        return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;
    }
    function setBoxDims(box, left, top, width, height) {
        box.top = top;
        box.left = left;
        box.right = left + width;
        box.bottom = top + height;
        box.width = width;
        box.height = height;
    }
    function placeBoxes(boxes, chartArea, params, stacks) {
        const userPadding = params.padding;
        let { x , y  } = chartArea;
        for (const layout of boxes){
            const box = layout.box;
            const stack = stacks[layout.stack] || {
                count: 1,
                placed: 0,
                weight: 1
            };
            const weight = layout.stackWeight / stack.weight || 1;
            if (layout.horizontal) {
                const width = chartArea.w * weight;
                const height = stack.size || box.height;
                if (defined(stack.start)) {
                    y = stack.start;
                }
                if (box.fullSize) {
                    setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);
                } else {
                    setBoxDims(box, chartArea.left + stack.placed, y, width, height);
                }
                stack.start = y;
                stack.placed += width;
                y = box.bottom;
            } else {
                const height = chartArea.h * weight;
                const width = stack.size || box.width;
                if (defined(stack.start)) {
                    x = stack.start;
                }
                if (box.fullSize) {
                    setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);
                } else {
                    setBoxDims(box, x, chartArea.top + stack.placed, width, height);
                }
                stack.start = x;
                stack.placed += height;
                x = box.right;
            }
        }
        chartArea.x = x;
        chartArea.y = y;
    }
    var layouts = {
     addBox (chart, item) {
            if (!chart.boxes) {
                chart.boxes = [];
            }
            item.fullSize = item.fullSize || false;
            item.position = item.position || 'top';
            item.weight = item.weight || 0;
            item._layers = item._layers || function() {
                return [
                    {
                        z: 0,
                        draw (chartArea) {
                            item.draw(chartArea);
                        }
                    }
                ];
            };
            chart.boxes.push(item);
        },
     removeBox (chart, layoutItem) {
            const index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
            if (index !== -1) {
                chart.boxes.splice(index, 1);
            }
        },
     configure (chart, item, options) {
            item.fullSize = options.fullSize;
            item.position = options.position;
            item.weight = options.weight;
        },
     update (chart, width, height, minPadding) {
            if (!chart) {
                return;
            }
            const padding = toPadding(chart.options.layout.padding);
            const availableWidth = Math.max(width - padding.width, 0);
            const availableHeight = Math.max(height - padding.height, 0);
            const boxes = buildLayoutBoxes(chart.boxes);
            const verticalBoxes = boxes.vertical;
            const horizontalBoxes = boxes.horizontal;
            each(chart.boxes, (box)=>{
                if (typeof box.beforeLayout === 'function') {
                    box.beforeLayout();
                }
            });
            const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap)=>wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;
            const params = Object.freeze({
                outerWidth: width,
                outerHeight: height,
                padding,
                availableWidth,
                availableHeight,
                vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,
                hBoxMaxHeight: availableHeight / 2
            });
            const maxPadding = Object.assign({}, padding);
            updateMaxPadding(maxPadding, toPadding(minPadding));
            const chartArea = Object.assign({
                maxPadding,
                w: availableWidth,
                h: availableHeight,
                x: padding.left,
                y: padding.top
            }, padding);
            const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);
            fitBoxes(boxes.fullSize, chartArea, params, stacks);
            fitBoxes(verticalBoxes, chartArea, params, stacks);
            if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {
                fitBoxes(verticalBoxes, chartArea, params, stacks);
            }
            handleMaxPadding(chartArea);
            placeBoxes(boxes.leftAndTop, chartArea, params, stacks);
            chartArea.x += chartArea.w;
            chartArea.y += chartArea.h;
            placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);
            chart.chartArea = {
                left: chartArea.left,
                top: chartArea.top,
                right: chartArea.left + chartArea.w,
                bottom: chartArea.top + chartArea.h,
                height: chartArea.h,
                width: chartArea.w
            };
            each(boxes.chartArea, (layout)=>{
                const box = layout.box;
                Object.assign(box, chart.chartArea);
                box.update(chartArea.w, chartArea.h, {
                    left: 0,
                    top: 0,
                    right: 0,
                    bottom: 0
                });
            });
        }
    };

    class BasePlatform {
     acquireContext(canvas, aspectRatio) {}
     releaseContext(context) {
            return false;
        }
     addEventListener(chart, type, listener) {}
     removeEventListener(chart, type, listener) {}
     getDevicePixelRatio() {
            return 1;
        }
     getMaximumSize(element, width, height, aspectRatio) {
            width = Math.max(0, width || element.width);
            height = height || element.height;
            return {
                width,
                height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)
            };
        }
     isAttached(canvas) {
            return true;
        }
     updateConfig(config) {
        }
    }

    class BasicPlatform extends BasePlatform {
        acquireContext(item) {
            return item && item.getContext && item.getContext('2d') || null;
        }
        updateConfig(config) {
            config.options.animation = false;
        }
    }

    const EXPANDO_KEY = '$chartjs';
     const EVENT_TYPES = {
        touchstart: 'mousedown',
        touchmove: 'mousemove',
        touchend: 'mouseup',
        pointerenter: 'mouseenter',
        pointerdown: 'mousedown',
        pointermove: 'mousemove',
        pointerup: 'mouseup',
        pointerleave: 'mouseout',
        pointerout: 'mouseout'
    };
    const isNullOrEmpty = (value)=>value === null || value === '';
     function initCanvas(canvas, aspectRatio) {
        const style = canvas.style;
        const renderHeight = canvas.getAttribute('height');
        const renderWidth = canvas.getAttribute('width');
        canvas[EXPANDO_KEY] = {
            initial: {
                height: renderHeight,
                width: renderWidth,
                style: {
                    display: style.display,
                    height: style.height,
                    width: style.width
                }
            }
        };
        style.display = style.display || 'block';
        style.boxSizing = style.boxSizing || 'border-box';
        if (isNullOrEmpty(renderWidth)) {
            const displayWidth = readUsedSize(canvas, 'width');
            if (displayWidth !== undefined) {
                canvas.width = displayWidth;
            }
        }
        if (isNullOrEmpty(renderHeight)) {
            if (canvas.style.height === '') {
                canvas.height = canvas.width / (aspectRatio || 2);
            } else {
                const displayHeight = readUsedSize(canvas, 'height');
                if (displayHeight !== undefined) {
                    canvas.height = displayHeight;
                }
            }
        }
        return canvas;
    }
    const eventListenerOptions = supportsEventListenerOptions ? {
        passive: true
    } : false;
    function addListener(node, type, listener) {
        if (node) {
            node.addEventListener(type, listener, eventListenerOptions);
        }
    }
    function removeListener(chart, type, listener) {
        if (chart && chart.canvas) {
            chart.canvas.removeEventListener(type, listener, eventListenerOptions);
        }
    }
    function fromNativeEvent(event, chart) {
        const type = EVENT_TYPES[event.type] || event.type;
        const { x , y  } = getRelativePosition(event, chart);
        return {
            type,
            chart,
            native: event,
            x: x !== undefined ? x : null,
            y: y !== undefined ? y : null
        };
    }
    function nodeListContains(nodeList, canvas) {
        for (const node of nodeList){
            if (node === canvas || node.contains(canvas)) {
                return true;
            }
        }
    }
    function createAttachObserver(chart, type, listener) {
        const canvas = chart.canvas;
        const observer = new MutationObserver((entries)=>{
            let trigger = false;
            for (const entry of entries){
                trigger = trigger || nodeListContains(entry.addedNodes, canvas);
                trigger = trigger && !nodeListContains(entry.removedNodes, canvas);
            }
            if (trigger) {
                listener();
            }
        });
        observer.observe(document, {
            childList: true,
            subtree: true
        });
        return observer;
    }
    function createDetachObserver(chart, type, listener) {
        const canvas = chart.canvas;
        const observer = new MutationObserver((entries)=>{
            let trigger = false;
            for (const entry of entries){
                trigger = trigger || nodeListContains(entry.removedNodes, canvas);
                trigger = trigger && !nodeListContains(entry.addedNodes, canvas);
            }
            if (trigger) {
                listener();
            }
        });
        observer.observe(document, {
            childList: true,
            subtree: true
        });
        return observer;
    }
    const drpListeningCharts = new Map();
    let oldDevicePixelRatio = 0;
    function onWindowResize() {
        const dpr = window.devicePixelRatio;
        if (dpr === oldDevicePixelRatio) {
            return;
        }
        oldDevicePixelRatio = dpr;
        drpListeningCharts.forEach((resize, chart)=>{
            if (chart.currentDevicePixelRatio !== dpr) {
                resize();
            }
        });
    }
    function listenDevicePixelRatioChanges(chart, resize) {
        if (!drpListeningCharts.size) {
            window.addEventListener('resize', onWindowResize);
        }
        drpListeningCharts.set(chart, resize);
    }
    function unlistenDevicePixelRatioChanges(chart) {
        drpListeningCharts.delete(chart);
        if (!drpListeningCharts.size) {
            window.removeEventListener('resize', onWindowResize);
        }
    }
    function createResizeObserver(chart, type, listener) {
        const canvas = chart.canvas;
        const container = canvas && _getParentNode(canvas);
        if (!container) {
            return;
        }
        const resize = throttled((width, height)=>{
            const w = container.clientWidth;
            listener(width, height);
            if (w < container.clientWidth) {
                listener();
            }
        }, window);
        const observer = new ResizeObserver((entries)=>{
            const entry = entries[0];
            const width = entry.contentRect.width;
            const height = entry.contentRect.height;
            if (width === 0 && height === 0) {
                return;
            }
            resize(width, height);
        });
        observer.observe(container);
        listenDevicePixelRatioChanges(chart, resize);
        return observer;
    }
    function releaseObserver(chart, type, observer) {
        if (observer) {
            observer.disconnect();
        }
        if (type === 'resize') {
            unlistenDevicePixelRatioChanges(chart);
        }
    }
    function createProxyAndListen(chart, type, listener) {
        const canvas = chart.canvas;
        const proxy = throttled((event)=>{
            if (chart.ctx !== null) {
                listener(fromNativeEvent(event, chart));
            }
        }, chart);
        addListener(canvas, type, proxy);
        return proxy;
    }
     class DomPlatform extends BasePlatform {
     acquireContext(canvas, aspectRatio) {
            const context = canvas && canvas.getContext && canvas.getContext('2d');
            if (context && context.canvas === canvas) {
                initCanvas(canvas, aspectRatio);
                return context;
            }
            return null;
        }
     releaseContext(context) {
            const canvas = context.canvas;
            if (!canvas[EXPANDO_KEY]) {
                return false;
            }
            const initial = canvas[EXPANDO_KEY].initial;
            [
                'height',
                'width'
            ].forEach((prop)=>{
                const value = initial[prop];
                if (isNullOrUndef(value)) {
                    canvas.removeAttribute(prop);
                } else {
                    canvas.setAttribute(prop, value);
                }
            });
            const style = initial.style || {};
            Object.keys(style).forEach((key)=>{
                canvas.style[key] = style[key];
            });
            canvas.width = canvas.width;
            delete canvas[EXPANDO_KEY];
            return true;
        }
     addEventListener(chart, type, listener) {
            this.removeEventListener(chart, type);
            const proxies = chart.$proxies || (chart.$proxies = {});
            const handlers = {
                attach: createAttachObserver,
                detach: createDetachObserver,
                resize: createResizeObserver
            };
            const handler = handlers[type] || createProxyAndListen;
            proxies[type] = handler(chart, type, listener);
        }
     removeEventListener(chart, type) {
            const proxies = chart.$proxies || (chart.$proxies = {});
            const proxy = proxies[type];
            if (!proxy) {
                return;
            }
            const handlers = {
                attach: releaseObserver,
                detach: releaseObserver,
                resize: releaseObserver
            };
            const handler = handlers[type] || removeListener;
            handler(chart, type, proxy);
            proxies[type] = undefined;
        }
        getDevicePixelRatio() {
            return window.devicePixelRatio;
        }
     getMaximumSize(canvas, width, height, aspectRatio) {
            return getMaximumSize(canvas, width, height, aspectRatio);
        }
     isAttached(canvas) {
            const container = canvas && _getParentNode(canvas);
            return !!(container && container.isConnected);
        }
    }

    function _detectPlatform(canvas) {
        if (!_isDomSupported() || typeof OffscreenCanvas !== 'undefined' && canvas instanceof OffscreenCanvas) {
            return BasicPlatform;
        }
        return DomPlatform;
    }

    let Element$1 = class Element {
        static defaults = {};
        static defaultRoutes = undefined;
        x;
        y;
        active = false;
        options;
        $animations;
        tooltipPosition(useFinalPosition) {
            const { x , y  } = this.getProps([
                'x',
                'y'
            ], useFinalPosition);
            return {
                x,
                y
            };
        }
        hasValue() {
            return isNumber(this.x) && isNumber(this.y);
        }
        getProps(props, final) {
            const anims = this.$animations;
            if (!final || !anims) {
                // let's not create an object, if not needed
                return this;
            }
            const ret = {};
            props.forEach((prop)=>{
                ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];
            });
            return ret;
        }
    };

    function autoSkip(scale, ticks) {
        const tickOpts = scale.options.ticks;
        const determinedMaxTicks = determineMaxTicks(scale);
        const ticksLimit = Math.min(tickOpts.maxTicksLimit || determinedMaxTicks, determinedMaxTicks);
        const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];
        const numMajorIndices = majorIndices.length;
        const first = majorIndices[0];
        const last = majorIndices[numMajorIndices - 1];
        const newTicks = [];
        if (numMajorIndices > ticksLimit) {
            skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);
            return newTicks;
        }
        const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);
        if (numMajorIndices > 0) {
            let i, ilen;
            const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;
            skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);
            for(i = 0, ilen = numMajorIndices - 1; i < ilen; i++){
                skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);
            }
            skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);
            return newTicks;
        }
        skip(ticks, newTicks, spacing);
        return newTicks;
    }
    function determineMaxTicks(scale) {
        const offset = scale.options.offset;
        const tickLength = scale._tickSize();
        const maxScale = scale._length / tickLength + (offset ? 0 : 1);
        const maxChart = scale._maxLength / tickLength;
        return Math.floor(Math.min(maxScale, maxChart));
    }
     function calculateSpacing(majorIndices, ticks, ticksLimit) {
        const evenMajorSpacing = getEvenSpacing(majorIndices);
        const spacing = ticks.length / ticksLimit;
        if (!evenMajorSpacing) {
            return Math.max(spacing, 1);
        }
        const factors = _factorize(evenMajorSpacing);
        for(let i = 0, ilen = factors.length - 1; i < ilen; i++){
            const factor = factors[i];
            if (factor > spacing) {
                return factor;
            }
        }
        return Math.max(spacing, 1);
    }
     function getMajorIndices(ticks) {
        const result = [];
        let i, ilen;
        for(i = 0, ilen = ticks.length; i < ilen; i++){
            if (ticks[i].major) {
                result.push(i);
            }
        }
        return result;
    }
     function skipMajors(ticks, newTicks, majorIndices, spacing) {
        let count = 0;
        let next = majorIndices[0];
        let i;
        spacing = Math.ceil(spacing);
        for(i = 0; i < ticks.length; i++){
            if (i === next) {
                newTicks.push(ticks[i]);
                count++;
                next = majorIndices[count * spacing];
            }
        }
    }
     function skip(ticks, newTicks, spacing, majorStart, majorEnd) {
        const start = valueOrDefault(majorStart, 0);
        const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);
        let count = 0;
        let length, i, next;
        spacing = Math.ceil(spacing);
        if (majorEnd) {
            length = majorEnd - majorStart;
            spacing = length / Math.floor(length / spacing);
        }
        next = start;
        while(next < 0){
            count++;
            next = Math.round(start + count * spacing);
        }
        for(i = Math.max(start, 0); i < end; i++){
            if (i === next) {
                newTicks.push(ticks[i]);
                count++;
                next = Math.round(start + count * spacing);
            }
        }
    }
     function getEvenSpacing(arr) {
        const len = arr.length;
        let i, diff;
        if (len < 2) {
            return false;
        }
        for(diff = arr[0], i = 1; i < len; ++i){
            if (arr[i] - arr[i - 1] !== diff) {
                return false;
            }
        }
        return diff;
    }

    const reverseAlign = (align)=>align === 'left' ? 'right' : align === 'right' ? 'left' : align;
    const offsetFromEdge = (scale, edge, offset)=>edge === 'top' || edge === 'left' ? scale[edge] + offset : scale[edge] - offset;
    const getTicksLimit = (ticksLength, maxTicksLimit)=>Math.min(maxTicksLimit || ticksLength, ticksLength);
     function sample(arr, numItems) {
        const result = [];
        const increment = arr.length / numItems;
        const len = arr.length;
        let i = 0;
        for(; i < len; i += increment){
            result.push(arr[Math.floor(i)]);
        }
        return result;
    }
     function getPixelForGridLine(scale, index, offsetGridLines) {
        const length = scale.ticks.length;
        const validIndex = Math.min(index, length - 1);
        const start = scale._startPixel;
        const end = scale._endPixel;
        const epsilon = 1e-6;
        let lineValue = scale.getPixelForTick(validIndex);
        let offset;
        if (offsetGridLines) {
            if (length === 1) {
                offset = Math.max(lineValue - start, end - lineValue);
            } else if (index === 0) {
                offset = (scale.getPixelForTick(1) - lineValue) / 2;
            } else {
                offset = (lineValue - scale.getPixelForTick(validIndex - 1)) / 2;
            }
            lineValue += validIndex < index ? offset : -offset;
            if (lineValue < start - epsilon || lineValue > end + epsilon) {
                return;
            }
        }
        return lineValue;
    }
     function garbageCollect(caches, length) {
        each(caches, (cache)=>{
            const gc = cache.gc;
            const gcLen = gc.length / 2;
            let i;
            if (gcLen > length) {
                for(i = 0; i < gcLen; ++i){
                    delete cache.data[gc[i]];
                }
                gc.splice(0, gcLen);
            }
        });
    }
     function getTickMarkLength(options) {
        return options.drawTicks ? options.tickLength : 0;
    }
     function getTitleHeight(options, fallback) {
        if (!options.display) {
            return 0;
        }
        const font = toFont(options.font, fallback);
        const padding = toPadding(options.padding);
        const lines = isArray$1(options.text) ? options.text.length : 1;
        return lines * font.lineHeight + padding.height;
    }
    function createScaleContext(parent, scale) {
        return createContext(parent, {
            scale,
            type: 'scale'
        });
    }
    function createTickContext(parent, index, tick) {
        return createContext(parent, {
            tick,
            index,
            type: 'tick'
        });
    }
    function titleAlign(align, position, reverse) {
         let ret = _toLeftRightCenter(align);
        if (reverse && position !== 'right' || !reverse && position === 'right') {
            ret = reverseAlign(ret);
        }
        return ret;
    }
    function titleArgs(scale, offset, position, align) {
        const { top , left , bottom , right , chart  } = scale;
        const { chartArea , scales  } = chart;
        let rotation = 0;
        let maxWidth, titleX, titleY;
        const height = bottom - top;
        const width = right - left;
        if (scale.isHorizontal()) {
            titleX = _alignStartEnd(align, left, right);
            if (isObject$1(position)) {
                const positionAxisID = Object.keys(position)[0];
                const value = position[positionAxisID];
                titleY = scales[positionAxisID].getPixelForValue(value) + height - offset;
            } else if (position === 'center') {
                titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;
            } else {
                titleY = offsetFromEdge(scale, position, offset);
            }
            maxWidth = right - left;
        } else {
            if (isObject$1(position)) {
                const positionAxisID = Object.keys(position)[0];
                const value = position[positionAxisID];
                titleX = scales[positionAxisID].getPixelForValue(value) - width + offset;
            } else if (position === 'center') {
                titleX = (chartArea.left + chartArea.right) / 2 - width + offset;
            } else {
                titleX = offsetFromEdge(scale, position, offset);
            }
            titleY = _alignStartEnd(align, bottom, top);
            rotation = position === 'left' ? -HALF_PI : HALF_PI;
        }
        return {
            titleX,
            titleY,
            maxWidth,
            rotation
        };
    }
    class Scale extends Element$1 {
        constructor(cfg){
            super();
             this.id = cfg.id;
             this.type = cfg.type;
             this.options = undefined;
             this.ctx = cfg.ctx;
             this.chart = cfg.chart;
             this.top = undefined;
             this.bottom = undefined;
             this.left = undefined;
             this.right = undefined;
             this.width = undefined;
             this.height = undefined;
            this._margins = {
                left: 0,
                right: 0,
                top: 0,
                bottom: 0
            };
             this.maxWidth = undefined;
             this.maxHeight = undefined;
             this.paddingTop = undefined;
             this.paddingBottom = undefined;
             this.paddingLeft = undefined;
             this.paddingRight = undefined;
             this.axis = undefined;
             this.labelRotation = undefined;
            this.min = undefined;
            this.max = undefined;
            this._range = undefined;
             this.ticks = [];
             this._gridLineItems = null;
             this._labelItems = null;
             this._labelSizes = null;
            this._length = 0;
            this._maxLength = 0;
            this._longestTextCache = {};
             this._startPixel = undefined;
             this._endPixel = undefined;
            this._reversePixels = false;
            this._userMax = undefined;
            this._userMin = undefined;
            this._suggestedMax = undefined;
            this._suggestedMin = undefined;
            this._ticksLength = 0;
            this._borderValue = 0;
            this._cache = {};
            this._dataLimitsCached = false;
            this.$context = undefined;
        }
     init(options) {
            this.options = options.setContext(this.getContext());
            this.axis = options.axis;
            this._userMin = this.parse(options.min);
            this._userMax = this.parse(options.max);
            this._suggestedMin = this.parse(options.suggestedMin);
            this._suggestedMax = this.parse(options.suggestedMax);
        }
     parse(raw, index) {
            return raw;
        }
     getUserBounds() {
            let { _userMin , _userMax , _suggestedMin , _suggestedMax  } = this;
            _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);
            _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);
            _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);
            _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);
            return {
                min: finiteOrDefault(_userMin, _suggestedMin),
                max: finiteOrDefault(_userMax, _suggestedMax),
                minDefined: isNumberFinite(_userMin),
                maxDefined: isNumberFinite(_userMax)
            };
        }
     getMinMax(canStack) {
            let { min , max , minDefined , maxDefined  } = this.getUserBounds();
            let range;
            if (minDefined && maxDefined) {
                return {
                    min,
                    max
                };
            }
            const metas = this.getMatchingVisibleMetas();
            for(let i = 0, ilen = metas.length; i < ilen; ++i){
                range = metas[i].controller.getMinMax(this, canStack);
                if (!minDefined) {
                    min = Math.min(min, range.min);
                }
                if (!maxDefined) {
                    max = Math.max(max, range.max);
                }
            }
            min = maxDefined && min > max ? max : min;
            max = minDefined && min > max ? min : max;
            return {
                min: finiteOrDefault(min, finiteOrDefault(max, min)),
                max: finiteOrDefault(max, finiteOrDefault(min, max))
            };
        }
     getPadding() {
            return {
                left: this.paddingLeft || 0,
                top: this.paddingTop || 0,
                right: this.paddingRight || 0,
                bottom: this.paddingBottom || 0
            };
        }
     getTicks() {
            return this.ticks;
        }
     getLabels() {
            const data = this.chart.data;
            return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];
        }
     getLabelItems(chartArea = this.chart.chartArea) {
            const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));
            return items;
        }
        beforeLayout() {
            this._cache = {};
            this._dataLimitsCached = false;
        }
        beforeUpdate() {
            callback(this.options.beforeUpdate, [
                this
            ]);
        }
     update(maxWidth, maxHeight, margins) {
            const { beginAtZero , grace , ticks: tickOpts  } = this.options;
            const sampleSize = tickOpts.sampleSize;
            this.beforeUpdate();
            this.maxWidth = maxWidth;
            this.maxHeight = maxHeight;
            this._margins = margins = Object.assign({
                left: 0,
                right: 0,
                top: 0,
                bottom: 0
            }, margins);
            this.ticks = null;
            this._labelSizes = null;
            this._gridLineItems = null;
            this._labelItems = null;
            this.beforeSetDimensions();
            this.setDimensions();
            this.afterSetDimensions();
            this._maxLength = this.isHorizontal() ? this.width + margins.left + margins.right : this.height + margins.top + margins.bottom;
            if (!this._dataLimitsCached) {
                this.beforeDataLimits();
                this.determineDataLimits();
                this.afterDataLimits();
                this._range = _addGrace(this, grace, beginAtZero);
                this._dataLimitsCached = true;
            }
            this.beforeBuildTicks();
            this.ticks = this.buildTicks() || [];
            this.afterBuildTicks();
            const samplingEnabled = sampleSize < this.ticks.length;
            this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);
            this.configure();
            this.beforeCalculateLabelRotation();
            this.calculateLabelRotation();
            this.afterCalculateLabelRotation();
            if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === 'auto')) {
                this.ticks = autoSkip(this, this.ticks);
                this._labelSizes = null;
                this.afterAutoSkip();
            }
            if (samplingEnabled) {
                this._convertTicksToLabels(this.ticks);
            }
            this.beforeFit();
            this.fit();
            this.afterFit();
            this.afterUpdate();
        }
     configure() {
            let reversePixels = this.options.reverse;
            let startPixel, endPixel;
            if (this.isHorizontal()) {
                startPixel = this.left;
                endPixel = this.right;
            } else {
                startPixel = this.top;
                endPixel = this.bottom;
                reversePixels = !reversePixels;
            }
            this._startPixel = startPixel;
            this._endPixel = endPixel;
            this._reversePixels = reversePixels;
            this._length = endPixel - startPixel;
            this._alignToPixels = this.options.alignToPixels;
        }
        afterUpdate() {
            callback(this.options.afterUpdate, [
                this
            ]);
        }
        beforeSetDimensions() {
            callback(this.options.beforeSetDimensions, [
                this
            ]);
        }
        setDimensions() {
            if (this.isHorizontal()) {
                this.width = this.maxWidth;
                this.left = 0;
                this.right = this.width;
            } else {
                this.height = this.maxHeight;
                this.top = 0;
                this.bottom = this.height;
            }
            this.paddingLeft = 0;
            this.paddingTop = 0;
            this.paddingRight = 0;
            this.paddingBottom = 0;
        }
        afterSetDimensions() {
            callback(this.options.afterSetDimensions, [
                this
            ]);
        }
        _callHooks(name) {
            this.chart.notifyPlugins(name, this.getContext());
            callback(this.options[name], [
                this
            ]);
        }
        beforeDataLimits() {
            this._callHooks('beforeDataLimits');
        }
        determineDataLimits() {}
        afterDataLimits() {
            this._callHooks('afterDataLimits');
        }
        beforeBuildTicks() {
            this._callHooks('beforeBuildTicks');
        }
     buildTicks() {
            return [];
        }
        afterBuildTicks() {
            this._callHooks('afterBuildTicks');
        }
        beforeTickToLabelConversion() {
            callback(this.options.beforeTickToLabelConversion, [
                this
            ]);
        }
     generateTickLabels(ticks) {
            const tickOpts = this.options.ticks;
            let i, ilen, tick;
            for(i = 0, ilen = ticks.length; i < ilen; i++){
                tick = ticks[i];
                tick.label = callback(tickOpts.callback, [
                    tick.value,
                    i,
                    ticks
                ], this);
            }
        }
        afterTickToLabelConversion() {
            callback(this.options.afterTickToLabelConversion, [
                this
            ]);
        }
        beforeCalculateLabelRotation() {
            callback(this.options.beforeCalculateLabelRotation, [
                this
            ]);
        }
        calculateLabelRotation() {
            const options = this.options;
            const tickOpts = options.ticks;
            const numTicks = getTicksLimit(this.ticks.length, options.ticks.maxTicksLimit);
            const minRotation = tickOpts.minRotation || 0;
            const maxRotation = tickOpts.maxRotation;
            let labelRotation = minRotation;
            let tickWidth, maxHeight, maxLabelDiagonal;
            if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {
                this.labelRotation = minRotation;
                return;
            }
            const labelSizes = this._getLabelSizes();
            const maxLabelWidth = labelSizes.widest.width;
            const maxLabelHeight = labelSizes.highest.height;
            const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);
            tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);
            if (maxLabelWidth + 6 > tickWidth) {
                tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));
                maxHeight = this.maxHeight - getTickMarkLength(options.grid) - tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);
                maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);
                labelRotation = toDegrees(Math.min(Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)), Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))));
                labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
            }
            this.labelRotation = labelRotation;
        }
        afterCalculateLabelRotation() {
            callback(this.options.afterCalculateLabelRotation, [
                this
            ]);
        }
        afterAutoSkip() {}
        beforeFit() {
            callback(this.options.beforeFit, [
                this
            ]);
        }
        fit() {
            const minSize = {
                width: 0,
                height: 0
            };
            const { chart , options: { ticks: tickOpts , title: titleOpts , grid: gridOpts  }  } = this;
            const display = this._isVisible();
            const isHorizontal = this.isHorizontal();
            if (display) {
                const titleHeight = getTitleHeight(titleOpts, chart.options.font);
                if (isHorizontal) {
                    minSize.width = this.maxWidth;
                    minSize.height = getTickMarkLength(gridOpts) + titleHeight;
                } else {
                    minSize.height = this.maxHeight;
                    minSize.width = getTickMarkLength(gridOpts) + titleHeight;
                }
                if (tickOpts.display && this.ticks.length) {
                    const { first , last , widest , highest  } = this._getLabelSizes();
                    const tickPadding = tickOpts.padding * 2;
                    const angleRadians = toRadians(this.labelRotation);
                    const cos = Math.cos(angleRadians);
                    const sin = Math.sin(angleRadians);
                    if (isHorizontal) {
                        const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;
                        minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);
                    } else {
                        const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;
                        minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);
                    }
                    this._calculatePadding(first, last, sin, cos);
                }
            }
            this._handleMargins();
            if (isHorizontal) {
                this.width = this._length = chart.width - this._margins.left - this._margins.right;
                this.height = minSize.height;
            } else {
                this.width = minSize.width;
                this.height = this._length = chart.height - this._margins.top - this._margins.bottom;
            }
        }
        _calculatePadding(first, last, sin, cos) {
            const { ticks: { align , padding  } , position  } = this.options;
            const isRotated = this.labelRotation !== 0;
            const labelsBelowTicks = position !== 'top' && this.axis === 'x';
            if (this.isHorizontal()) {
                const offsetLeft = this.getPixelForTick(0) - this.left;
                const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);
                let paddingLeft = 0;
                let paddingRight = 0;
                if (isRotated) {
                    if (labelsBelowTicks) {
                        paddingLeft = cos * first.width;
                        paddingRight = sin * last.height;
                    } else {
                        paddingLeft = sin * first.height;
                        paddingRight = cos * last.width;
                    }
                } else if (align === 'start') {
                    paddingRight = last.width;
                } else if (align === 'end') {
                    paddingLeft = first.width;
                } else if (align !== 'inner') {
                    paddingLeft = first.width / 2;
                    paddingRight = last.width / 2;
                }
                this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);
                this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);
            } else {
                let paddingTop = last.height / 2;
                let paddingBottom = first.height / 2;
                if (align === 'start') {
                    paddingTop = 0;
                    paddingBottom = first.height;
                } else if (align === 'end') {
                    paddingTop = last.height;
                    paddingBottom = 0;
                }
                this.paddingTop = paddingTop + padding;
                this.paddingBottom = paddingBottom + padding;
            }
        }
     _handleMargins() {
            if (this._margins) {
                this._margins.left = Math.max(this.paddingLeft, this._margins.left);
                this._margins.top = Math.max(this.paddingTop, this._margins.top);
                this._margins.right = Math.max(this.paddingRight, this._margins.right);
                this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);
            }
        }
        afterFit() {
            callback(this.options.afterFit, [
                this
            ]);
        }
     isHorizontal() {
            const { axis , position  } = this.options;
            return position === 'top' || position === 'bottom' || axis === 'x';
        }
     isFullSize() {
            return this.options.fullSize;
        }
     _convertTicksToLabels(ticks) {
            this.beforeTickToLabelConversion();
            this.generateTickLabels(ticks);
            let i, ilen;
            for(i = 0, ilen = ticks.length; i < ilen; i++){
                if (isNullOrUndef(ticks[i].label)) {
                    ticks.splice(i, 1);
                    ilen--;
                    i--;
                }
            }
            this.afterTickToLabelConversion();
        }
     _getLabelSizes() {
            let labelSizes = this._labelSizes;
            if (!labelSizes) {
                const sampleSize = this.options.ticks.sampleSize;
                let ticks = this.ticks;
                if (sampleSize < ticks.length) {
                    ticks = sample(ticks, sampleSize);
                }
                this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length, this.options.ticks.maxTicksLimit);
            }
            return labelSizes;
        }
     _computeLabelSizes(ticks, length, maxTicksLimit) {
            const { ctx , _longestTextCache: caches  } = this;
            const widths = [];
            const heights = [];
            const increment = Math.floor(length / getTicksLimit(length, maxTicksLimit));
            let widestLabelSize = 0;
            let highestLabelSize = 0;
            let i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;
            for(i = 0; i < length; i += increment){
                label = ticks[i].label;
                tickFont = this._resolveTickFontOptions(i);
                ctx.font = fontString = tickFont.string;
                cache = caches[fontString] = caches[fontString] || {
                    data: {},
                    gc: []
                };
                lineHeight = tickFont.lineHeight;
                width = height = 0;
                if (!isNullOrUndef(label) && !isArray$1(label)) {
                    width = _measureText(ctx, cache.data, cache.gc, width, label);
                    height = lineHeight;
                } else if (isArray$1(label)) {
                    for(j = 0, jlen = label.length; j < jlen; ++j){
                        nestedLabel =  label[j];
                        if (!isNullOrUndef(nestedLabel) && !isArray$1(nestedLabel)) {
                            width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel);
                            height += lineHeight;
                        }
                    }
                }
                widths.push(width);
                heights.push(height);
                widestLabelSize = Math.max(width, widestLabelSize);
                highestLabelSize = Math.max(height, highestLabelSize);
            }
            garbageCollect(caches, length);
            const widest = widths.indexOf(widestLabelSize);
            const highest = heights.indexOf(highestLabelSize);
            const valueAt = (idx)=>({
                    width: widths[idx] || 0,
                    height: heights[idx] || 0
                });
            return {
                first: valueAt(0),
                last: valueAt(length - 1),
                widest: valueAt(widest),
                highest: valueAt(highest),
                widths,
                heights
            };
        }
     getLabelForValue(value) {
            return value;
        }
     getPixelForValue(value, index) {
            return NaN;
        }
     getValueForPixel(pixel) {}
     getPixelForTick(index) {
            const ticks = this.ticks;
            if (index < 0 || index > ticks.length - 1) {
                return null;
            }
            return this.getPixelForValue(ticks[index].value);
        }
     getPixelForDecimal(decimal) {
            if (this._reversePixels) {
                decimal = 1 - decimal;
            }
            const pixel = this._startPixel + decimal * this._length;
            return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);
        }
     getDecimalForPixel(pixel) {
            const decimal = (pixel - this._startPixel) / this._length;
            return this._reversePixels ? 1 - decimal : decimal;
        }
     getBasePixel() {
            return this.getPixelForValue(this.getBaseValue());
        }
     getBaseValue() {
            const { min , max  } = this;
            return min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;
        }
     getContext(index) {
            const ticks = this.ticks || [];
            if (index >= 0 && index < ticks.length) {
                const tick = ticks[index];
                return tick.$context || (tick.$context = createTickContext(this.getContext(), index, tick));
            }
            return this.$context || (this.$context = createScaleContext(this.chart.getContext(), this));
        }
     _tickSize() {
            const optionTicks = this.options.ticks;
            const rot = toRadians(this.labelRotation);
            const cos = Math.abs(Math.cos(rot));
            const sin = Math.abs(Math.sin(rot));
            const labelSizes = this._getLabelSizes();
            const padding = optionTicks.autoSkipPadding || 0;
            const w = labelSizes ? labelSizes.widest.width + padding : 0;
            const h = labelSizes ? labelSizes.highest.height + padding : 0;
            return this.isHorizontal() ? h * cos > w * sin ? w / cos : h / sin : h * sin < w * cos ? h / cos : w / sin;
        }
     _isVisible() {
            const display = this.options.display;
            if (display !== 'auto') {
                return !!display;
            }
            return this.getMatchingVisibleMetas().length > 0;
        }
     _computeGridLineItems(chartArea) {
            const axis = this.axis;
            const chart = this.chart;
            const options = this.options;
            const { grid , position , border  } = options;
            const offset = grid.offset;
            const isHorizontal = this.isHorizontal();
            const ticks = this.ticks;
            const ticksLength = ticks.length + (offset ? 1 : 0);
            const tl = getTickMarkLength(grid);
            const items = [];
            const borderOpts = border.setContext(this.getContext());
            const axisWidth = borderOpts.display ? borderOpts.width : 0;
            const axisHalfWidth = axisWidth / 2;
            const alignBorderValue = function(pixel) {
                return _alignPixel(chart, pixel, axisWidth);
            };
            let borderValue, i, lineValue, alignedLineValue;
            let tx1, ty1, tx2, ty2, x1, y1, x2, y2;
            if (position === 'top') {
                borderValue = alignBorderValue(this.bottom);
                ty1 = this.bottom - tl;
                ty2 = borderValue - axisHalfWidth;
                y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
                y2 = chartArea.bottom;
            } else if (position === 'bottom') {
                borderValue = alignBorderValue(this.top);
                y1 = chartArea.top;
                y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
                ty1 = borderValue + axisHalfWidth;
                ty2 = this.top + tl;
            } else if (position === 'left') {
                borderValue = alignBorderValue(this.right);
                tx1 = this.right - tl;
                tx2 = borderValue - axisHalfWidth;
                x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
                x2 = chartArea.right;
            } else if (position === 'right') {
                borderValue = alignBorderValue(this.left);
                x1 = chartArea.left;
                x2 = alignBorderValue(chartArea.right) - axisHalfWidth;
                tx1 = borderValue + axisHalfWidth;
                tx2 = this.left + tl;
            } else if (axis === 'x') {
                if (position === 'center') {
                    borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);
                } else if (isObject$1(position)) {
                    const positionAxisID = Object.keys(position)[0];
                    const value = position[positionAxisID];
                    borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
                }
                y1 = chartArea.top;
                y2 = chartArea.bottom;
                ty1 = borderValue + axisHalfWidth;
                ty2 = ty1 + tl;
            } else if (axis === 'y') {
                if (position === 'center') {
                    borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);
                } else if (isObject$1(position)) {
                    const positionAxisID = Object.keys(position)[0];
                    const value = position[positionAxisID];
                    borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
                }
                tx1 = borderValue - axisHalfWidth;
                tx2 = tx1 - tl;
                x1 = chartArea.left;
                x2 = chartArea.right;
            }
            const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);
            const step = Math.max(1, Math.ceil(ticksLength / limit));
            for(i = 0; i < ticksLength; i += step){
                const context = this.getContext(i);
                const optsAtIndex = grid.setContext(context);
                const optsAtIndexBorder = border.setContext(context);
                const lineWidth = optsAtIndex.lineWidth;
                const lineColor = optsAtIndex.color;
                const borderDash = optsAtIndexBorder.dash || [];
                const borderDashOffset = optsAtIndexBorder.dashOffset;
                const tickWidth = optsAtIndex.tickWidth;
                const tickColor = optsAtIndex.tickColor;
                const tickBorderDash = optsAtIndex.tickBorderDash || [];
                const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;
                lineValue = getPixelForGridLine(this, i, offset);
                if (lineValue === undefined) {
                    continue;
                }
                alignedLineValue = _alignPixel(chart, lineValue, lineWidth);
                if (isHorizontal) {
                    tx1 = tx2 = x1 = x2 = alignedLineValue;
                } else {
                    ty1 = ty2 = y1 = y2 = alignedLineValue;
                }
                items.push({
                    tx1,
                    ty1,
                    tx2,
                    ty2,
                    x1,
                    y1,
                    x2,
                    y2,
                    width: lineWidth,
                    color: lineColor,
                    borderDash,
                    borderDashOffset,
                    tickWidth,
                    tickColor,
                    tickBorderDash,
                    tickBorderDashOffset
                });
            }
            this._ticksLength = ticksLength;
            this._borderValue = borderValue;
            return items;
        }
     _computeLabelItems(chartArea) {
            const axis = this.axis;
            const options = this.options;
            const { position , ticks: optionTicks  } = options;
            const isHorizontal = this.isHorizontal();
            const ticks = this.ticks;
            const { align , crossAlign , padding , mirror  } = optionTicks;
            const tl = getTickMarkLength(options.grid);
            const tickAndPadding = tl + padding;
            const hTickAndPadding = mirror ? -padding : tickAndPadding;
            const rotation = -toRadians(this.labelRotation);
            const items = [];
            let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;
            let textBaseline = 'middle';
            if (position === 'top') {
                y = this.bottom - hTickAndPadding;
                textAlign = this._getXAxisLabelAlignment();
            } else if (position === 'bottom') {
                y = this.top + hTickAndPadding;
                textAlign = this._getXAxisLabelAlignment();
            } else if (position === 'left') {
                const ret = this._getYAxisLabelAlignment(tl);
                textAlign = ret.textAlign;
                x = ret.x;
            } else if (position === 'right') {
                const ret = this._getYAxisLabelAlignment(tl);
                textAlign = ret.textAlign;
                x = ret.x;
            } else if (axis === 'x') {
                if (position === 'center') {
                    y = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;
                } else if (isObject$1(position)) {
                    const positionAxisID = Object.keys(position)[0];
                    const value = position[positionAxisID];
                    y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;
                }
                textAlign = this._getXAxisLabelAlignment();
            } else if (axis === 'y') {
                if (position === 'center') {
                    x = (chartArea.left + chartArea.right) / 2 - tickAndPadding;
                } else if (isObject$1(position)) {
                    const positionAxisID = Object.keys(position)[0];
                    const value = position[positionAxisID];
                    x = this.chart.scales[positionAxisID].getPixelForValue(value);
                }
                textAlign = this._getYAxisLabelAlignment(tl).textAlign;
            }
            if (axis === 'y') {
                if (align === 'start') {
                    textBaseline = 'top';
                } else if (align === 'end') {
                    textBaseline = 'bottom';
                }
            }
            const labelSizes = this._getLabelSizes();
            for(i = 0, ilen = ticks.length; i < ilen; ++i){
                tick = ticks[i];
                label = tick.label;
                const optsAtIndex = optionTicks.setContext(this.getContext(i));
                pixel = this.getPixelForTick(i) + optionTicks.labelOffset;
                font = this._resolveTickFontOptions(i);
                lineHeight = font.lineHeight;
                lineCount = isArray$1(label) ? label.length : 1;
                const halfCount = lineCount / 2;
                const color = optsAtIndex.color;
                const strokeColor = optsAtIndex.textStrokeColor;
                const strokeWidth = optsAtIndex.textStrokeWidth;
                let tickTextAlign = textAlign;
                if (isHorizontal) {
                    x = pixel;
                    if (textAlign === 'inner') {
                        if (i === ilen - 1) {
                            tickTextAlign = !this.options.reverse ? 'right' : 'left';
                        } else if (i === 0) {
                            tickTextAlign = !this.options.reverse ? 'left' : 'right';
                        } else {
                            tickTextAlign = 'center';
                        }
                    }
                    if (position === 'top') {
                        if (crossAlign === 'near' || rotation !== 0) {
                            textOffset = -lineCount * lineHeight + lineHeight / 2;
                        } else if (crossAlign === 'center') {
                            textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;
                        } else {
                            textOffset = -labelSizes.highest.height + lineHeight / 2;
                        }
                    } else {
                        if (crossAlign === 'near' || rotation !== 0) {
                            textOffset = lineHeight / 2;
                        } else if (crossAlign === 'center') {
                            textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;
                        } else {
                            textOffset = labelSizes.highest.height - lineCount * lineHeight;
                        }
                    }
                    if (mirror) {
                        textOffset *= -1;
                    }
                    if (rotation !== 0 && !optsAtIndex.showLabelBackdrop) {
                        x += lineHeight / 2 * Math.sin(rotation);
                    }
                } else {
                    y = pixel;
                    textOffset = (1 - lineCount) * lineHeight / 2;
                }
                let backdrop;
                if (optsAtIndex.showLabelBackdrop) {
                    const labelPadding = toPadding(optsAtIndex.backdropPadding);
                    const height = labelSizes.heights[i];
                    const width = labelSizes.widths[i];
                    let top = textOffset - labelPadding.top;
                    let left = 0 - labelPadding.left;
                    switch(textBaseline){
                        case 'middle':
                            top -= height / 2;
                            break;
                        case 'bottom':
                            top -= height;
                            break;
                    }
                    switch(textAlign){
                        case 'center':
                            left -= width / 2;
                            break;
                        case 'right':
                            left -= width;
                            break;
                        case 'inner':
                            if (i === ilen - 1) {
                                left -= width;
                            } else if (i > 0) {
                                left -= width / 2;
                            }
                            break;
                    }
                    backdrop = {
                        left,
                        top,
                        width: width + labelPadding.width,
                        height: height + labelPadding.height,
                        color: optsAtIndex.backdropColor
                    };
                }
                items.push({
                    label,
                    font,
                    textOffset,
                    options: {
                        rotation,
                        color,
                        strokeColor,
                        strokeWidth,
                        textAlign: tickTextAlign,
                        textBaseline,
                        translation: [
                            x,
                            y
                        ],
                        backdrop
                    }
                });
            }
            return items;
        }
        _getXAxisLabelAlignment() {
            const { position , ticks  } = this.options;
            const rotation = -toRadians(this.labelRotation);
            if (rotation) {
                return position === 'top' ? 'left' : 'right';
            }
            let align = 'center';
            if (ticks.align === 'start') {
                align = 'left';
            } else if (ticks.align === 'end') {
                align = 'right';
            } else if (ticks.align === 'inner') {
                align = 'inner';
            }
            return align;
        }
        _getYAxisLabelAlignment(tl) {
            const { position , ticks: { crossAlign , mirror , padding  }  } = this.options;
            const labelSizes = this._getLabelSizes();
            const tickAndPadding = tl + padding;
            const widest = labelSizes.widest.width;
            let textAlign;
            let x;
            if (position === 'left') {
                if (mirror) {
                    x = this.right + padding;
                    if (crossAlign === 'near') {
                        textAlign = 'left';
                    } else if (crossAlign === 'center') {
                        textAlign = 'center';
                        x += widest / 2;
                    } else {
                        textAlign = 'right';
                        x += widest;
                    }
                } else {
                    x = this.right - tickAndPadding;
                    if (crossAlign === 'near') {
                        textAlign = 'right';
                    } else if (crossAlign === 'center') {
                        textAlign = 'center';
                        x -= widest / 2;
                    } else {
                        textAlign = 'left';
                        x = this.left;
                    }
                }
            } else if (position === 'right') {
                if (mirror) {
                    x = this.left + padding;
                    if (crossAlign === 'near') {
                        textAlign = 'right';
                    } else if (crossAlign === 'center') {
                        textAlign = 'center';
                        x -= widest / 2;
                    } else {
                        textAlign = 'left';
                        x -= widest;
                    }
                } else {
                    x = this.left + tickAndPadding;
                    if (crossAlign === 'near') {
                        textAlign = 'left';
                    } else if (crossAlign === 'center') {
                        textAlign = 'center';
                        x += widest / 2;
                    } else {
                        textAlign = 'right';
                        x = this.right;
                    }
                }
            } else {
                textAlign = 'right';
            }
            return {
                textAlign,
                x
            };
        }
     _computeLabelArea() {
            if (this.options.ticks.mirror) {
                return;
            }
            const chart = this.chart;
            const position = this.options.position;
            if (position === 'left' || position === 'right') {
                return {
                    top: 0,
                    left: this.left,
                    bottom: chart.height,
                    right: this.right
                };
            }
            if (position === 'top' || position === 'bottom') {
                return {
                    top: this.top,
                    left: 0,
                    bottom: this.bottom,
                    right: chart.width
                };
            }
        }
     drawBackground() {
            const { ctx , options: { backgroundColor  } , left , top , width , height  } = this;
            if (backgroundColor) {
                ctx.save();
                ctx.fillStyle = backgroundColor;
                ctx.fillRect(left, top, width, height);
                ctx.restore();
            }
        }
        getLineWidthForValue(value) {
            const grid = this.options.grid;
            if (!this._isVisible() || !grid.display) {
                return 0;
            }
            const ticks = this.ticks;
            const index = ticks.findIndex((t)=>t.value === value);
            if (index >= 0) {
                const opts = grid.setContext(this.getContext(index));
                return opts.lineWidth;
            }
            return 0;
        }
     drawGrid(chartArea) {
            const grid = this.options.grid;
            const ctx = this.ctx;
            const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));
            let i, ilen;
            const drawLine = (p1, p2, style)=>{
                if (!style.width || !style.color) {
                    return;
                }
                ctx.save();
                ctx.lineWidth = style.width;
                ctx.strokeStyle = style.color;
                ctx.setLineDash(style.borderDash || []);
                ctx.lineDashOffset = style.borderDashOffset;
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.stroke();
                ctx.restore();
            };
            if (grid.display) {
                for(i = 0, ilen = items.length; i < ilen; ++i){
                    const item = items[i];
                    if (grid.drawOnChartArea) {
                        drawLine({
                            x: item.x1,
                            y: item.y1
                        }, {
                            x: item.x2,
                            y: item.y2
                        }, item);
                    }
                    if (grid.drawTicks) {
                        drawLine({
                            x: item.tx1,
                            y: item.ty1
                        }, {
                            x: item.tx2,
                            y: item.ty2
                        }, {
                            color: item.tickColor,
                            width: item.tickWidth,
                            borderDash: item.tickBorderDash,
                            borderDashOffset: item.tickBorderDashOffset
                        });
                    }
                }
            }
        }
     drawBorder() {
            const { chart , ctx , options: { border , grid  }  } = this;
            const borderOpts = border.setContext(this.getContext());
            const axisWidth = border.display ? borderOpts.width : 0;
            if (!axisWidth) {
                return;
            }
            const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;
            const borderValue = this._borderValue;
            let x1, x2, y1, y2;
            if (this.isHorizontal()) {
                x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;
                x2 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;
                y1 = y2 = borderValue;
            } else {
                y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;
                y2 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;
                x1 = x2 = borderValue;
            }
            ctx.save();
            ctx.lineWidth = borderOpts.width;
            ctx.strokeStyle = borderOpts.color;
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
            ctx.restore();
        }
     drawLabels(chartArea) {
            const optionTicks = this.options.ticks;
            if (!optionTicks.display) {
                return;
            }
            const ctx = this.ctx;
            const area = this._computeLabelArea();
            if (area) {
                clipArea(ctx, area);
            }
            const items = this.getLabelItems(chartArea);
            for (const item of items){
                const renderTextOptions = item.options;
                const tickFont = item.font;
                const label = item.label;
                const y = item.textOffset;
                renderText(ctx, label, 0, y, tickFont, renderTextOptions);
            }
            if (area) {
                unclipArea(ctx);
            }
        }
     drawTitle() {
            const { ctx , options: { position , title , reverse  }  } = this;
            if (!title.display) {
                return;
            }
            const font = toFont(title.font);
            const padding = toPadding(title.padding);
            const align = title.align;
            let offset = font.lineHeight / 2;
            if (position === 'bottom' || position === 'center' || isObject$1(position)) {
                offset += padding.bottom;
                if (isArray$1(title.text)) {
                    offset += font.lineHeight * (title.text.length - 1);
                }
            } else {
                offset += padding.top;
            }
            const { titleX , titleY , maxWidth , rotation  } = titleArgs(this, offset, position, align);
            renderText(ctx, title.text, 0, 0, font, {
                color: title.color,
                maxWidth,
                rotation,
                textAlign: titleAlign(align, position, reverse),
                textBaseline: 'middle',
                translation: [
                    titleX,
                    titleY
                ]
            });
        }
        draw(chartArea) {
            if (!this._isVisible()) {
                return;
            }
            this.drawBackground();
            this.drawGrid(chartArea);
            this.drawBorder();
            this.drawTitle();
            this.drawLabels(chartArea);
        }
     _layers() {
            const opts = this.options;
            const tz = opts.ticks && opts.ticks.z || 0;
            const gz = valueOrDefault(opts.grid && opts.grid.z, -1);
            const bz = valueOrDefault(opts.border && opts.border.z, 0);
            if (!this._isVisible() || this.draw !== Scale.prototype.draw) {
                return [
                    {
                        z: tz,
                        draw: (chartArea)=>{
                            this.draw(chartArea);
                        }
                    }
                ];
            }
            return [
                {
                    z: gz,
                    draw: (chartArea)=>{
                        this.drawBackground();
                        this.drawGrid(chartArea);
                        this.drawTitle();
                    }
                },
                {
                    z: bz,
                    draw: ()=>{
                        this.drawBorder();
                    }
                },
                {
                    z: tz,
                    draw: (chartArea)=>{
                        this.drawLabels(chartArea);
                    }
                }
            ];
        }
     getMatchingVisibleMetas(type) {
            const metas = this.chart.getSortedVisibleDatasetMetas();
            const axisID = this.axis + 'AxisID';
            const result = [];
            let i, ilen;
            for(i = 0, ilen = metas.length; i < ilen; ++i){
                const meta = metas[i];
                if (meta[axisID] === this.id && (!type || meta.type === type)) {
                    result.push(meta);
                }
            }
            return result;
        }
     _resolveTickFontOptions(index) {
            const opts = this.options.ticks.setContext(this.getContext(index));
            return toFont(opts.font);
        }
     _maxDigits() {
            const fontSize = this._resolveTickFontOptions(0).lineHeight;
            return (this.isHorizontal() ? this.width : this.height) / fontSize;
        }
    }

    class TypedRegistry {
        constructor(type, scope, override){
            this.type = type;
            this.scope = scope;
            this.override = override;
            this.items = Object.create(null);
        }
        isForType(type) {
            return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);
        }
     register(item) {
            const proto = Object.getPrototypeOf(item);
            let parentScope;
            if (isIChartComponent(proto)) {
                parentScope = this.register(proto);
            }
            const items = this.items;
            const id = item.id;
            const scope = this.scope + '.' + id;
            if (!id) {
                throw new Error('class does not have id: ' + item);
            }
            if (id in items) {
                return scope;
            }
            items[id] = item;
            registerDefaults(item, scope, parentScope);
            if (this.override) {
                defaults$1.override(item.id, item.overrides);
            }
            return scope;
        }
     get(id) {
            return this.items[id];
        }
     unregister(item) {
            const items = this.items;
            const id = item.id;
            const scope = this.scope;
            if (id in items) {
                delete items[id];
            }
            if (scope && id in defaults$1[scope]) {
                delete defaults$1[scope][id];
                if (this.override) {
                    delete overrides[id];
                }
            }
        }
    }
    function registerDefaults(item, scope, parentScope) {
        const itemDefaults = merge(Object.create(null), [
            parentScope ? defaults$1.get(parentScope) : {},
            defaults$1.get(scope),
            item.defaults
        ]);
        defaults$1.set(scope, itemDefaults);
        if (item.defaultRoutes) {
            routeDefaults(scope, item.defaultRoutes);
        }
        if (item.descriptors) {
            defaults$1.describe(scope, item.descriptors);
        }
    }
    function routeDefaults(scope, routes) {
        Object.keys(routes).forEach((property)=>{
            const propertyParts = property.split('.');
            const sourceName = propertyParts.pop();
            const sourceScope = [
                scope
            ].concat(propertyParts).join('.');
            const parts = routes[property].split('.');
            const targetName = parts.pop();
            const targetScope = parts.join('.');
            defaults$1.route(sourceScope, sourceName, targetScope, targetName);
        });
    }
    function isIChartComponent(proto) {
        return 'id' in proto && 'defaults' in proto;
    }

    class Registry {
        constructor(){
            this.controllers = new TypedRegistry(DatasetController, 'datasets', true);
            this.elements = new TypedRegistry(Element$1, 'elements');
            this.plugins = new TypedRegistry(Object, 'plugins');
            this.scales = new TypedRegistry(Scale, 'scales');
            this._typedRegistries = [
                this.controllers,
                this.scales,
                this.elements
            ];
        }
     add(...args) {
            this._each('register', args);
        }
        remove(...args) {
            this._each('unregister', args);
        }
     addControllers(...args) {
            this._each('register', args, this.controllers);
        }
     addElements(...args) {
            this._each('register', args, this.elements);
        }
     addPlugins(...args) {
            this._each('register', args, this.plugins);
        }
     addScales(...args) {
            this._each('register', args, this.scales);
        }
     getController(id) {
            return this._get(id, this.controllers, 'controller');
        }
     getElement(id) {
            return this._get(id, this.elements, 'element');
        }
     getPlugin(id) {
            return this._get(id, this.plugins, 'plugin');
        }
     getScale(id) {
            return this._get(id, this.scales, 'scale');
        }
     removeControllers(...args) {
            this._each('unregister', args, this.controllers);
        }
     removeElements(...args) {
            this._each('unregister', args, this.elements);
        }
     removePlugins(...args) {
            this._each('unregister', args, this.plugins);
        }
     removeScales(...args) {
            this._each('unregister', args, this.scales);
        }
     _each(method, args, typedRegistry) {
            [
                ...args
            ].forEach((arg)=>{
                const reg = typedRegistry || this._getRegistryForType(arg);
                if (typedRegistry || reg.isForType(arg) || reg === this.plugins && arg.id) {
                    this._exec(method, reg, arg);
                } else {
                    each(arg, (item)=>{
                        const itemReg = typedRegistry || this._getRegistryForType(item);
                        this._exec(method, itemReg, item);
                    });
                }
            });
        }
     _exec(method, registry, component) {
            const camelMethod = _capitalize(method);
            callback(component['before' + camelMethod], [], component);
            registry[method](component);
            callback(component['after' + camelMethod], [], component);
        }
     _getRegistryForType(type) {
            for(let i = 0; i < this._typedRegistries.length; i++){
                const reg = this._typedRegistries[i];
                if (reg.isForType(type)) {
                    return reg;
                }
            }
            return this.plugins;
        }
     _get(id, typedRegistry, type) {
            const item = typedRegistry.get(id);
            if (item === undefined) {
                throw new Error('"' + id + '" is not a registered ' + type + '.');
            }
            return item;
        }
    }
    var registry = /* #__PURE__ */ new Registry();

    class PluginService {
        constructor(){
            this._init = [];
        }
     notify(chart, hook, args, filter) {
            if (hook === 'beforeInit') {
                this._init = this._createDescriptors(chart, true);
                this._notify(this._init, chart, 'install');
            }
            const descriptors = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);
            const result = this._notify(descriptors, chart, hook, args);
            if (hook === 'afterDestroy') {
                this._notify(descriptors, chart, 'stop');
                this._notify(this._init, chart, 'uninstall');
            }
            return result;
        }
     _notify(descriptors, chart, hook, args) {
            args = args || {};
            for (const descriptor of descriptors){
                const plugin = descriptor.plugin;
                const method = plugin[hook];
                const params = [
                    chart,
                    args,
                    descriptor.options
                ];
                if (callback(method, params, plugin) === false && args.cancelable) {
                    return false;
                }
            }
            return true;
        }
        invalidate() {
            if (!isNullOrUndef(this._cache)) {
                this._oldCache = this._cache;
                this._cache = undefined;
            }
        }
     _descriptors(chart) {
            if (this._cache) {
                return this._cache;
            }
            const descriptors = this._cache = this._createDescriptors(chart);
            this._notifyStateChanges(chart);
            return descriptors;
        }
        _createDescriptors(chart, all) {
            const config = chart && chart.config;
            const options = valueOrDefault(config.options && config.options.plugins, {});
            const plugins = allPlugins(config);
            return options === false && !all ? [] : createDescriptors(chart, plugins, options, all);
        }
     _notifyStateChanges(chart) {
            const previousDescriptors = this._oldCache || [];
            const descriptors = this._cache;
            const diff = (a, b)=>a.filter((x)=>!b.some((y)=>x.plugin.id === y.plugin.id));
            this._notify(diff(previousDescriptors, descriptors), chart, 'stop');
            this._notify(diff(descriptors, previousDescriptors), chart, 'start');
        }
    }
     function allPlugins(config) {
        const localIds = {};
        const plugins = [];
        const keys = Object.keys(registry.plugins.items);
        for(let i = 0; i < keys.length; i++){
            plugins.push(registry.getPlugin(keys[i]));
        }
        const local = config.plugins || [];
        for(let i = 0; i < local.length; i++){
            const plugin = local[i];
            if (plugins.indexOf(plugin) === -1) {
                plugins.push(plugin);
                localIds[plugin.id] = true;
            }
        }
        return {
            plugins,
            localIds
        };
    }
    function getOpts(options, all) {
        if (!all && options === false) {
            return null;
        }
        if (options === true) {
            return {};
        }
        return options;
    }
    function createDescriptors(chart, { plugins , localIds  }, options, all) {
        const result = [];
        const context = chart.getContext();
        for (const plugin of plugins){
            const id = plugin.id;
            const opts = getOpts(options[id], all);
            if (opts === null) {
                continue;
            }
            result.push({
                plugin,
                options: pluginOpts(chart.config, {
                    plugin,
                    local: localIds[id]
                }, opts, context)
            });
        }
        return result;
    }
    function pluginOpts(config, { plugin , local  }, opts, context) {
        const keys = config.pluginScopeKeys(plugin);
        const scopes = config.getOptionScopes(opts, keys);
        if (local && plugin.defaults) {
            scopes.push(plugin.defaults);
        }
        return config.createResolver(scopes, context, [
            ''
        ], {
            scriptable: false,
            indexable: false,
            allKeys: true
        });
    }

    function getIndexAxis(type, options) {
        const datasetDefaults = defaults$1.datasets[type] || {};
        const datasetOptions = (options.datasets || {})[type] || {};
        return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || 'x';
    }
    function getAxisFromDefaultScaleID(id, indexAxis) {
        let axis = id;
        if (id === '_index_') {
            axis = indexAxis;
        } else if (id === '_value_') {
            axis = indexAxis === 'x' ? 'y' : 'x';
        }
        return axis;
    }
    function getDefaultScaleIDFromAxis(axis, indexAxis) {
        return axis === indexAxis ? '_index_' : '_value_';
    }
    function idMatchesAxis(id) {
        if (id === 'x' || id === 'y' || id === 'r') {
            return id;
        }
    }
    function axisFromPosition(position) {
        if (position === 'top' || position === 'bottom') {
            return 'x';
        }
        if (position === 'left' || position === 'right') {
            return 'y';
        }
    }
    function determineAxis(id, ...scaleOptions) {
        if (idMatchesAxis(id)) {
            return id;
        }
        for (const opts of scaleOptions){
            const axis = opts.axis || axisFromPosition(opts.position) || id.length > 1 && idMatchesAxis(id[0].toLowerCase());
            if (axis) {
                return axis;
            }
        }
        throw new Error(`Cannot determine type of '${id}' axis. Please provide 'axis' or 'position' option.`);
    }
    function getAxisFromDataset(id, axis, dataset) {
        if (dataset[axis + 'AxisID'] === id) {
            return {
                axis
            };
        }
    }
    function retrieveAxisFromDatasets(id, config) {
        if (config.data && config.data.datasets) {
            const boundDs = config.data.datasets.filter((d)=>d.xAxisID === id || d.yAxisID === id);
            if (boundDs.length) {
                return getAxisFromDataset(id, 'x', boundDs[0]) || getAxisFromDataset(id, 'y', boundDs[0]);
            }
        }
        return {};
    }
    function mergeScaleConfig(config, options) {
        const chartDefaults = overrides[config.type] || {
            scales: {}
        };
        const configScales = options.scales || {};
        const chartIndexAxis = getIndexAxis(config.type, options);
        const scales = Object.create(null);
        Object.keys(configScales).forEach((id)=>{
            const scaleConf = configScales[id];
            if (!isObject$1(scaleConf)) {
                return console.error(`Invalid scale configuration for scale: ${id}`);
            }
            if (scaleConf._proxy) {
                return console.warn(`Ignoring resolver passed as options for scale: ${id}`);
            }
            const axis = determineAxis(id, scaleConf, retrieveAxisFromDatasets(id, config), defaults$1.scales[scaleConf.type]);
            const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);
            const defaultScaleOptions = chartDefaults.scales || {};
            scales[id] = mergeIf(Object.create(null), [
                {
                    axis
                },
                scaleConf,
                defaultScaleOptions[axis],
                defaultScaleOptions[defaultId]
            ]);
        });
        config.data.datasets.forEach((dataset)=>{
            const type = dataset.type || config.type;
            const indexAxis = dataset.indexAxis || getIndexAxis(type, options);
            const datasetDefaults = overrides[type] || {};
            const defaultScaleOptions = datasetDefaults.scales || {};
            Object.keys(defaultScaleOptions).forEach((defaultID)=>{
                const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);
                const id = dataset[axis + 'AxisID'] || axis;
                scales[id] = scales[id] || Object.create(null);
                mergeIf(scales[id], [
                    {
                        axis
                    },
                    configScales[id],
                    defaultScaleOptions[defaultID]
                ]);
            });
        });
        Object.keys(scales).forEach((key)=>{
            const scale = scales[key];
            mergeIf(scale, [
                defaults$1.scales[scale.type],
                defaults$1.scale
            ]);
        });
        return scales;
    }
    function initOptions(config) {
        const options = config.options || (config.options = {});
        options.plugins = valueOrDefault(options.plugins, {});
        options.scales = mergeScaleConfig(config, options);
    }
    function initData(data) {
        data = data || {};
        data.datasets = data.datasets || [];
        data.labels = data.labels || [];
        return data;
    }
    function initConfig(config) {
        config = config || {};
        config.data = initData(config.data);
        initOptions(config);
        return config;
    }
    const keyCache = new Map();
    const keysCached = new Set();
    function cachedKeys(cacheKey, generate) {
        let keys = keyCache.get(cacheKey);
        if (!keys) {
            keys = generate();
            keyCache.set(cacheKey, keys);
            keysCached.add(keys);
        }
        return keys;
    }
    const addIfFound = (set, obj, key)=>{
        const opts = resolveObjectKey(obj, key);
        if (opts !== undefined) {
            set.add(opts);
        }
    };
    class Config {
        constructor(config){
            this._config = initConfig(config);
            this._scopeCache = new Map();
            this._resolverCache = new Map();
        }
        get platform() {
            return this._config.platform;
        }
        get type() {
            return this._config.type;
        }
        set type(type) {
            this._config.type = type;
        }
        get data() {
            return this._config.data;
        }
        set data(data) {
            this._config.data = initData(data);
        }
        get options() {
            return this._config.options;
        }
        set options(options) {
            this._config.options = options;
        }
        get plugins() {
            return this._config.plugins;
        }
        update() {
            const config = this._config;
            this.clearCache();
            initOptions(config);
        }
        clearCache() {
            this._scopeCache.clear();
            this._resolverCache.clear();
        }
     datasetScopeKeys(datasetType) {
            return cachedKeys(datasetType, ()=>[
                    [
                        `datasets.${datasetType}`,
                        ''
                    ]
                ]);
        }
     datasetAnimationScopeKeys(datasetType, transition) {
            return cachedKeys(`${datasetType}.transition.${transition}`, ()=>[
                    [
                        `datasets.${datasetType}.transitions.${transition}`,
                        `transitions.${transition}`
                    ],
                    [
                        `datasets.${datasetType}`,
                        ''
                    ]
                ]);
        }
     datasetElementScopeKeys(datasetType, elementType) {
            return cachedKeys(`${datasetType}-${elementType}`, ()=>[
                    [
                        `datasets.${datasetType}.elements.${elementType}`,
                        `datasets.${datasetType}`,
                        `elements.${elementType}`,
                        ''
                    ]
                ]);
        }
     pluginScopeKeys(plugin) {
            const id = plugin.id;
            const type = this.type;
            return cachedKeys(`${type}-plugin-${id}`, ()=>[
                    [
                        `plugins.${id}`,
                        ...plugin.additionalOptionScopes || []
                    ]
                ]);
        }
     _cachedScopes(mainScope, resetCache) {
            const _scopeCache = this._scopeCache;
            let cache = _scopeCache.get(mainScope);
            if (!cache || resetCache) {
                cache = new Map();
                _scopeCache.set(mainScope, cache);
            }
            return cache;
        }
     getOptionScopes(mainScope, keyLists, resetCache) {
            const { options , type  } = this;
            const cache = this._cachedScopes(mainScope, resetCache);
            const cached = cache.get(keyLists);
            if (cached) {
                return cached;
            }
            const scopes = new Set();
            keyLists.forEach((keys)=>{
                if (mainScope) {
                    scopes.add(mainScope);
                    keys.forEach((key)=>addIfFound(scopes, mainScope, key));
                }
                keys.forEach((key)=>addIfFound(scopes, options, key));
                keys.forEach((key)=>addIfFound(scopes, overrides[type] || {}, key));
                keys.forEach((key)=>addIfFound(scopes, defaults$1, key));
                keys.forEach((key)=>addIfFound(scopes, descriptors, key));
            });
            const array = Array.from(scopes);
            if (array.length === 0) {
                array.push(Object.create(null));
            }
            if (keysCached.has(keyLists)) {
                cache.set(keyLists, array);
            }
            return array;
        }
     chartOptionScopes() {
            const { options , type  } = this;
            return [
                options,
                overrides[type] || {},
                defaults$1.datasets[type] || {},
                {
                    type
                },
                defaults$1,
                descriptors
            ];
        }
     resolveNamedOptions(scopes, names, context, prefixes = [
            ''
        ]) {
            const result = {
                $shared: true
            };
            const { resolver , subPrefixes  } = getResolver(this._resolverCache, scopes, prefixes);
            let options = resolver;
            if (needContext(resolver, names)) {
                result.$shared = false;
                context = isFunction$1(context) ? context() : context;
                const subResolver = this.createResolver(scopes, context, subPrefixes);
                options = _attachContext(resolver, context, subResolver);
            }
            for (const prop of names){
                result[prop] = options[prop];
            }
            return result;
        }
     createResolver(scopes, context, prefixes = [
            ''
        ], descriptorDefaults) {
            const { resolver  } = getResolver(this._resolverCache, scopes, prefixes);
            return isObject$1(context) ? _attachContext(resolver, context, undefined, descriptorDefaults) : resolver;
        }
    }
    function getResolver(resolverCache, scopes, prefixes) {
        let cache = resolverCache.get(scopes);
        if (!cache) {
            cache = new Map();
            resolverCache.set(scopes, cache);
        }
        const cacheKey = prefixes.join();
        let cached = cache.get(cacheKey);
        if (!cached) {
            const resolver = _createResolver(scopes, prefixes);
            cached = {
                resolver,
                subPrefixes: prefixes.filter((p)=>!p.toLowerCase().includes('hover'))
            };
            cache.set(cacheKey, cached);
        }
        return cached;
    }
    const hasFunction = (value)=>isObject$1(value) && Object.getOwnPropertyNames(value).some((key)=>isFunction$1(value[key]));
    function needContext(proxy, names) {
        const { isScriptable , isIndexable  } = _descriptors(proxy);
        for (const prop of names){
            const scriptable = isScriptable(prop);
            const indexable = isIndexable(prop);
            const value = (indexable || scriptable) && proxy[prop];
            if (scriptable && (isFunction$1(value) || hasFunction(value)) || indexable && isArray$1(value)) {
                return true;
            }
        }
        return false;
    }

    var version = "4.4.7";

    const KNOWN_POSITIONS = [
        'top',
        'bottom',
        'left',
        'right',
        'chartArea'
    ];
    function positionIsHorizontal(position, axis) {
        return position === 'top' || position === 'bottom' || KNOWN_POSITIONS.indexOf(position) === -1 && axis === 'x';
    }
    function compare2Level(l1, l2) {
        return function(a, b) {
            return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];
        };
    }
    function onAnimationsComplete(context) {
        const chart = context.chart;
        const animationOptions = chart.options.animation;
        chart.notifyPlugins('afterRender');
        callback(animationOptions && animationOptions.onComplete, [
            context
        ], chart);
    }
    function onAnimationProgress(context) {
        const chart = context.chart;
        const animationOptions = chart.options.animation;
        callback(animationOptions && animationOptions.onProgress, [
            context
        ], chart);
    }
     function getCanvas(item) {
        if (_isDomSupported() && typeof item === 'string') {
            item = document.getElementById(item);
        } else if (item && item.length) {
            item = item[0];
        }
        if (item && item.canvas) {
            item = item.canvas;
        }
        return item;
    }
    const instances = {};
    const getChart = (key)=>{
        const canvas = getCanvas(key);
        return Object.values(instances).filter((c)=>c.canvas === canvas).pop();
    };
    function moveNumericKeys(obj, start, move) {
        const keys = Object.keys(obj);
        for (const key of keys){
            const intKey = +key;
            if (intKey >= start) {
                const value = obj[key];
                delete obj[key];
                if (move > 0 || intKey > start) {
                    obj[intKey + move] = value;
                }
            }
        }
    }
     function determineLastEvent(e, lastEvent, inChartArea, isClick) {
        if (!inChartArea || e.type === 'mouseout') {
            return null;
        }
        if (isClick) {
            return lastEvent;
        }
        return e;
    }
    function getSizeForArea(scale, chartArea, field) {
        return scale.options.clip ? scale[field] : chartArea[field];
    }
    function getDatasetArea(meta, chartArea) {
        const { xScale , yScale  } = meta;
        if (xScale && yScale) {
            return {
                left: getSizeForArea(xScale, chartArea, 'left'),
                right: getSizeForArea(xScale, chartArea, 'right'),
                top: getSizeForArea(yScale, chartArea, 'top'),
                bottom: getSizeForArea(yScale, chartArea, 'bottom')
            };
        }
        return chartArea;
    }
    class Chart {
        static defaults = defaults$1;
        static instances = instances;
        static overrides = overrides;
        static registry = registry;
        static version = version;
        static getChart = getChart;
        static register(...items) {
            registry.add(...items);
            invalidatePlugins();
        }
        static unregister(...items) {
            registry.remove(...items);
            invalidatePlugins();
        }
        constructor(item, userConfig){
            const config = this.config = new Config(userConfig);
            const initialCanvas = getCanvas(item);
            const existingChart = getChart(initialCanvas);
            if (existingChart) {
                throw new Error('Canvas is already in use. Chart with ID \'' + existingChart.id + '\'' + ' must be destroyed before the canvas with ID \'' + existingChart.canvas.id + '\' can be reused.');
            }
            const options = config.createResolver(config.chartOptionScopes(), this.getContext());
            this.platform = new (config.platform || _detectPlatform(initialCanvas))();
            this.platform.updateConfig(config);
            const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);
            const canvas = context && context.canvas;
            const height = canvas && canvas.height;
            const width = canvas && canvas.width;
            this.id = uid();
            this.ctx = context;
            this.canvas = canvas;
            this.width = width;
            this.height = height;
            this._options = options;
            this._aspectRatio = this.aspectRatio;
            this._layers = [];
            this._metasets = [];
            this._stacks = undefined;
            this.boxes = [];
            this.currentDevicePixelRatio = undefined;
            this.chartArea = undefined;
            this._active = [];
            this._lastEvent = undefined;
            this._listeners = {};
             this._responsiveListeners = undefined;
            this._sortedMetasets = [];
            this.scales = {};
            this._plugins = new PluginService();
            this.$proxies = {};
            this._hiddenIndices = {};
            this.attached = false;
            this._animationsDisabled = undefined;
            this.$context = undefined;
            this._doResize = debounce((mode)=>this.update(mode), options.resizeDelay || 0);
            this._dataChanges = [];
            instances[this.id] = this;
            if (!context || !canvas) {
                console.error("Failed to create chart: can't acquire context from the given item");
                return;
            }
            animator.listen(this, 'complete', onAnimationsComplete);
            animator.listen(this, 'progress', onAnimationProgress);
            this._initialize();
            if (this.attached) {
                this.update();
            }
        }
        get aspectRatio() {
            const { options: { aspectRatio , maintainAspectRatio  } , width , height , _aspectRatio  } = this;
            if (!isNullOrUndef(aspectRatio)) {
                return aspectRatio;
            }
            if (maintainAspectRatio && _aspectRatio) {
                return _aspectRatio;
            }
            return height ? width / height : null;
        }
        get data() {
            return this.config.data;
        }
        set data(data) {
            this.config.data = data;
        }
        get options() {
            return this._options;
        }
        set options(options) {
            this.config.options = options;
        }
        get registry() {
            return registry;
        }
     _initialize() {
            this.notifyPlugins('beforeInit');
            if (this.options.responsive) {
                this.resize();
            } else {
                retinaScale(this, this.options.devicePixelRatio);
            }
            this.bindEvents();
            this.notifyPlugins('afterInit');
            return this;
        }
        clear() {
            clearCanvas(this.canvas, this.ctx);
            return this;
        }
        stop() {
            animator.stop(this);
            return this;
        }
     resize(width, height) {
            if (!animator.running(this)) {
                this._resize(width, height);
            } else {
                this._resizeBeforeDraw = {
                    width,
                    height
                };
            }
        }
        _resize(width, height) {
            const options = this.options;
            const canvas = this.canvas;
            const aspectRatio = options.maintainAspectRatio && this.aspectRatio;
            const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);
            const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();
            const mode = this.width ? 'resize' : 'attach';
            this.width = newSize.width;
            this.height = newSize.height;
            this._aspectRatio = this.aspectRatio;
            if (!retinaScale(this, newRatio, true)) {
                return;
            }
            this.notifyPlugins('resize', {
                size: newSize
            });
            callback(options.onResize, [
                this,
                newSize
            ], this);
            if (this.attached) {
                if (this._doResize(mode)) {
                    this.render();
                }
            }
        }
        ensureScalesHaveIDs() {
            const options = this.options;
            const scalesOptions = options.scales || {};
            each(scalesOptions, (axisOptions, axisID)=>{
                axisOptions.id = axisID;
            });
        }
     buildOrUpdateScales() {
            const options = this.options;
            const scaleOpts = options.scales;
            const scales = this.scales;
            const updated = Object.keys(scales).reduce((obj, id)=>{
                obj[id] = false;
                return obj;
            }, {});
            let items = [];
            if (scaleOpts) {
                items = items.concat(Object.keys(scaleOpts).map((id)=>{
                    const scaleOptions = scaleOpts[id];
                    const axis = determineAxis(id, scaleOptions);
                    const isRadial = axis === 'r';
                    const isHorizontal = axis === 'x';
                    return {
                        options: scaleOptions,
                        dposition: isRadial ? 'chartArea' : isHorizontal ? 'bottom' : 'left',
                        dtype: isRadial ? 'radialLinear' : isHorizontal ? 'category' : 'linear'
                    };
                }));
            }
            each(items, (item)=>{
                const scaleOptions = item.options;
                const id = scaleOptions.id;
                const axis = determineAxis(id, scaleOptions);
                const scaleType = valueOrDefault(scaleOptions.type, item.dtype);
                if (scaleOptions.position === undefined || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {
                    scaleOptions.position = item.dposition;
                }
                updated[id] = true;
                let scale = null;
                if (id in scales && scales[id].type === scaleType) {
                    scale = scales[id];
                } else {
                    const scaleClass = registry.getScale(scaleType);
                    scale = new scaleClass({
                        id,
                        type: scaleType,
                        ctx: this.ctx,
                        chart: this
                    });
                    scales[scale.id] = scale;
                }
                scale.init(scaleOptions, options);
            });
            each(updated, (hasUpdated, id)=>{
                if (!hasUpdated) {
                    delete scales[id];
                }
            });
            each(scales, (scale)=>{
                layouts.configure(this, scale, scale.options);
                layouts.addBox(this, scale);
            });
        }
     _updateMetasets() {
            const metasets = this._metasets;
            const numData = this.data.datasets.length;
            const numMeta = metasets.length;
            metasets.sort((a, b)=>a.index - b.index);
            if (numMeta > numData) {
                for(let i = numData; i < numMeta; ++i){
                    this._destroyDatasetMeta(i);
                }
                metasets.splice(numData, numMeta - numData);
            }
            this._sortedMetasets = metasets.slice(0).sort(compare2Level('order', 'index'));
        }
     _removeUnreferencedMetasets() {
            const { _metasets: metasets , data: { datasets  }  } = this;
            if (metasets.length > datasets.length) {
                delete this._stacks;
            }
            metasets.forEach((meta, index)=>{
                if (datasets.filter((x)=>x === meta._dataset).length === 0) {
                    this._destroyDatasetMeta(index);
                }
            });
        }
        buildOrUpdateControllers() {
            const newControllers = [];
            const datasets = this.data.datasets;
            let i, ilen;
            this._removeUnreferencedMetasets();
            for(i = 0, ilen = datasets.length; i < ilen; i++){
                const dataset = datasets[i];
                let meta = this.getDatasetMeta(i);
                const type = dataset.type || this.config.type;
                if (meta.type && meta.type !== type) {
                    this._destroyDatasetMeta(i);
                    meta = this.getDatasetMeta(i);
                }
                meta.type = type;
                meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);
                meta.order = dataset.order || 0;
                meta.index = i;
                meta.label = '' + dataset.label;
                meta.visible = this.isDatasetVisible(i);
                if (meta.controller) {
                    meta.controller.updateIndex(i);
                    meta.controller.linkScales();
                } else {
                    const ControllerClass = registry.getController(type);
                    const { datasetElementType , dataElementType  } = defaults$1.datasets[type];
                    Object.assign(ControllerClass, {
                        dataElementType: registry.getElement(dataElementType),
                        datasetElementType: datasetElementType && registry.getElement(datasetElementType)
                    });
                    meta.controller = new ControllerClass(this, i);
                    newControllers.push(meta.controller);
                }
            }
            this._updateMetasets();
            return newControllers;
        }
     _resetElements() {
            each(this.data.datasets, (dataset, datasetIndex)=>{
                this.getDatasetMeta(datasetIndex).controller.reset();
            }, this);
        }
     reset() {
            this._resetElements();
            this.notifyPlugins('reset');
        }
        update(mode) {
            const config = this.config;
            config.update();
            const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());
            const animsDisabled = this._animationsDisabled = !options.animation;
            this._updateScales();
            this._checkEventBindings();
            this._updateHiddenIndices();
            this._plugins.invalidate();
            if (this.notifyPlugins('beforeUpdate', {
                mode,
                cancelable: true
            }) === false) {
                return;
            }
            const newControllers = this.buildOrUpdateControllers();
            this.notifyPlugins('beforeElementsUpdate');
            let minPadding = 0;
            for(let i = 0, ilen = this.data.datasets.length; i < ilen; i++){
                const { controller  } = this.getDatasetMeta(i);
                const reset = !animsDisabled && newControllers.indexOf(controller) === -1;
                controller.buildOrUpdateElements(reset);
                minPadding = Math.max(+controller.getMaxOverflow(), minPadding);
            }
            minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;
            this._updateLayout(minPadding);
            if (!animsDisabled) {
                each(newControllers, (controller)=>{
                    controller.reset();
                });
            }
            this._updateDatasets(mode);
            this.notifyPlugins('afterUpdate', {
                mode
            });
            this._layers.sort(compare2Level('z', '_idx'));
            const { _active , _lastEvent  } = this;
            if (_lastEvent) {
                this._eventHandler(_lastEvent, true);
            } else if (_active.length) {
                this._updateHoverStyles(_active, _active, true);
            }
            this.render();
        }
     _updateScales() {
            each(this.scales, (scale)=>{
                layouts.removeBox(this, scale);
            });
            this.ensureScalesHaveIDs();
            this.buildOrUpdateScales();
        }
     _checkEventBindings() {
            const options = this.options;
            const existingEvents = new Set(Object.keys(this._listeners));
            const newEvents = new Set(options.events);
            if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {
                this.unbindEvents();
                this.bindEvents();
            }
        }
     _updateHiddenIndices() {
            const { _hiddenIndices  } = this;
            const changes = this._getUniformDataChanges() || [];
            for (const { method , start , count  } of changes){
                const move = method === '_removeElements' ? -count : count;
                moveNumericKeys(_hiddenIndices, start, move);
            }
        }
     _getUniformDataChanges() {
            const _dataChanges = this._dataChanges;
            if (!_dataChanges || !_dataChanges.length) {
                return;
            }
            this._dataChanges = [];
            const datasetCount = this.data.datasets.length;
            const makeSet = (idx)=>new Set(_dataChanges.filter((c)=>c[0] === idx).map((c, i)=>i + ',' + c.splice(1).join(',')));
            const changeSet = makeSet(0);
            for(let i = 1; i < datasetCount; i++){
                if (!setsEqual(changeSet, makeSet(i))) {
                    return;
                }
            }
            return Array.from(changeSet).map((c)=>c.split(',')).map((a)=>({
                    method: a[1],
                    start: +a[2],
                    count: +a[3]
                }));
        }
     _updateLayout(minPadding) {
            if (this.notifyPlugins('beforeLayout', {
                cancelable: true
            }) === false) {
                return;
            }
            layouts.update(this, this.width, this.height, minPadding);
            const area = this.chartArea;
            const noArea = area.width <= 0 || area.height <= 0;
            this._layers = [];
            each(this.boxes, (box)=>{
                if (noArea && box.position === 'chartArea') {
                    return;
                }
                if (box.configure) {
                    box.configure();
                }
                this._layers.push(...box._layers());
            }, this);
            this._layers.forEach((item, index)=>{
                item._idx = index;
            });
            this.notifyPlugins('afterLayout');
        }
     _updateDatasets(mode) {
            if (this.notifyPlugins('beforeDatasetsUpdate', {
                mode,
                cancelable: true
            }) === false) {
                return;
            }
            for(let i = 0, ilen = this.data.datasets.length; i < ilen; ++i){
                this.getDatasetMeta(i).controller.configure();
            }
            for(let i = 0, ilen = this.data.datasets.length; i < ilen; ++i){
                this._updateDataset(i, isFunction$1(mode) ? mode({
                    datasetIndex: i
                }) : mode);
            }
            this.notifyPlugins('afterDatasetsUpdate', {
                mode
            });
        }
     _updateDataset(index, mode) {
            const meta = this.getDatasetMeta(index);
            const args = {
                meta,
                index,
                mode,
                cancelable: true
            };
            if (this.notifyPlugins('beforeDatasetUpdate', args) === false) {
                return;
            }
            meta.controller._update(mode);
            args.cancelable = false;
            this.notifyPlugins('afterDatasetUpdate', args);
        }
        render() {
            if (this.notifyPlugins('beforeRender', {
                cancelable: true
            }) === false) {
                return;
            }
            if (animator.has(this)) {
                if (this.attached && !animator.running(this)) {
                    animator.start(this);
                }
            } else {
                this.draw();
                onAnimationsComplete({
                    chart: this
                });
            }
        }
        draw() {
            let i;
            if (this._resizeBeforeDraw) {
                const { width , height  } = this._resizeBeforeDraw;
                this._resizeBeforeDraw = null;
                this._resize(width, height);
            }
            this.clear();
            if (this.width <= 0 || this.height <= 0) {
                return;
            }
            if (this.notifyPlugins('beforeDraw', {
                cancelable: true
            }) === false) {
                return;
            }
            const layers = this._layers;
            for(i = 0; i < layers.length && layers[i].z <= 0; ++i){
                layers[i].draw(this.chartArea);
            }
            this._drawDatasets();
            for(; i < layers.length; ++i){
                layers[i].draw(this.chartArea);
            }
            this.notifyPlugins('afterDraw');
        }
     _getSortedDatasetMetas(filterVisible) {
            const metasets = this._sortedMetasets;
            const result = [];
            let i, ilen;
            for(i = 0, ilen = metasets.length; i < ilen; ++i){
                const meta = metasets[i];
                if (!filterVisible || meta.visible) {
                    result.push(meta);
                }
            }
            return result;
        }
     getSortedVisibleDatasetMetas() {
            return this._getSortedDatasetMetas(true);
        }
     _drawDatasets() {
            if (this.notifyPlugins('beforeDatasetsDraw', {
                cancelable: true
            }) === false) {
                return;
            }
            const metasets = this.getSortedVisibleDatasetMetas();
            for(let i = metasets.length - 1; i >= 0; --i){
                this._drawDataset(metasets[i]);
            }
            this.notifyPlugins('afterDatasetsDraw');
        }
     _drawDataset(meta) {
            const ctx = this.ctx;
            const clip = meta._clip;
            const useClip = !clip.disabled;
            const area = getDatasetArea(meta, this.chartArea);
            const args = {
                meta,
                index: meta.index,
                cancelable: true
            };
            if (this.notifyPlugins('beforeDatasetDraw', args) === false) {
                return;
            }
            if (useClip) {
                clipArea(ctx, {
                    left: clip.left === false ? 0 : area.left - clip.left,
                    right: clip.right === false ? this.width : area.right + clip.right,
                    top: clip.top === false ? 0 : area.top - clip.top,
                    bottom: clip.bottom === false ? this.height : area.bottom + clip.bottom
                });
            }
            meta.controller.draw();
            if (useClip) {
                unclipArea(ctx);
            }
            args.cancelable = false;
            this.notifyPlugins('afterDatasetDraw', args);
        }
     isPointInArea(point) {
            return _isPointInArea(point, this.chartArea, this._minPadding);
        }
        getElementsAtEventForMode(e, mode, options, useFinalPosition) {
            const method = Interaction.modes[mode];
            if (typeof method === 'function') {
                return method(this, e, options, useFinalPosition);
            }
            return [];
        }
        getDatasetMeta(datasetIndex) {
            const dataset = this.data.datasets[datasetIndex];
            const metasets = this._metasets;
            let meta = metasets.filter((x)=>x && x._dataset === dataset).pop();
            if (!meta) {
                meta = {
                    type: null,
                    data: [],
                    dataset: null,
                    controller: null,
                    hidden: null,
                    xAxisID: null,
                    yAxisID: null,
                    order: dataset && dataset.order || 0,
                    index: datasetIndex,
                    _dataset: dataset,
                    _parsed: [],
                    _sorted: false
                };
                metasets.push(meta);
            }
            return meta;
        }
        getContext() {
            return this.$context || (this.$context = createContext(null, {
                chart: this,
                type: 'chart'
            }));
        }
        getVisibleDatasetCount() {
            return this.getSortedVisibleDatasetMetas().length;
        }
        isDatasetVisible(datasetIndex) {
            const dataset = this.data.datasets[datasetIndex];
            if (!dataset) {
                return false;
            }
            const meta = this.getDatasetMeta(datasetIndex);
            return typeof meta.hidden === 'boolean' ? !meta.hidden : !dataset.hidden;
        }
        setDatasetVisibility(datasetIndex, visible) {
            const meta = this.getDatasetMeta(datasetIndex);
            meta.hidden = !visible;
        }
        toggleDataVisibility(index) {
            this._hiddenIndices[index] = !this._hiddenIndices[index];
        }
        getDataVisibility(index) {
            return !this._hiddenIndices[index];
        }
     _updateVisibility(datasetIndex, dataIndex, visible) {
            const mode = visible ? 'show' : 'hide';
            const meta = this.getDatasetMeta(datasetIndex);
            const anims = meta.controller._resolveAnimations(undefined, mode);
            if (defined(dataIndex)) {
                meta.data[dataIndex].hidden = !visible;
                this.update();
            } else {
                this.setDatasetVisibility(datasetIndex, visible);
                anims.update(meta, {
                    visible
                });
                this.update((ctx)=>ctx.datasetIndex === datasetIndex ? mode : undefined);
            }
        }
        hide(datasetIndex, dataIndex) {
            this._updateVisibility(datasetIndex, dataIndex, false);
        }
        show(datasetIndex, dataIndex) {
            this._updateVisibility(datasetIndex, dataIndex, true);
        }
     _destroyDatasetMeta(datasetIndex) {
            const meta = this._metasets[datasetIndex];
            if (meta && meta.controller) {
                meta.controller._destroy();
            }
            delete this._metasets[datasetIndex];
        }
        _stop() {
            let i, ilen;
            this.stop();
            animator.remove(this);
            for(i = 0, ilen = this.data.datasets.length; i < ilen; ++i){
                this._destroyDatasetMeta(i);
            }
        }
        destroy() {
            this.notifyPlugins('beforeDestroy');
            const { canvas , ctx  } = this;
            this._stop();
            this.config.clearCache();
            if (canvas) {
                this.unbindEvents();
                clearCanvas(canvas, ctx);
                this.platform.releaseContext(ctx);
                this.canvas = null;
                this.ctx = null;
            }
            delete instances[this.id];
            this.notifyPlugins('afterDestroy');
        }
        toBase64Image(...args) {
            return this.canvas.toDataURL(...args);
        }
     bindEvents() {
            this.bindUserEvents();
            if (this.options.responsive) {
                this.bindResponsiveEvents();
            } else {
                this.attached = true;
            }
        }
     bindUserEvents() {
            const listeners = this._listeners;
            const platform = this.platform;
            const _add = (type, listener)=>{
                platform.addEventListener(this, type, listener);
                listeners[type] = listener;
            };
            const listener = (e, x, y)=>{
                e.offsetX = x;
                e.offsetY = y;
                this._eventHandler(e);
            };
            each(this.options.events, (type)=>_add(type, listener));
        }
     bindResponsiveEvents() {
            if (!this._responsiveListeners) {
                this._responsiveListeners = {};
            }
            const listeners = this._responsiveListeners;
            const platform = this.platform;
            const _add = (type, listener)=>{
                platform.addEventListener(this, type, listener);
                listeners[type] = listener;
            };
            const _remove = (type, listener)=>{
                if (listeners[type]) {
                    platform.removeEventListener(this, type, listener);
                    delete listeners[type];
                }
            };
            const listener = (width, height)=>{
                if (this.canvas) {
                    this.resize(width, height);
                }
            };
            let detached;
            const attached = ()=>{
                _remove('attach', attached);
                this.attached = true;
                this.resize();
                _add('resize', listener);
                _add('detach', detached);
            };
            detached = ()=>{
                this.attached = false;
                _remove('resize', listener);
                this._stop();
                this._resize(0, 0);
                _add('attach', attached);
            };
            if (platform.isAttached(this.canvas)) {
                attached();
            } else {
                detached();
            }
        }
     unbindEvents() {
            each(this._listeners, (listener, type)=>{
                this.platform.removeEventListener(this, type, listener);
            });
            this._listeners = {};
            each(this._responsiveListeners, (listener, type)=>{
                this.platform.removeEventListener(this, type, listener);
            });
            this._responsiveListeners = undefined;
        }
        updateHoverStyle(items, mode, enabled) {
            const prefix = enabled ? 'set' : 'remove';
            let meta, item, i, ilen;
            if (mode === 'dataset') {
                meta = this.getDatasetMeta(items[0].datasetIndex);
                meta.controller['_' + prefix + 'DatasetHoverStyle']();
            }
            for(i = 0, ilen = items.length; i < ilen; ++i){
                item = items[i];
                const controller = item && this.getDatasetMeta(item.datasetIndex).controller;
                if (controller) {
                    controller[prefix + 'HoverStyle'](item.element, item.datasetIndex, item.index);
                }
            }
        }
     getActiveElements() {
            return this._active || [];
        }
     setActiveElements(activeElements) {
            const lastActive = this._active || [];
            const active = activeElements.map(({ datasetIndex , index  })=>{
                const meta = this.getDatasetMeta(datasetIndex);
                if (!meta) {
                    throw new Error('No dataset found at index ' + datasetIndex);
                }
                return {
                    datasetIndex,
                    element: meta.data[index],
                    index
                };
            });
            const changed = !_elementsEqual(active, lastActive);
            if (changed) {
                this._active = active;
                this._lastEvent = null;
                this._updateHoverStyles(active, lastActive);
            }
        }
     notifyPlugins(hook, args, filter) {
            return this._plugins.notify(this, hook, args, filter);
        }
     isPluginEnabled(pluginId) {
            return this._plugins._cache.filter((p)=>p.plugin.id === pluginId).length === 1;
        }
     _updateHoverStyles(active, lastActive, replay) {
            const hoverOptions = this.options.hover;
            const diff = (a, b)=>a.filter((x)=>!b.some((y)=>x.datasetIndex === y.datasetIndex && x.index === y.index));
            const deactivated = diff(lastActive, active);
            const activated = replay ? active : diff(active, lastActive);
            if (deactivated.length) {
                this.updateHoverStyle(deactivated, hoverOptions.mode, false);
            }
            if (activated.length && hoverOptions.mode) {
                this.updateHoverStyle(activated, hoverOptions.mode, true);
            }
        }
     _eventHandler(e, replay) {
            const args = {
                event: e,
                replay,
                cancelable: true,
                inChartArea: this.isPointInArea(e)
            };
            const eventFilter = (plugin)=>(plugin.options.events || this.options.events).includes(e.native.type);
            if (this.notifyPlugins('beforeEvent', args, eventFilter) === false) {
                return;
            }
            const changed = this._handleEvent(e, replay, args.inChartArea);
            args.cancelable = false;
            this.notifyPlugins('afterEvent', args, eventFilter);
            if (changed || args.changed) {
                this.render();
            }
            return this;
        }
     _handleEvent(e, replay, inChartArea) {
            const { _active: lastActive = [] , options  } = this;
            const useFinalPosition = replay;
            const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);
            const isClick = _isClickEvent(e);
            const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);
            if (inChartArea) {
                this._lastEvent = null;
                callback(options.onHover, [
                    e,
                    active,
                    this
                ], this);
                if (isClick) {
                    callback(options.onClick, [
                        e,
                        active,
                        this
                    ], this);
                }
            }
            const changed = !_elementsEqual(active, lastActive);
            if (changed || replay) {
                this._active = active;
                this._updateHoverStyles(active, lastActive, replay);
            }
            this._lastEvent = lastEvent;
            return changed;
        }
     _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {
            if (e.type === 'mouseout') {
                return [];
            }
            if (!inChartArea) {
                return lastActive;
            }
            const hoverOptions = this.options.hover;
            return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);
        }
    }
    function invalidatePlugins() {
        return each(Chart.instances, (chart)=>chart._plugins.invalidate());
    }

    function clipArc(ctx, element, endAngle) {
        const { startAngle , pixelMargin , x , y , outerRadius , innerRadius  } = element;
        let angleMargin = pixelMargin / outerRadius;
        // Draw an inner border by clipping the arc and drawing a double-width border
        // Enlarge the clipping arc by 0.33 pixels to eliminate glitches between borders
        ctx.beginPath();
        ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);
        if (innerRadius > pixelMargin) {
            angleMargin = pixelMargin / innerRadius;
            ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);
        } else {
            ctx.arc(x, y, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);
        }
        ctx.closePath();
        ctx.clip();
    }
    function toRadiusCorners(value) {
        return _readValueToProps(value, [
            'outerStart',
            'outerEnd',
            'innerStart',
            'innerEnd'
        ]);
    }
    /**
     * Parse border radius from the provided options
     */ function parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {
        const o = toRadiusCorners(arc.options.borderRadius);
        const halfThickness = (outerRadius - innerRadius) / 2;
        const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);
        // Outer limits are complicated. We want to compute the available angular distance at
        // a radius of outerRadius - borderRadius because for small angular distances, this term limits.
        // We compute at r = outerRadius - borderRadius because this circle defines the center of the border corners.
        //
        // If the borderRadius is large, that value can become negative.
        // This causes the outer borders to lose their radius entirely, which is rather unexpected. To solve that, if borderRadius > outerRadius
        // we know that the thickness term will dominate and compute the limits at that point
        const computeOuterLimit = (val)=>{
            const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;
            return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));
        };
        return {
            outerStart: computeOuterLimit(o.outerStart),
            outerEnd: computeOuterLimit(o.outerEnd),
            innerStart: _limitValue(o.innerStart, 0, innerLimit),
            innerEnd: _limitValue(o.innerEnd, 0, innerLimit)
        };
    }
    /**
     * Convert (r, ) to (x, y)
     */ function rThetaToXY(r, theta, x, y) {
        return {
            x: x + r * Math.cos(theta),
            y: y + r * Math.sin(theta)
        };
    }
    /**
     * Path the arc, respecting border radius by separating into left and right halves.
     *
     *   Start      End
     *
     *    1--->a--->2    Outer
     *   /           \
     *   8           3
     *   |           |
     *   |           |
     *   7           4
     *   \           /
     *    6<---b<---5    Inner
     */ function pathArc(ctx, element, offset, spacing, end, circular) {
        const { x , y , startAngle: start , pixelMargin , innerRadius: innerR  } = element;
        const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);
        const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;
        let spacingOffset = 0;
        const alpha = end - start;
        if (spacing) {
            // When spacing is present, it is the same for all items
            // So we adjust the start and end angle of the arc such that
            // the distance is the same as it would be without the spacing
            const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;
            const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;
            const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;
            const adjustedAngle = avNogSpacingRadius !== 0 ? alpha * avNogSpacingRadius / (avNogSpacingRadius + spacing) : alpha;
            spacingOffset = (alpha - adjustedAngle) / 2;
        }
        const beta = Math.max(0.001, alpha * outerRadius - offset / PI) / outerRadius;
        const angleOffset = (alpha - beta) / 2;
        const startAngle = start + angleOffset + spacingOffset;
        const endAngle = end - angleOffset - spacingOffset;
        const { outerStart , outerEnd , innerStart , innerEnd  } = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);
        const outerStartAdjustedRadius = outerRadius - outerStart;
        const outerEndAdjustedRadius = outerRadius - outerEnd;
        const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;
        const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;
        const innerStartAdjustedRadius = innerRadius + innerStart;
        const innerEndAdjustedRadius = innerRadius + innerEnd;
        const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;
        const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;
        ctx.beginPath();
        if (circular) {
            // The first arc segments from point 1 to point a to point 2
            const outerMidAdjustedAngle = (outerStartAdjustedAngle + outerEndAdjustedAngle) / 2;
            ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerMidAdjustedAngle);
            ctx.arc(x, y, outerRadius, outerMidAdjustedAngle, outerEndAdjustedAngle);
            // The corner segment from point 2 to point 3
            if (outerEnd > 0) {
                const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);
                ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);
            }
            // The line from point 3 to point 4
            const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);
            ctx.lineTo(p4.x, p4.y);
            // The corner segment from point 4 to point 5
            if (innerEnd > 0) {
                const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);
                ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);
            }
            // The inner arc from point 5 to point b to point 6
            const innerMidAdjustedAngle = (endAngle - innerEnd / innerRadius + (startAngle + innerStart / innerRadius)) / 2;
            ctx.arc(x, y, innerRadius, endAngle - innerEnd / innerRadius, innerMidAdjustedAngle, true);
            ctx.arc(x, y, innerRadius, innerMidAdjustedAngle, startAngle + innerStart / innerRadius, true);
            // The corner segment from point 6 to point 7
            if (innerStart > 0) {
                const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);
                ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);
            }
            // The line from point 7 to point 8
            const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);
            ctx.lineTo(p8.x, p8.y);
            // The corner segment from point 8 to point 1
            if (outerStart > 0) {
                const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);
                ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);
            }
        } else {
            ctx.moveTo(x, y);
            const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x;
            const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y;
            ctx.lineTo(outerStartX, outerStartY);
            const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x;
            const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y;
            ctx.lineTo(outerEndX, outerEndY);
        }
        ctx.closePath();
    }
    function drawArc(ctx, element, offset, spacing, circular) {
        const { fullCircles , startAngle , circumference  } = element;
        let endAngle = element.endAngle;
        if (fullCircles) {
            pathArc(ctx, element, offset, spacing, endAngle, circular);
            for(let i = 0; i < fullCircles; ++i){
                ctx.fill();
            }
            if (!isNaN(circumference)) {
                endAngle = startAngle + (circumference % TAU || TAU);
            }
        }
        pathArc(ctx, element, offset, spacing, endAngle, circular);
        ctx.fill();
        return endAngle;
    }
    function drawBorder(ctx, element, offset, spacing, circular) {
        const { fullCircles , startAngle , circumference , options  } = element;
        const { borderWidth , borderJoinStyle , borderDash , borderDashOffset  } = options;
        const inner = options.borderAlign === 'inner';
        if (!borderWidth) {
            return;
        }
        ctx.setLineDash(borderDash || []);
        ctx.lineDashOffset = borderDashOffset;
        if (inner) {
            ctx.lineWidth = borderWidth * 2;
            ctx.lineJoin = borderJoinStyle || 'round';
        } else {
            ctx.lineWidth = borderWidth;
            ctx.lineJoin = borderJoinStyle || 'bevel';
        }
        let endAngle = element.endAngle;
        if (fullCircles) {
            pathArc(ctx, element, offset, spacing, endAngle, circular);
            for(let i = 0; i < fullCircles; ++i){
                ctx.stroke();
            }
            if (!isNaN(circumference)) {
                endAngle = startAngle + (circumference % TAU || TAU);
            }
        }
        if (inner) {
            clipArc(ctx, element, endAngle);
        }
        if (!fullCircles) {
            pathArc(ctx, element, offset, spacing, endAngle, circular);
            ctx.stroke();
        }
    }
    class ArcElement extends Element$1 {
        static id = 'arc';
        static defaults = {
            borderAlign: 'center',
            borderColor: '#fff',
            borderDash: [],
            borderDashOffset: 0,
            borderJoinStyle: undefined,
            borderRadius: 0,
            borderWidth: 2,
            offset: 0,
            spacing: 0,
            angle: undefined,
            circular: true
        };
        static defaultRoutes = {
            backgroundColor: 'backgroundColor'
        };
        static descriptors = {
            _scriptable: true,
            _indexable: (name)=>name !== 'borderDash'
        };
        circumference;
        endAngle;
        fullCircles;
        innerRadius;
        outerRadius;
        pixelMargin;
        startAngle;
        constructor(cfg){
            super();
            this.options = undefined;
            this.circumference = undefined;
            this.startAngle = undefined;
            this.endAngle = undefined;
            this.innerRadius = undefined;
            this.outerRadius = undefined;
            this.pixelMargin = 0;
            this.fullCircles = 0;
            if (cfg) {
                Object.assign(this, cfg);
            }
        }
        inRange(chartX, chartY, useFinalPosition) {
            const point = this.getProps([
                'x',
                'y'
            ], useFinalPosition);
            const { angle , distance  } = getAngleFromPoint(point, {
                x: chartX,
                y: chartY
            });
            const { startAngle , endAngle , innerRadius , outerRadius , circumference  } = this.getProps([
                'startAngle',
                'endAngle',
                'innerRadius',
                'outerRadius',
                'circumference'
            ], useFinalPosition);
            const rAdjust = (this.options.spacing + this.options.borderWidth) / 2;
            const _circumference = valueOrDefault(circumference, endAngle - startAngle);
            const nonZeroBetween = _angleBetween(angle, startAngle, endAngle) && startAngle !== endAngle;
            const betweenAngles = _circumference >= TAU || nonZeroBetween;
            const withinRadius = _isBetween(distance, innerRadius + rAdjust, outerRadius + rAdjust);
            return betweenAngles && withinRadius;
        }
        getCenterPoint(useFinalPosition) {
            const { x , y , startAngle , endAngle , innerRadius , outerRadius  } = this.getProps([
                'x',
                'y',
                'startAngle',
                'endAngle',
                'innerRadius',
                'outerRadius'
            ], useFinalPosition);
            const { offset , spacing  } = this.options;
            const halfAngle = (startAngle + endAngle) / 2;
            const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;
            return {
                x: x + Math.cos(halfAngle) * halfRadius,
                y: y + Math.sin(halfAngle) * halfRadius
            };
        }
        tooltipPosition(useFinalPosition) {
            return this.getCenterPoint(useFinalPosition);
        }
        draw(ctx) {
            const { options , circumference  } = this;
            const offset = (options.offset || 0) / 4;
            const spacing = (options.spacing || 0) / 2;
            const circular = options.circular;
            this.pixelMargin = options.borderAlign === 'inner' ? 0.33 : 0;
            this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;
            if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {
                return;
            }
            ctx.save();
            const halfAngle = (this.startAngle + this.endAngle) / 2;
            ctx.translate(Math.cos(halfAngle) * offset, Math.sin(halfAngle) * offset);
            const fix = 1 - Math.sin(Math.min(PI, circumference || 0));
            const radiusOffset = offset * fix;
            ctx.fillStyle = options.backgroundColor;
            ctx.strokeStyle = options.borderColor;
            drawArc(ctx, this, radiusOffset, spacing, circular);
            drawBorder(ctx, this, radiusOffset, spacing, circular);
            ctx.restore();
        }
    }

    function setStyle(ctx, options, style = options) {
        ctx.lineCap = valueOrDefault(style.borderCapStyle, options.borderCapStyle);
        ctx.setLineDash(valueOrDefault(style.borderDash, options.borderDash));
        ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options.borderDashOffset);
        ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);
        ctx.lineWidth = valueOrDefault(style.borderWidth, options.borderWidth);
        ctx.strokeStyle = valueOrDefault(style.borderColor, options.borderColor);
    }
    function lineTo(ctx, previous, target) {
        ctx.lineTo(target.x, target.y);
    }
     function getLineMethod(options) {
        if (options.stepped) {
            return _steppedLineTo;
        }
        if (options.tension || options.cubicInterpolationMode === 'monotone') {
            return _bezierCurveTo;
        }
        return lineTo;
    }
    function pathVars(points, segment, params = {}) {
        const count = points.length;
        const { start: paramsStart = 0 , end: paramsEnd = count - 1  } = params;
        const { start: segmentStart , end: segmentEnd  } = segment;
        const start = Math.max(paramsStart, segmentStart);
        const end = Math.min(paramsEnd, segmentEnd);
        const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;
        return {
            count,
            start,
            loop: segment.loop,
            ilen: end < start && !outside ? count + end - start : end - start
        };
    }
     function pathSegment(ctx, line, segment, params) {
        const { points , options  } = line;
        const { count , start , loop , ilen  } = pathVars(points, segment, params);
        const lineMethod = getLineMethod(options);
        let { move =true , reverse  } = params || {};
        let i, point, prev;
        for(i = 0; i <= ilen; ++i){
            point = points[(start + (reverse ? ilen - i : i)) % count];
            if (point.skip) {
                continue;
            } else if (move) {
                ctx.moveTo(point.x, point.y);
                move = false;
            } else {
                lineMethod(ctx, prev, point, reverse, options.stepped);
            }
            prev = point;
        }
        if (loop) {
            point = points[(start + (reverse ? ilen : 0)) % count];
            lineMethod(ctx, prev, point, reverse, options.stepped);
        }
        return !!loop;
    }
     function fastPathSegment(ctx, line, segment, params) {
        const points = line.points;
        const { count , start , ilen  } = pathVars(points, segment, params);
        const { move =true , reverse  } = params || {};
        let avgX = 0;
        let countX = 0;
        let i, point, prevX, minY, maxY, lastY;
        const pointIndex = (index)=>(start + (reverse ? ilen - index : index)) % count;
        const drawX = ()=>{
            if (minY !== maxY) {
                ctx.lineTo(avgX, maxY);
                ctx.lineTo(avgX, minY);
                ctx.lineTo(avgX, lastY);
            }
        };
        if (move) {
            point = points[pointIndex(0)];
            ctx.moveTo(point.x, point.y);
        }
        for(i = 0; i <= ilen; ++i){
            point = points[pointIndex(i)];
            if (point.skip) {
                continue;
            }
            const x = point.x;
            const y = point.y;
            const truncX = x | 0;
            if (truncX === prevX) {
                if (y < minY) {
                    minY = y;
                } else if (y > maxY) {
                    maxY = y;
                }
                avgX = (countX * avgX + x) / ++countX;
            } else {
                drawX();
                ctx.lineTo(x, y);
                prevX = truncX;
                countX = 0;
                minY = maxY = y;
            }
            lastY = y;
        }
        drawX();
    }
     function _getSegmentMethod(line) {
        const opts = line.options;
        const borderDash = opts.borderDash && opts.borderDash.length;
        const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== 'monotone' && !opts.stepped && !borderDash;
        return useFastPath ? fastPathSegment : pathSegment;
    }
     function _getInterpolationMethod(options) {
        if (options.stepped) {
            return _steppedInterpolation;
        }
        if (options.tension || options.cubicInterpolationMode === 'monotone') {
            return _bezierInterpolation;
        }
        return _pointInLine;
    }
    function strokePathWithCache(ctx, line, start, count) {
        let path = line._path;
        if (!path) {
            path = line._path = new Path2D();
            if (line.path(path, start, count)) {
                path.closePath();
            }
        }
        setStyle(ctx, line.options);
        ctx.stroke(path);
    }
    function strokePathDirect(ctx, line, start, count) {
        const { segments , options  } = line;
        const segmentMethod = _getSegmentMethod(line);
        for (const segment of segments){
            setStyle(ctx, options, segment.style);
            ctx.beginPath();
            if (segmentMethod(ctx, line, segment, {
                start,
                end: start + count - 1
            })) {
                ctx.closePath();
            }
            ctx.stroke();
        }
    }
    const usePath2D = typeof Path2D === 'function';
    function draw(ctx, line, start, count) {
        if (usePath2D && !line.options.segment) {
            strokePathWithCache(ctx, line, start, count);
        } else {
            strokePathDirect(ctx, line, start, count);
        }
    }
    class LineElement extends Element$1 {
        static id = 'line';
     static defaults = {
            borderCapStyle: 'butt',
            borderDash: [],
            borderDashOffset: 0,
            borderJoinStyle: 'miter',
            borderWidth: 3,
            capBezierPoints: true,
            cubicInterpolationMode: 'default',
            fill: false,
            spanGaps: false,
            stepped: false,
            tension: 0
        };
     static defaultRoutes = {
            backgroundColor: 'backgroundColor',
            borderColor: 'borderColor'
        };
        static descriptors = {
            _scriptable: true,
            _indexable: (name)=>name !== 'borderDash' && name !== 'fill'
        };
        constructor(cfg){
            super();
            this.animated = true;
            this.options = undefined;
            this._chart = undefined;
            this._loop = undefined;
            this._fullLoop = undefined;
            this._path = undefined;
            this._points = undefined;
            this._segments = undefined;
            this._decimated = false;
            this._pointsUpdated = false;
            this._datasetIndex = undefined;
            if (cfg) {
                Object.assign(this, cfg);
            }
        }
        updateControlPoints(chartArea, indexAxis) {
            const options = this.options;
            if ((options.tension || options.cubicInterpolationMode === 'monotone') && !options.stepped && !this._pointsUpdated) {
                const loop = options.spanGaps ? this._loop : this._fullLoop;
                _updateBezierControlPoints(this._points, options, chartArea, loop, indexAxis);
                this._pointsUpdated = true;
            }
        }
        set points(points) {
            this._points = points;
            delete this._segments;
            delete this._path;
            this._pointsUpdated = false;
        }
        get points() {
            return this._points;
        }
        get segments() {
            return this._segments || (this._segments = _computeSegments(this, this.options.segment));
        }
     first() {
            const segments = this.segments;
            const points = this.points;
            return segments.length && points[segments[0].start];
        }
     last() {
            const segments = this.segments;
            const points = this.points;
            const count = segments.length;
            return count && points[segments[count - 1].end];
        }
     interpolate(point, property) {
            const options = this.options;
            const value = point[property];
            const points = this.points;
            const segments = _boundSegments(this, {
                property,
                start: value,
                end: value
            });
            if (!segments.length) {
                return;
            }
            const result = [];
            const _interpolate = _getInterpolationMethod(options);
            let i, ilen;
            for(i = 0, ilen = segments.length; i < ilen; ++i){
                const { start , end  } = segments[i];
                const p1 = points[start];
                const p2 = points[end];
                if (p1 === p2) {
                    result.push(p1);
                    continue;
                }
                const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));
                const interpolated = _interpolate(p1, p2, t, options.stepped);
                interpolated[property] = point[property];
                result.push(interpolated);
            }
            return result.length === 1 ? result[0] : result;
        }
     pathSegment(ctx, segment, params) {
            const segmentMethod = _getSegmentMethod(this);
            return segmentMethod(ctx, this, segment, params);
        }
     path(ctx, start, count) {
            const segments = this.segments;
            const segmentMethod = _getSegmentMethod(this);
            let loop = this._loop;
            start = start || 0;
            count = count || this.points.length - start;
            for (const segment of segments){
                loop &= segmentMethod(ctx, this, segment, {
                    start,
                    end: start + count - 1
                });
            }
            return !!loop;
        }
     draw(ctx, chartArea, start, count) {
            const options = this.options || {};
            const points = this.points || [];
            if (points.length && options.borderWidth) {
                ctx.save();
                draw(ctx, this, start, count);
                ctx.restore();
            }
            if (this.animated) {
                this._pointsUpdated = false;
                this._path = undefined;
            }
        }
    }

    function inRange$1(el, pos, axis, useFinalPosition) {
        const options = el.options;
        const { [axis]: value  } = el.getProps([
            axis
        ], useFinalPosition);
        return Math.abs(pos - value) < options.radius + options.hitRadius;
    }
    class PointElement extends Element$1 {
        static id = 'point';
        parsed;
        skip;
        stop;
        /**
       * @type {any}
       */ static defaults = {
            borderWidth: 1,
            hitRadius: 1,
            hoverBorderWidth: 1,
            hoverRadius: 4,
            pointStyle: 'circle',
            radius: 3,
            rotation: 0
        };
        /**
       * @type {any}
       */ static defaultRoutes = {
            backgroundColor: 'backgroundColor',
            borderColor: 'borderColor'
        };
        constructor(cfg){
            super();
            this.options = undefined;
            this.parsed = undefined;
            this.skip = undefined;
            this.stop = undefined;
            if (cfg) {
                Object.assign(this, cfg);
            }
        }
        inRange(mouseX, mouseY, useFinalPosition) {
            const options = this.options;
            const { x , y  } = this.getProps([
                'x',
                'y'
            ], useFinalPosition);
            return Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2) < Math.pow(options.hitRadius + options.radius, 2);
        }
        inXRange(mouseX, useFinalPosition) {
            return inRange$1(this, mouseX, 'x', useFinalPosition);
        }
        inYRange(mouseY, useFinalPosition) {
            return inRange$1(this, mouseY, 'y', useFinalPosition);
        }
        getCenterPoint(useFinalPosition) {
            const { x , y  } = this.getProps([
                'x',
                'y'
            ], useFinalPosition);
            return {
                x,
                y
            };
        }
        size(options) {
            options = options || this.options || {};
            let radius = options.radius || 0;
            radius = Math.max(radius, radius && options.hoverRadius || 0);
            const borderWidth = radius && options.borderWidth || 0;
            return (radius + borderWidth) * 2;
        }
        draw(ctx, area) {
            const options = this.options;
            if (this.skip || options.radius < 0.1 || !_isPointInArea(this, area, this.size(options) / 2)) {
                return;
            }
            ctx.strokeStyle = options.borderColor;
            ctx.lineWidth = options.borderWidth;
            ctx.fillStyle = options.backgroundColor;
            drawPoint(ctx, options, this.x, this.y);
        }
        getRange() {
            const options = this.options || {};
            // @ts-expect-error Fallbacks should never be hit in practice
            return options.radius + options.hitRadius;
        }
    }

    function getBarBounds(bar, useFinalPosition) {
        const { x , y , base , width , height  } =  bar.getProps([
            'x',
            'y',
            'base',
            'width',
            'height'
        ], useFinalPosition);
        let left, right, top, bottom, half;
        if (bar.horizontal) {
            half = height / 2;
            left = Math.min(x, base);
            right = Math.max(x, base);
            top = y - half;
            bottom = y + half;
        } else {
            half = width / 2;
            left = x - half;
            right = x + half;
            top = Math.min(y, base);
            bottom = Math.max(y, base);
        }
        return {
            left,
            top,
            right,
            bottom
        };
    }
    function skipOrLimit(skip, value, min, max) {
        return skip ? 0 : _limitValue(value, min, max);
    }
    function parseBorderWidth(bar, maxW, maxH) {
        const value = bar.options.borderWidth;
        const skip = bar.borderSkipped;
        const o = toTRBL(value);
        return {
            t: skipOrLimit(skip.top, o.top, 0, maxH),
            r: skipOrLimit(skip.right, o.right, 0, maxW),
            b: skipOrLimit(skip.bottom, o.bottom, 0, maxH),
            l: skipOrLimit(skip.left, o.left, 0, maxW)
        };
    }
    function parseBorderRadius(bar, maxW, maxH) {
        const { enableBorderRadius  } = bar.getProps([
            'enableBorderRadius'
        ]);
        const value = bar.options.borderRadius;
        const o = toTRBLCorners(value);
        const maxR = Math.min(maxW, maxH);
        const skip = bar.borderSkipped;
        const enableBorder = enableBorderRadius || isObject$1(value);
        return {
            topLeft: skipOrLimit(!enableBorder || skip.top || skip.left, o.topLeft, 0, maxR),
            topRight: skipOrLimit(!enableBorder || skip.top || skip.right, o.topRight, 0, maxR),
            bottomLeft: skipOrLimit(!enableBorder || skip.bottom || skip.left, o.bottomLeft, 0, maxR),
            bottomRight: skipOrLimit(!enableBorder || skip.bottom || skip.right, o.bottomRight, 0, maxR)
        };
    }
    function boundingRects(bar) {
        const bounds = getBarBounds(bar);
        const width = bounds.right - bounds.left;
        const height = bounds.bottom - bounds.top;
        const border = parseBorderWidth(bar, width / 2, height / 2);
        const radius = parseBorderRadius(bar, width / 2, height / 2);
        return {
            outer: {
                x: bounds.left,
                y: bounds.top,
                w: width,
                h: height,
                radius
            },
            inner: {
                x: bounds.left + border.l,
                y: bounds.top + border.t,
                w: width - border.l - border.r,
                h: height - border.t - border.b,
                radius: {
                    topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),
                    topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),
                    bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),
                    bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r))
                }
            }
        };
    }
    function inRange(bar, x, y, useFinalPosition) {
        const skipX = x === null;
        const skipY = y === null;
        const skipBoth = skipX && skipY;
        const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);
        return bounds && (skipX || _isBetween(x, bounds.left, bounds.right)) && (skipY || _isBetween(y, bounds.top, bounds.bottom));
    }
    function hasRadius(radius) {
        return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;
    }
     function addNormalRectPath(ctx, rect) {
        ctx.rect(rect.x, rect.y, rect.w, rect.h);
    }
    function inflateRect(rect, amount, refRect = {}) {
        const x = rect.x !== refRect.x ? -amount : 0;
        const y = rect.y !== refRect.y ? -amount : 0;
        const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;
        const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;
        return {
            x: rect.x + x,
            y: rect.y + y,
            w: rect.w + w,
            h: rect.h + h,
            radius: rect.radius
        };
    }
    class BarElement extends Element$1 {
        static id = 'bar';
     static defaults = {
            borderSkipped: 'start',
            borderWidth: 0,
            borderRadius: 0,
            inflateAmount: 'auto',
            pointStyle: undefined
        };
     static defaultRoutes = {
            backgroundColor: 'backgroundColor',
            borderColor: 'borderColor'
        };
        constructor(cfg){
            super();
            this.options = undefined;
            this.horizontal = undefined;
            this.base = undefined;
            this.width = undefined;
            this.height = undefined;
            this.inflateAmount = undefined;
            if (cfg) {
                Object.assign(this, cfg);
            }
        }
        draw(ctx) {
            const { inflateAmount , options: { borderColor , backgroundColor  }  } = this;
            const { inner , outer  } = boundingRects(this);
            const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;
            ctx.save();
            if (outer.w !== inner.w || outer.h !== inner.h) {
                ctx.beginPath();
                addRectPath(ctx, inflateRect(outer, inflateAmount, inner));
                ctx.clip();
                addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));
                ctx.fillStyle = borderColor;
                ctx.fill('evenodd');
            }
            ctx.beginPath();
            addRectPath(ctx, inflateRect(inner, inflateAmount));
            ctx.fillStyle = backgroundColor;
            ctx.fill();
            ctx.restore();
        }
        inRange(mouseX, mouseY, useFinalPosition) {
            return inRange(this, mouseX, mouseY, useFinalPosition);
        }
        inXRange(mouseX, useFinalPosition) {
            return inRange(this, mouseX, null, useFinalPosition);
        }
        inYRange(mouseY, useFinalPosition) {
            return inRange(this, null, mouseY, useFinalPosition);
        }
        getCenterPoint(useFinalPosition) {
            const { x , y , base , horizontal  } =  this.getProps([
                'x',
                'y',
                'base',
                'horizontal'
            ], useFinalPosition);
            return {
                x: horizontal ? (x + base) / 2 : x,
                y: horizontal ? y : (y + base) / 2
            };
        }
        getRange(axis) {
            return axis === 'x' ? this.width / 2 : this.height / 2;
        }
    }

    var elements = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ArcElement: ArcElement,
    BarElement: BarElement,
    LineElement: LineElement,
    PointElement: PointElement
    });

    const BORDER_COLORS = [
        'rgb(54, 162, 235)',
        'rgb(255, 99, 132)',
        'rgb(255, 159, 64)',
        'rgb(255, 205, 86)',
        'rgb(75, 192, 192)',
        'rgb(153, 102, 255)',
        'rgb(201, 203, 207)' // grey
    ];
    // Border colors with 50% transparency
    const BACKGROUND_COLORS = /* #__PURE__ */ BORDER_COLORS.map((color)=>color.replace('rgb(', 'rgba(').replace(')', ', 0.5)'));
    function getBorderColor(i) {
        return BORDER_COLORS[i % BORDER_COLORS.length];
    }
    function getBackgroundColor(i) {
        return BACKGROUND_COLORS[i % BACKGROUND_COLORS.length];
    }
    function colorizeDefaultDataset(dataset, i) {
        dataset.borderColor = getBorderColor(i);
        dataset.backgroundColor = getBackgroundColor(i);
        return ++i;
    }
    function colorizeDoughnutDataset(dataset, i) {
        dataset.backgroundColor = dataset.data.map(()=>getBorderColor(i++));
        return i;
    }
    function colorizePolarAreaDataset(dataset, i) {
        dataset.backgroundColor = dataset.data.map(()=>getBackgroundColor(i++));
        return i;
    }
    function getColorizer(chart) {
        let i = 0;
        return (dataset, datasetIndex)=>{
            const controller = chart.getDatasetMeta(datasetIndex).controller;
            if (controller instanceof DoughnutController) {
                i = colorizeDoughnutDataset(dataset, i);
            } else if (controller instanceof PolarAreaController) {
                i = colorizePolarAreaDataset(dataset, i);
            } else if (controller) {
                i = colorizeDefaultDataset(dataset, i);
            }
        };
    }
    function containsColorsDefinitions(descriptors) {
        let k;
        for(k in descriptors){
            if (descriptors[k].borderColor || descriptors[k].backgroundColor) {
                return true;
            }
        }
        return false;
    }
    function containsColorsDefinition(descriptor) {
        return descriptor && (descriptor.borderColor || descriptor.backgroundColor);
    }
    function containsDefaultColorsDefenitions() {
        return defaults$1.borderColor !== 'rgba(0,0,0,0.1)' || defaults$1.backgroundColor !== 'rgba(0,0,0,0.1)';
    }
    var plugin_colors = {
        id: 'colors',
        defaults: {
            enabled: true,
            forceOverride: false
        },
        beforeLayout (chart, _args, options) {
            if (!options.enabled) {
                return;
            }
            const { data: { datasets  } , options: chartOptions  } = chart.config;
            const { elements  } = chartOptions;
            const containsColorDefenition = containsColorsDefinitions(datasets) || containsColorsDefinition(chartOptions) || elements && containsColorsDefinitions(elements) || containsDefaultColorsDefenitions();
            if (!options.forceOverride && containsColorDefenition) {
                return;
            }
            const colorizer = getColorizer(chart);
            datasets.forEach(colorizer);
        }
    };

    function lttbDecimation(data, start, count, availableWidth, options) {
     const samples = options.samples || availableWidth;
        if (samples >= count) {
            return data.slice(start, start + count);
        }
        const decimated = [];
        const bucketWidth = (count - 2) / (samples - 2);
        let sampledIndex = 0;
        const endIndex = start + count - 1;
        let a = start;
        let i, maxAreaPoint, maxArea, area, nextA;
        decimated[sampledIndex++] = data[a];
        for(i = 0; i < samples - 2; i++){
            let avgX = 0;
            let avgY = 0;
            let j;
            const avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1 + start;
            const avgRangeEnd = Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start;
            const avgRangeLength = avgRangeEnd - avgRangeStart;
            for(j = avgRangeStart; j < avgRangeEnd; j++){
                avgX += data[j].x;
                avgY += data[j].y;
            }
            avgX /= avgRangeLength;
            avgY /= avgRangeLength;
            const rangeOffs = Math.floor(i * bucketWidth) + 1 + start;
            const rangeTo = Math.min(Math.floor((i + 1) * bucketWidth) + 1, count) + start;
            const { x: pointAx , y: pointAy  } = data[a];
            maxArea = area = -1;
            for(j = rangeOffs; j < rangeTo; j++){
                area = 0.5 * Math.abs((pointAx - avgX) * (data[j].y - pointAy) - (pointAx - data[j].x) * (avgY - pointAy));
                if (area > maxArea) {
                    maxArea = area;
                    maxAreaPoint = data[j];
                    nextA = j;
                }
            }
            decimated[sampledIndex++] = maxAreaPoint;
            a = nextA;
        }
        decimated[sampledIndex++] = data[endIndex];
        return decimated;
    }
    function minMaxDecimation(data, start, count, availableWidth) {
        let avgX = 0;
        let countX = 0;
        let i, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;
        const decimated = [];
        const endIndex = start + count - 1;
        const xMin = data[start].x;
        const xMax = data[endIndex].x;
        const dx = xMax - xMin;
        for(i = start; i < start + count; ++i){
            point = data[i];
            x = (point.x - xMin) / dx * availableWidth;
            y = point.y;
            const truncX = x | 0;
            if (truncX === prevX) {
                if (y < minY) {
                    minY = y;
                    minIndex = i;
                } else if (y > maxY) {
                    maxY = y;
                    maxIndex = i;
                }
                avgX = (countX * avgX + point.x) / ++countX;
            } else {
                const lastIndex = i - 1;
                if (!isNullOrUndef(minIndex) && !isNullOrUndef(maxIndex)) {
                    const intermediateIndex1 = Math.min(minIndex, maxIndex);
                    const intermediateIndex2 = Math.max(minIndex, maxIndex);
                    if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {
                        decimated.push({
                            ...data[intermediateIndex1],
                            x: avgX
                        });
                    }
                    if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {
                        decimated.push({
                            ...data[intermediateIndex2],
                            x: avgX
                        });
                    }
                }
                if (i > 0 && lastIndex !== startIndex) {
                    decimated.push(data[lastIndex]);
                }
                decimated.push(point);
                prevX = truncX;
                countX = 0;
                minY = maxY = y;
                minIndex = maxIndex = startIndex = i;
            }
        }
        return decimated;
    }
    function cleanDecimatedDataset(dataset) {
        if (dataset._decimated) {
            const data = dataset._data;
            delete dataset._decimated;
            delete dataset._data;
            Object.defineProperty(dataset, 'data', {
                configurable: true,
                enumerable: true,
                writable: true,
                value: data
            });
        }
    }
    function cleanDecimatedData(chart) {
        chart.data.datasets.forEach((dataset)=>{
            cleanDecimatedDataset(dataset);
        });
    }
    function getStartAndCountOfVisiblePointsSimplified(meta, points) {
        const pointCount = points.length;
        let start = 0;
        let count;
        const { iScale  } = meta;
        const { min , max , minDefined , maxDefined  } = iScale.getUserBounds();
        if (minDefined) {
            start = _limitValue(_lookupByKey(points, iScale.axis, min).lo, 0, pointCount - 1);
        }
        if (maxDefined) {
            count = _limitValue(_lookupByKey(points, iScale.axis, max).hi + 1, start, pointCount) - start;
        } else {
            count = pointCount - start;
        }
        return {
            start,
            count
        };
    }
    var plugin_decimation = {
        id: 'decimation',
        defaults: {
            algorithm: 'min-max',
            enabled: false
        },
        beforeElementsUpdate: (chart, args, options)=>{
            if (!options.enabled) {
                cleanDecimatedData(chart);
                return;
            }
            const availableWidth = chart.width;
            chart.data.datasets.forEach((dataset, datasetIndex)=>{
                const { _data , indexAxis  } = dataset;
                const meta = chart.getDatasetMeta(datasetIndex);
                const data = _data || dataset.data;
                if (resolve([
                    indexAxis,
                    chart.options.indexAxis
                ]) === 'y') {
                    return;
                }
                if (!meta.controller.supportsDecimation) {
                    return;
                }
                const xAxis = chart.scales[meta.xAxisID];
                if (xAxis.type !== 'linear' && xAxis.type !== 'time') {
                    return;
                }
                if (chart.options.parsing) {
                    return;
                }
                let { start , count  } = getStartAndCountOfVisiblePointsSimplified(meta, data);
                const threshold = options.threshold || 4 * availableWidth;
                if (count <= threshold) {
                    cleanDecimatedDataset(dataset);
                    return;
                }
                if (isNullOrUndef(_data)) {
                    dataset._data = data;
                    delete dataset.data;
                    Object.defineProperty(dataset, 'data', {
                        configurable: true,
                        enumerable: true,
                        get: function() {
                            return this._decimated;
                        },
                        set: function(d) {
                            this._data = d;
                        }
                    });
                }
                let decimated;
                switch(options.algorithm){
                    case 'lttb':
                        decimated = lttbDecimation(data, start, count, availableWidth, options);
                        break;
                    case 'min-max':
                        decimated = minMaxDecimation(data, start, count, availableWidth);
                        break;
                    default:
                        throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);
                }
                dataset._decimated = decimated;
            });
        },
        destroy (chart) {
            cleanDecimatedData(chart);
        }
    };

    function _segments(line, target, property) {
        const segments = line.segments;
        const points = line.points;
        const tpoints = target.points;
        const parts = [];
        for (const segment of segments){
            let { start , end  } = segment;
            end = _findSegmentEnd(start, end, points);
            const bounds = _getBounds(property, points[start], points[end], segment.loop);
            if (!target.segments) {
                parts.push({
                    source: segment,
                    target: bounds,
                    start: points[start],
                    end: points[end]
                });
                continue;
            }
            const targetSegments = _boundSegments(target, bounds);
            for (const tgt of targetSegments){
                const subBounds = _getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);
                const fillSources = _boundSegment(segment, points, subBounds);
                for (const fillSource of fillSources){
                    parts.push({
                        source: fillSource,
                        target: tgt,
                        start: {
                            [property]: _getEdge(bounds, subBounds, 'start', Math.max)
                        },
                        end: {
                            [property]: _getEdge(bounds, subBounds, 'end', Math.min)
                        }
                    });
                }
            }
        }
        return parts;
    }
    function _getBounds(property, first, last, loop) {
        if (loop) {
            return;
        }
        let start = first[property];
        let end = last[property];
        if (property === 'angle') {
            start = _normalizeAngle(start);
            end = _normalizeAngle(end);
        }
        return {
            property,
            start,
            end
        };
    }
    function _pointsFromSegments(boundary, line) {
        const { x =null , y =null  } = boundary || {};
        const linePoints = line.points;
        const points = [];
        line.segments.forEach(({ start , end  })=>{
            end = _findSegmentEnd(start, end, linePoints);
            const first = linePoints[start];
            const last = linePoints[end];
            if (y !== null) {
                points.push({
                    x: first.x,
                    y
                });
                points.push({
                    x: last.x,
                    y
                });
            } else if (x !== null) {
                points.push({
                    x,
                    y: first.y
                });
                points.push({
                    x,
                    y: last.y
                });
            }
        });
        return points;
    }
    function _findSegmentEnd(start, end, points) {
        for(; end > start; end--){
            const point = points[end];
            if (!isNaN(point.x) && !isNaN(point.y)) {
                break;
            }
        }
        return end;
    }
    function _getEdge(a, b, prop, fn) {
        if (a && b) {
            return fn(a[prop], b[prop]);
        }
        return a ? a[prop] : b ? b[prop] : 0;
    }

    function _createBoundaryLine(boundary, line) {
        let points = [];
        let _loop = false;
        if (isArray$1(boundary)) {
            _loop = true;
            points = boundary;
        } else {
            points = _pointsFromSegments(boundary, line);
        }
        return points.length ? new LineElement({
            points,
            options: {
                tension: 0
            },
            _loop,
            _fullLoop: _loop
        }) : null;
    }
    function _shouldApplyFill(source) {
        return source && source.fill !== false;
    }

    function _resolveTarget(sources, index, propagate) {
        const source = sources[index];
        let fill = source.fill;
        const visited = [
            index
        ];
        let target;
        if (!propagate) {
            return fill;
        }
        while(fill !== false && visited.indexOf(fill) === -1){
            if (!isNumberFinite(fill)) {
                return fill;
            }
            target = sources[fill];
            if (!target) {
                return false;
            }
            if (target.visible) {
                return fill;
            }
            visited.push(fill);
            fill = target.fill;
        }
        return false;
    }
     function _decodeFill(line, index, count) {
         const fill = parseFillOption(line);
        if (isObject$1(fill)) {
            return isNaN(fill.value) ? false : fill;
        }
        let target = parseFloat(fill);
        if (isNumberFinite(target) && Math.floor(target) === target) {
            return decodeTargetIndex(fill[0], index, target, count);
        }
        return [
            'origin',
            'start',
            'end',
            'stack',
            'shape'
        ].indexOf(fill) >= 0 && fill;
    }
    function decodeTargetIndex(firstCh, index, target, count) {
        if (firstCh === '-' || firstCh === '+') {
            target = index + target;
        }
        if (target === index || target < 0 || target >= count) {
            return false;
        }
        return target;
    }
     function _getTargetPixel(fill, scale) {
        let pixel = null;
        if (fill === 'start') {
            pixel = scale.bottom;
        } else if (fill === 'end') {
            pixel = scale.top;
        } else if (isObject$1(fill)) {
            pixel = scale.getPixelForValue(fill.value);
        } else if (scale.getBasePixel) {
            pixel = scale.getBasePixel();
        }
        return pixel;
    }
     function _getTargetValue(fill, scale, startValue) {
        let value;
        if (fill === 'start') {
            value = startValue;
        } else if (fill === 'end') {
            value = scale.options.reverse ? scale.min : scale.max;
        } else if (isObject$1(fill)) {
            value = fill.value;
        } else {
            value = scale.getBaseValue();
        }
        return value;
    }
     function parseFillOption(line) {
        const options = line.options;
        const fillOption = options.fill;
        let fill = valueOrDefault(fillOption && fillOption.target, fillOption);
        if (fill === undefined) {
            fill = !!options.backgroundColor;
        }
        if (fill === false || fill === null) {
            return false;
        }
        if (fill === true) {
            return 'origin';
        }
        return fill;
    }

    function _buildStackLine(source) {
        const { scale , index , line  } = source;
        const points = [];
        const segments = line.segments;
        const sourcePoints = line.points;
        const linesBelow = getLinesBelow(scale, index);
        linesBelow.push(_createBoundaryLine({
            x: null,
            y: scale.bottom
        }, line));
        for(let i = 0; i < segments.length; i++){
            const segment = segments[i];
            for(let j = segment.start; j <= segment.end; j++){
                addPointsBelow(points, sourcePoints[j], linesBelow);
            }
        }
        return new LineElement({
            points,
            options: {}
        });
    }
     function getLinesBelow(scale, index) {
        const below = [];
        const metas = scale.getMatchingVisibleMetas('line');
        for(let i = 0; i < metas.length; i++){
            const meta = metas[i];
            if (meta.index === index) {
                break;
            }
            if (!meta.hidden) {
                below.unshift(meta.dataset);
            }
        }
        return below;
    }
     function addPointsBelow(points, sourcePoint, linesBelow) {
        const postponed = [];
        for(let j = 0; j < linesBelow.length; j++){
            const line = linesBelow[j];
            const { first , last , point  } = findPoint(line, sourcePoint, 'x');
            if (!point || first && last) {
                continue;
            }
            if (first) {
                postponed.unshift(point);
            } else {
                points.push(point);
                if (!last) {
                    break;
                }
            }
        }
        points.push(...postponed);
    }
     function findPoint(line, sourcePoint, property) {
        const point = line.interpolate(sourcePoint, property);
        if (!point) {
            return {};
        }
        const pointValue = point[property];
        const segments = line.segments;
        const linePoints = line.points;
        let first = false;
        let last = false;
        for(let i = 0; i < segments.length; i++){
            const segment = segments[i];
            const firstValue = linePoints[segment.start][property];
            const lastValue = linePoints[segment.end][property];
            if (_isBetween(pointValue, firstValue, lastValue)) {
                first = pointValue === firstValue;
                last = pointValue === lastValue;
                break;
            }
        }
        return {
            first,
            last,
            point
        };
    }

    class simpleArc {
        constructor(opts){
            this.x = opts.x;
            this.y = opts.y;
            this.radius = opts.radius;
        }
        pathSegment(ctx, bounds, opts) {
            const { x , y , radius  } = this;
            bounds = bounds || {
                start: 0,
                end: TAU
            };
            ctx.arc(x, y, radius, bounds.end, bounds.start, true);
            return !opts.bounds;
        }
        interpolate(point) {
            const { x , y , radius  } = this;
            const angle = point.angle;
            return {
                x: x + Math.cos(angle) * radius,
                y: y + Math.sin(angle) * radius,
                angle
            };
        }
    }

    function _getTarget(source) {
        const { chart , fill , line  } = source;
        if (isNumberFinite(fill)) {
            return getLineByIndex(chart, fill);
        }
        if (fill === 'stack') {
            return _buildStackLine(source);
        }
        if (fill === 'shape') {
            return true;
        }
        const boundary = computeBoundary(source);
        if (boundary instanceof simpleArc) {
            return boundary;
        }
        return _createBoundaryLine(boundary, line);
    }
     function getLineByIndex(chart, index) {
        const meta = chart.getDatasetMeta(index);
        const visible = meta && chart.isDatasetVisible(index);
        return visible ? meta.dataset : null;
    }
    function computeBoundary(source) {
        const scale = source.scale || {};
        if (scale.getPointPositionForValue) {
            return computeCircularBoundary(source);
        }
        return computeLinearBoundary(source);
    }
    function computeLinearBoundary(source) {
        const { scale ={} , fill  } = source;
        const pixel = _getTargetPixel(fill, scale);
        if (isNumberFinite(pixel)) {
            const horizontal = scale.isHorizontal();
            return {
                x: horizontal ? pixel : null,
                y: horizontal ? null : pixel
            };
        }
        return null;
    }
    function computeCircularBoundary(source) {
        const { scale , fill  } = source;
        const options = scale.options;
        const length = scale.getLabels().length;
        const start = options.reverse ? scale.max : scale.min;
        const value = _getTargetValue(fill, scale, start);
        const target = [];
        if (options.grid.circular) {
            const center = scale.getPointPositionForValue(0, start);
            return new simpleArc({
                x: center.x,
                y: center.y,
                radius: scale.getDistanceFromCenterForValue(value)
            });
        }
        for(let i = 0; i < length; ++i){
            target.push(scale.getPointPositionForValue(i, value));
        }
        return target;
    }

    function _drawfill(ctx, source, area) {
        const target = _getTarget(source);
        const { line , scale , axis  } = source;
        const lineOpts = line.options;
        const fillOption = lineOpts.fill;
        const color = lineOpts.backgroundColor;
        const { above =color , below =color  } = fillOption || {};
        if (target && line.points.length) {
            clipArea(ctx, area);
            doFill(ctx, {
                line,
                target,
                above,
                below,
                area,
                scale,
                axis
            });
            unclipArea(ctx);
        }
    }
    function doFill(ctx, cfg) {
        const { line , target , above , below , area , scale  } = cfg;
        const property = line._loop ? 'angle' : cfg.axis;
        ctx.save();
        if (property === 'x' && below !== above) {
            clipVertical(ctx, target, area.top);
            fill(ctx, {
                line,
                target,
                color: above,
                scale,
                property
            });
            ctx.restore();
            ctx.save();
            clipVertical(ctx, target, area.bottom);
        }
        fill(ctx, {
            line,
            target,
            color: below,
            scale,
            property
        });
        ctx.restore();
    }
    function clipVertical(ctx, target, clipY) {
        const { segments , points  } = target;
        let first = true;
        let lineLoop = false;
        ctx.beginPath();
        for (const segment of segments){
            const { start , end  } = segment;
            const firstPoint = points[start];
            const lastPoint = points[_findSegmentEnd(start, end, points)];
            if (first) {
                ctx.moveTo(firstPoint.x, firstPoint.y);
                first = false;
            } else {
                ctx.lineTo(firstPoint.x, clipY);
                ctx.lineTo(firstPoint.x, firstPoint.y);
            }
            lineLoop = !!target.pathSegment(ctx, segment, {
                move: lineLoop
            });
            if (lineLoop) {
                ctx.closePath();
            } else {
                ctx.lineTo(lastPoint.x, clipY);
            }
        }
        ctx.lineTo(target.first().x, clipY);
        ctx.closePath();
        ctx.clip();
    }
    function fill(ctx, cfg) {
        const { line , target , property , color , scale  } = cfg;
        const segments = _segments(line, target, property);
        for (const { source: src , target: tgt , start , end  } of segments){
            const { style: { backgroundColor =color  } = {}  } = src;
            const notShape = target !== true;
            ctx.save();
            ctx.fillStyle = backgroundColor;
            clipBounds(ctx, scale, notShape && _getBounds(property, start, end));
            ctx.beginPath();
            const lineLoop = !!line.pathSegment(ctx, src);
            let loop;
            if (notShape) {
                if (lineLoop) {
                    ctx.closePath();
                } else {
                    interpolatedLineTo(ctx, target, end, property);
                }
                const targetLoop = !!target.pathSegment(ctx, tgt, {
                    move: lineLoop,
                    reverse: true
                });
                loop = lineLoop && targetLoop;
                if (!loop) {
                    interpolatedLineTo(ctx, target, start, property);
                }
            }
            ctx.closePath();
            ctx.fill(loop ? 'evenodd' : 'nonzero');
            ctx.restore();
        }
    }
    function clipBounds(ctx, scale, bounds) {
        const { top , bottom  } = scale.chart.chartArea;
        const { property , start , end  } = bounds || {};
        if (property === 'x') {
            ctx.beginPath();
            ctx.rect(start, top, end - start, bottom - top);
            ctx.clip();
        }
    }
    function interpolatedLineTo(ctx, target, point, property) {
        const interpolatedPoint = target.interpolate(point, property);
        if (interpolatedPoint) {
            ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);
        }
    }

    var index = {
        id: 'filler',
        afterDatasetsUpdate (chart, _args, options) {
            const count = (chart.data.datasets || []).length;
            const sources = [];
            let meta, i, line, source;
            for(i = 0; i < count; ++i){
                meta = chart.getDatasetMeta(i);
                line = meta.dataset;
                source = null;
                if (line && line.options && line instanceof LineElement) {
                    source = {
                        visible: chart.isDatasetVisible(i),
                        index: i,
                        fill: _decodeFill(line, i, count),
                        chart,
                        axis: meta.controller.options.indexAxis,
                        scale: meta.vScale,
                        line
                    };
                }
                meta.$filler = source;
                sources.push(source);
            }
            for(i = 0; i < count; ++i){
                source = sources[i];
                if (!source || source.fill === false) {
                    continue;
                }
                source.fill = _resolveTarget(sources, i, options.propagate);
            }
        },
        beforeDraw (chart, _args, options) {
            const draw = options.drawTime === 'beforeDraw';
            const metasets = chart.getSortedVisibleDatasetMetas();
            const area = chart.chartArea;
            for(let i = metasets.length - 1; i >= 0; --i){
                const source = metasets[i].$filler;
                if (!source) {
                    continue;
                }
                source.line.updateControlPoints(area, source.axis);
                if (draw && source.fill) {
                    _drawfill(chart.ctx, source, area);
                }
            }
        },
        beforeDatasetsDraw (chart, _args, options) {
            if (options.drawTime !== 'beforeDatasetsDraw') {
                return;
            }
            const metasets = chart.getSortedVisibleDatasetMetas();
            for(let i = metasets.length - 1; i >= 0; --i){
                const source = metasets[i].$filler;
                if (_shouldApplyFill(source)) {
                    _drawfill(chart.ctx, source, chart.chartArea);
                }
            }
        },
        beforeDatasetDraw (chart, args, options) {
            const source = args.meta.$filler;
            if (!_shouldApplyFill(source) || options.drawTime !== 'beforeDatasetDraw') {
                return;
            }
            _drawfill(chart.ctx, source, chart.chartArea);
        },
        defaults: {
            propagate: true,
            drawTime: 'beforeDatasetDraw'
        }
    };

    const getBoxSize = (labelOpts, fontSize)=>{
        let { boxHeight =fontSize , boxWidth =fontSize  } = labelOpts;
        if (labelOpts.usePointStyle) {
            boxHeight = Math.min(boxHeight, fontSize);
            boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);
        }
        return {
            boxWidth,
            boxHeight,
            itemHeight: Math.max(fontSize, boxHeight)
        };
    };
    const itemsEqual = (a, b)=>a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;
    class Legend extends Element$1 {
     constructor(config){
            super();
            this._added = false;
            this.legendHitBoxes = [];
     this._hoveredItem = null;
            this.doughnutMode = false;
            this.chart = config.chart;
            this.options = config.options;
            this.ctx = config.ctx;
            this.legendItems = undefined;
            this.columnSizes = undefined;
            this.lineWidths = undefined;
            this.maxHeight = undefined;
            this.maxWidth = undefined;
            this.top = undefined;
            this.bottom = undefined;
            this.left = undefined;
            this.right = undefined;
            this.height = undefined;
            this.width = undefined;
            this._margins = undefined;
            this.position = undefined;
            this.weight = undefined;
            this.fullSize = undefined;
        }
        update(maxWidth, maxHeight, margins) {
            this.maxWidth = maxWidth;
            this.maxHeight = maxHeight;
            this._margins = margins;
            this.setDimensions();
            this.buildLabels();
            this.fit();
        }
        setDimensions() {
            if (this.isHorizontal()) {
                this.width = this.maxWidth;
                this.left = this._margins.left;
                this.right = this.width;
            } else {
                this.height = this.maxHeight;
                this.top = this._margins.top;
                this.bottom = this.height;
            }
        }
        buildLabels() {
            const labelOpts = this.options.labels || {};
            let legendItems = callback(labelOpts.generateLabels, [
                this.chart
            ], this) || [];
            if (labelOpts.filter) {
                legendItems = legendItems.filter((item)=>labelOpts.filter(item, this.chart.data));
            }
            if (labelOpts.sort) {
                legendItems = legendItems.sort((a, b)=>labelOpts.sort(a, b, this.chart.data));
            }
            if (this.options.reverse) {
                legendItems.reverse();
            }
            this.legendItems = legendItems;
        }
        fit() {
            const { options , ctx  } = this;
            if (!options.display) {
                this.width = this.height = 0;
                return;
            }
            const labelOpts = options.labels;
            const labelFont = toFont(labelOpts.font);
            const fontSize = labelFont.size;
            const titleHeight = this._computeTitleHeight();
            const { boxWidth , itemHeight  } = getBoxSize(labelOpts, fontSize);
            let width, height;
            ctx.font = labelFont.string;
            if (this.isHorizontal()) {
                width = this.maxWidth;
                height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;
            } else {
                height = this.maxHeight;
                width = this._fitCols(titleHeight, labelFont, boxWidth, itemHeight) + 10;
            }
            this.width = Math.min(width, options.maxWidth || this.maxWidth);
            this.height = Math.min(height, options.maxHeight || this.maxHeight);
        }
     _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {
            const { ctx , maxWidth , options: { labels: { padding  }  }  } = this;
            const hitboxes = this.legendHitBoxes = [];
            const lineWidths = this.lineWidths = [
                0
            ];
            const lineHeight = itemHeight + padding;
            let totalHeight = titleHeight;
            ctx.textAlign = 'left';
            ctx.textBaseline = 'middle';
            let row = -1;
            let top = -lineHeight;
            this.legendItems.forEach((legendItem, i)=>{
                const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
                if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {
                    totalHeight += lineHeight;
                    lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;
                    top += lineHeight;
                    row++;
                }
                hitboxes[i] = {
                    left: 0,
                    top,
                    row,
                    width: itemWidth,
                    height: itemHeight
                };
                lineWidths[lineWidths.length - 1] += itemWidth + padding;
            });
            return totalHeight;
        }
        _fitCols(titleHeight, labelFont, boxWidth, _itemHeight) {
            const { ctx , maxHeight , options: { labels: { padding  }  }  } = this;
            const hitboxes = this.legendHitBoxes = [];
            const columnSizes = this.columnSizes = [];
            const heightLimit = maxHeight - titleHeight;
            let totalWidth = padding;
            let currentColWidth = 0;
            let currentColHeight = 0;
            let left = 0;
            let col = 0;
            this.legendItems.forEach((legendItem, i)=>{
                const { itemWidth , itemHeight  } = calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight);
                if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {
                    totalWidth += currentColWidth + padding;
                    columnSizes.push({
                        width: currentColWidth,
                        height: currentColHeight
                    });
                    left += currentColWidth + padding;
                    col++;
                    currentColWidth = currentColHeight = 0;
                }
                hitboxes[i] = {
                    left,
                    top: currentColHeight,
                    col,
                    width: itemWidth,
                    height: itemHeight
                };
                currentColWidth = Math.max(currentColWidth, itemWidth);
                currentColHeight += itemHeight + padding;
            });
            totalWidth += currentColWidth;
            columnSizes.push({
                width: currentColWidth,
                height: currentColHeight
            });
            return totalWidth;
        }
        adjustHitBoxes() {
            if (!this.options.display) {
                return;
            }
            const titleHeight = this._computeTitleHeight();
            const { legendHitBoxes: hitboxes , options: { align , labels: { padding  } , rtl  }  } = this;
            const rtlHelper = getRtlAdapter(rtl, this.left, this.width);
            if (this.isHorizontal()) {
                let row = 0;
                let left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
                for (const hitbox of hitboxes){
                    if (row !== hitbox.row) {
                        row = hitbox.row;
                        left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
                    }
                    hitbox.top += this.top + titleHeight + padding;
                    hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);
                    left += hitbox.width + padding;
                }
            } else {
                let col = 0;
                let top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
                for (const hitbox of hitboxes){
                    if (hitbox.col !== col) {
                        col = hitbox.col;
                        top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
                    }
                    hitbox.top = top;
                    hitbox.left += this.left + padding;
                    hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);
                    top += hitbox.height + padding;
                }
            }
        }
        isHorizontal() {
            return this.options.position === 'top' || this.options.position === 'bottom';
        }
        draw() {
            if (this.options.display) {
                const ctx = this.ctx;
                clipArea(ctx, this);
                this._draw();
                unclipArea(ctx);
            }
        }
     _draw() {
            const { options: opts , columnSizes , lineWidths , ctx  } = this;
            const { align , labels: labelOpts  } = opts;
            const defaultColor = defaults$1.color;
            const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
            const labelFont = toFont(labelOpts.font);
            const { padding  } = labelOpts;
            const fontSize = labelFont.size;
            const halfFontSize = fontSize / 2;
            let cursor;
            this.drawTitle();
            ctx.textAlign = rtlHelper.textAlign('left');
            ctx.textBaseline = 'middle';
            ctx.lineWidth = 0.5;
            ctx.font = labelFont.string;
            const { boxWidth , boxHeight , itemHeight  } = getBoxSize(labelOpts, fontSize);
            const drawLegendBox = function(x, y, legendItem) {
                if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {
                    return;
                }
                ctx.save();
                const lineWidth = valueOrDefault(legendItem.lineWidth, 1);
                ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);
                ctx.lineCap = valueOrDefault(legendItem.lineCap, 'butt');
                ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);
                ctx.lineJoin = valueOrDefault(legendItem.lineJoin, 'miter');
                ctx.lineWidth = lineWidth;
                ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);
                ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));
                if (labelOpts.usePointStyle) {
                    const drawOptions = {
                        radius: boxHeight * Math.SQRT2 / 2,
                        pointStyle: legendItem.pointStyle,
                        rotation: legendItem.rotation,
                        borderWidth: lineWidth
                    };
                    const centerX = rtlHelper.xPlus(x, boxWidth / 2);
                    const centerY = y + halfFontSize;
                    drawPointLegend(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);
                } else {
                    const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);
                    const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);
                    const borderRadius = toTRBLCorners(legendItem.borderRadius);
                    ctx.beginPath();
                    if (Object.values(borderRadius).some((v)=>v !== 0)) {
                        addRoundedRectPath(ctx, {
                            x: xBoxLeft,
                            y: yBoxTop,
                            w: boxWidth,
                            h: boxHeight,
                            radius: borderRadius
                        });
                    } else {
                        ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);
                    }
                    ctx.fill();
                    if (lineWidth !== 0) {
                        ctx.stroke();
                    }
                }
                ctx.restore();
            };
            const fillText = function(x, y, legendItem) {
                renderText(ctx, legendItem.text, x, y + itemHeight / 2, labelFont, {
                    strikethrough: legendItem.hidden,
                    textAlign: rtlHelper.textAlign(legendItem.textAlign)
                });
            };
            const isHorizontal = this.isHorizontal();
            const titleHeight = this._computeTitleHeight();
            if (isHorizontal) {
                cursor = {
                    x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),
                    y: this.top + padding + titleHeight,
                    line: 0
                };
            } else {
                cursor = {
                    x: this.left + padding,
                    y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),
                    line: 0
                };
            }
            overrideTextDirection(this.ctx, opts.textDirection);
            const lineHeight = itemHeight + padding;
            this.legendItems.forEach((legendItem, i)=>{
                ctx.strokeStyle = legendItem.fontColor;
                ctx.fillStyle = legendItem.fontColor;
                const textWidth = ctx.measureText(legendItem.text).width;
                const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));
                const width = boxWidth + halfFontSize + textWidth;
                let x = cursor.x;
                let y = cursor.y;
                rtlHelper.setWidth(this.width);
                if (isHorizontal) {
                    if (i > 0 && x + width + padding > this.right) {
                        y = cursor.y += lineHeight;
                        cursor.line++;
                        x = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);
                    }
                } else if (i > 0 && y + lineHeight > this.bottom) {
                    x = cursor.x = x + columnSizes[cursor.line].width + padding;
                    cursor.line++;
                    y = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);
                }
                const realX = rtlHelper.x(x);
                drawLegendBox(realX, y, legendItem);
                x = _textX(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);
                fillText(rtlHelper.x(x), y, legendItem);
                if (isHorizontal) {
                    cursor.x += width + padding;
                } else if (typeof legendItem.text !== 'string') {
                    const fontLineHeight = labelFont.lineHeight;
                    cursor.y += calculateLegendItemHeight(legendItem, fontLineHeight) + padding;
                } else {
                    cursor.y += lineHeight;
                }
            });
            restoreTextDirection(this.ctx, opts.textDirection);
        }
     drawTitle() {
            const opts = this.options;
            const titleOpts = opts.title;
            const titleFont = toFont(titleOpts.font);
            const titlePadding = toPadding(titleOpts.padding);
            if (!titleOpts.display) {
                return;
            }
            const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
            const ctx = this.ctx;
            const position = titleOpts.position;
            const halfFontSize = titleFont.size / 2;
            const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;
            let y;
            let left = this.left;
            let maxWidth = this.width;
            if (this.isHorizontal()) {
                maxWidth = Math.max(...this.lineWidths);
                y = this.top + topPaddingPlusHalfFontSize;
                left = _alignStartEnd(opts.align, left, this.right - maxWidth);
            } else {
                const maxHeight = this.columnSizes.reduce((acc, size)=>Math.max(acc, size.height), 0);
                y = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());
            }
            const x = _alignStartEnd(position, left, left + maxWidth);
            ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));
            ctx.textBaseline = 'middle';
            ctx.strokeStyle = titleOpts.color;
            ctx.fillStyle = titleOpts.color;
            ctx.font = titleFont.string;
            renderText(ctx, titleOpts.text, x, y, titleFont);
        }
     _computeTitleHeight() {
            const titleOpts = this.options.title;
            const titleFont = toFont(titleOpts.font);
            const titlePadding = toPadding(titleOpts.padding);
            return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;
        }
     _getLegendItemAt(x, y) {
            let i, hitBox, lh;
            if (_isBetween(x, this.left, this.right) && _isBetween(y, this.top, this.bottom)) {
                lh = this.legendHitBoxes;
                for(i = 0; i < lh.length; ++i){
                    hitBox = lh[i];
                    if (_isBetween(x, hitBox.left, hitBox.left + hitBox.width) && _isBetween(y, hitBox.top, hitBox.top + hitBox.height)) {
                        return this.legendItems[i];
                    }
                }
            }
            return null;
        }
     handleEvent(e) {
            const opts = this.options;
            if (!isListened(e.type, opts)) {
                return;
            }
            const hoveredItem = this._getLegendItemAt(e.x, e.y);
            if (e.type === 'mousemove' || e.type === 'mouseout') {
                const previous = this._hoveredItem;
                const sameItem = itemsEqual(previous, hoveredItem);
                if (previous && !sameItem) {
                    callback(opts.onLeave, [
                        e,
                        previous,
                        this
                    ], this);
                }
                this._hoveredItem = hoveredItem;
                if (hoveredItem && !sameItem) {
                    callback(opts.onHover, [
                        e,
                        hoveredItem,
                        this
                    ], this);
                }
            } else if (hoveredItem) {
                callback(opts.onClick, [
                    e,
                    hoveredItem,
                    this
                ], this);
            }
        }
    }
    function calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight) {
        const itemWidth = calculateItemWidth(legendItem, boxWidth, labelFont, ctx);
        const itemHeight = calculateItemHeight(_itemHeight, legendItem, labelFont.lineHeight);
        return {
            itemWidth,
            itemHeight
        };
    }
    function calculateItemWidth(legendItem, boxWidth, labelFont, ctx) {
        let legendItemText = legendItem.text;
        if (legendItemText && typeof legendItemText !== 'string') {
            legendItemText = legendItemText.reduce((a, b)=>a.length > b.length ? a : b);
        }
        return boxWidth + labelFont.size / 2 + ctx.measureText(legendItemText).width;
    }
    function calculateItemHeight(_itemHeight, legendItem, fontLineHeight) {
        let itemHeight = _itemHeight;
        if (typeof legendItem.text !== 'string') {
            itemHeight = calculateLegendItemHeight(legendItem, fontLineHeight);
        }
        return itemHeight;
    }
    function calculateLegendItemHeight(legendItem, fontLineHeight) {
        const labelHeight = legendItem.text ? legendItem.text.length : 0;
        return fontLineHeight * labelHeight;
    }
    function isListened(type, opts) {
        if ((type === 'mousemove' || type === 'mouseout') && (opts.onHover || opts.onLeave)) {
            return true;
        }
        if (opts.onClick && (type === 'click' || type === 'mouseup')) {
            return true;
        }
        return false;
    }
    var plugin_legend = {
        id: 'legend',
     _element: Legend,
        start (chart, _args, options) {
            const legend = chart.legend = new Legend({
                ctx: chart.ctx,
                options,
                chart
            });
            layouts.configure(chart, legend, options);
            layouts.addBox(chart, legend);
        },
        stop (chart) {
            layouts.removeBox(chart, chart.legend);
            delete chart.legend;
        },
        beforeUpdate (chart, _args, options) {
            const legend = chart.legend;
            layouts.configure(chart, legend, options);
            legend.options = options;
        },
        afterUpdate (chart) {
            const legend = chart.legend;
            legend.buildLabels();
            legend.adjustHitBoxes();
        },
        afterEvent (chart, args) {
            if (!args.replay) {
                chart.legend.handleEvent(args.event);
            }
        },
        defaults: {
            display: true,
            position: 'top',
            align: 'center',
            fullSize: true,
            reverse: false,
            weight: 1000,
            onClick (e, legendItem, legend) {
                const index = legendItem.datasetIndex;
                const ci = legend.chart;
                if (ci.isDatasetVisible(index)) {
                    ci.hide(index);
                    legendItem.hidden = true;
                } else {
                    ci.show(index);
                    legendItem.hidden = false;
                }
            },
            onHover: null,
            onLeave: null,
            labels: {
                color: (ctx)=>ctx.chart.options.color,
                boxWidth: 40,
                padding: 10,
                generateLabels (chart) {
                    const datasets = chart.data.datasets;
                    const { labels: { usePointStyle , pointStyle , textAlign , color , useBorderRadius , borderRadius  }  } = chart.legend.options;
                    return chart._getSortedDatasetMetas().map((meta)=>{
                        const style = meta.controller.getStyle(usePointStyle ? 0 : undefined);
                        const borderWidth = toPadding(style.borderWidth);
                        return {
                            text: datasets[meta.index].label,
                            fillStyle: style.backgroundColor,
                            fontColor: color,
                            hidden: !meta.visible,
                            lineCap: style.borderCapStyle,
                            lineDash: style.borderDash,
                            lineDashOffset: style.borderDashOffset,
                            lineJoin: style.borderJoinStyle,
                            lineWidth: (borderWidth.width + borderWidth.height) / 4,
                            strokeStyle: style.borderColor,
                            pointStyle: pointStyle || style.pointStyle,
                            rotation: style.rotation,
                            textAlign: textAlign || style.textAlign,
                            borderRadius: useBorderRadius && (borderRadius || style.borderRadius),
                            datasetIndex: meta.index
                        };
                    }, this);
                }
            },
            title: {
                color: (ctx)=>ctx.chart.options.color,
                display: false,
                position: 'center',
                text: ''
            }
        },
        descriptors: {
            _scriptable: (name)=>!name.startsWith('on'),
            labels: {
                _scriptable: (name)=>![
                        'generateLabels',
                        'filter',
                        'sort'
                    ].includes(name)
            }
        }
    };

    class Title extends Element$1 {
     constructor(config){
            super();
            this.chart = config.chart;
            this.options = config.options;
            this.ctx = config.ctx;
            this._padding = undefined;
            this.top = undefined;
            this.bottom = undefined;
            this.left = undefined;
            this.right = undefined;
            this.width = undefined;
            this.height = undefined;
            this.position = undefined;
            this.weight = undefined;
            this.fullSize = undefined;
        }
        update(maxWidth, maxHeight) {
            const opts = this.options;
            this.left = 0;
            this.top = 0;
            if (!opts.display) {
                this.width = this.height = this.right = this.bottom = 0;
                return;
            }
            this.width = this.right = maxWidth;
            this.height = this.bottom = maxHeight;
            const lineCount = isArray$1(opts.text) ? opts.text.length : 1;
            this._padding = toPadding(opts.padding);
            const textSize = lineCount * toFont(opts.font).lineHeight + this._padding.height;
            if (this.isHorizontal()) {
                this.height = textSize;
            } else {
                this.width = textSize;
            }
        }
        isHorizontal() {
            const pos = this.options.position;
            return pos === 'top' || pos === 'bottom';
        }
        _drawArgs(offset) {
            const { top , left , bottom , right , options  } = this;
            const align = options.align;
            let rotation = 0;
            let maxWidth, titleX, titleY;
            if (this.isHorizontal()) {
                titleX = _alignStartEnd(align, left, right);
                titleY = top + offset;
                maxWidth = right - left;
            } else {
                if (options.position === 'left') {
                    titleX = left + offset;
                    titleY = _alignStartEnd(align, bottom, top);
                    rotation = PI * -0.5;
                } else {
                    titleX = right - offset;
                    titleY = _alignStartEnd(align, top, bottom);
                    rotation = PI * 0.5;
                }
                maxWidth = bottom - top;
            }
            return {
                titleX,
                titleY,
                maxWidth,
                rotation
            };
        }
        draw() {
            const ctx = this.ctx;
            const opts = this.options;
            if (!opts.display) {
                return;
            }
            const fontOpts = toFont(opts.font);
            const lineHeight = fontOpts.lineHeight;
            const offset = lineHeight / 2 + this._padding.top;
            const { titleX , titleY , maxWidth , rotation  } = this._drawArgs(offset);
            renderText(ctx, opts.text, 0, 0, fontOpts, {
                color: opts.color,
                maxWidth,
                rotation,
                textAlign: _toLeftRightCenter(opts.align),
                textBaseline: 'middle',
                translation: [
                    titleX,
                    titleY
                ]
            });
        }
    }
    function createTitle(chart, titleOpts) {
        const title = new Title({
            ctx: chart.ctx,
            options: titleOpts,
            chart
        });
        layouts.configure(chart, title, titleOpts);
        layouts.addBox(chart, title);
        chart.titleBlock = title;
    }
    var plugin_title = {
        id: 'title',
     _element: Title,
        start (chart, _args, options) {
            createTitle(chart, options);
        },
        stop (chart) {
            const titleBlock = chart.titleBlock;
            layouts.removeBox(chart, titleBlock);
            delete chart.titleBlock;
        },
        beforeUpdate (chart, _args, options) {
            const title = chart.titleBlock;
            layouts.configure(chart, title, options);
            title.options = options;
        },
        defaults: {
            align: 'center',
            display: false,
            font: {
                weight: 'bold'
            },
            fullSize: true,
            padding: 10,
            position: 'top',
            text: '',
            weight: 2000
        },
        defaultRoutes: {
            color: 'color'
        },
        descriptors: {
            _scriptable: true,
            _indexable: false
        }
    };

    const map$1 = new WeakMap();
    var plugin_subtitle = {
        id: 'subtitle',
        start (chart, _args, options) {
            const title = new Title({
                ctx: chart.ctx,
                options,
                chart
            });
            layouts.configure(chart, title, options);
            layouts.addBox(chart, title);
            map$1.set(chart, title);
        },
        stop (chart) {
            layouts.removeBox(chart, map$1.get(chart));
            map$1.delete(chart);
        },
        beforeUpdate (chart, _args, options) {
            const title = map$1.get(chart);
            layouts.configure(chart, title, options);
            title.options = options;
        },
        defaults: {
            align: 'center',
            display: false,
            font: {
                weight: 'normal'
            },
            fullSize: true,
            padding: 0,
            position: 'top',
            text: '',
            weight: 1500
        },
        defaultRoutes: {
            color: 'color'
        },
        descriptors: {
            _scriptable: true,
            _indexable: false
        }
    };

    const positioners = {
     average (items) {
            if (!items.length) {
                return false;
            }
            let i, len;
            let xSet = new Set();
            let y = 0;
            let count = 0;
            for(i = 0, len = items.length; i < len; ++i){
                const el = items[i].element;
                if (el && el.hasValue()) {
                    const pos = el.tooltipPosition();
                    xSet.add(pos.x);
                    y += pos.y;
                    ++count;
                }
            }
            if (count === 0 || xSet.size === 0) {
                return false;
            }
            const xAverage = [
                ...xSet
            ].reduce((a, b)=>a + b) / xSet.size;
            return {
                x: xAverage,
                y: y / count
            };
        },
     nearest (items, eventPosition) {
            if (!items.length) {
                return false;
            }
            let x = eventPosition.x;
            let y = eventPosition.y;
            let minDistance = Number.POSITIVE_INFINITY;
            let i, len, nearestElement;
            for(i = 0, len = items.length; i < len; ++i){
                const el = items[i].element;
                if (el && el.hasValue()) {
                    const center = el.getCenterPoint();
                    const d = distanceBetweenPoints(eventPosition, center);
                    if (d < minDistance) {
                        minDistance = d;
                        nearestElement = el;
                    }
                }
            }
            if (nearestElement) {
                const tp = nearestElement.tooltipPosition();
                x = tp.x;
                y = tp.y;
            }
            return {
                x,
                y
            };
        }
    };
    function pushOrConcat(base, toPush) {
        if (toPush) {
            if (isArray$1(toPush)) {
                Array.prototype.push.apply(base, toPush);
            } else {
                base.push(toPush);
            }
        }
        return base;
    }
     function splitNewlines(str) {
        if ((typeof str === 'string' || str instanceof String) && str.indexOf('\n') > -1) {
            return str.split('\n');
        }
        return str;
    }
     function createTooltipItem(chart, item) {
        const { element , datasetIndex , index  } = item;
        const controller = chart.getDatasetMeta(datasetIndex).controller;
        const { label , value  } = controller.getLabelAndValue(index);
        return {
            chart,
            label,
            parsed: controller.getParsed(index),
            raw: chart.data.datasets[datasetIndex].data[index],
            formattedValue: value,
            dataset: controller.getDataset(),
            dataIndex: index,
            datasetIndex,
            element
        };
    }
     function getTooltipSize(tooltip, options) {
        const ctx = tooltip.chart.ctx;
        const { body , footer , title  } = tooltip;
        const { boxWidth , boxHeight  } = options;
        const bodyFont = toFont(options.bodyFont);
        const titleFont = toFont(options.titleFont);
        const footerFont = toFont(options.footerFont);
        const titleLineCount = title.length;
        const footerLineCount = footer.length;
        const bodyLineItemCount = body.length;
        const padding = toPadding(options.padding);
        let height = padding.height;
        let width = 0;
        let combinedBodyLength = body.reduce((count, bodyItem)=>count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);
        combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;
        if (titleLineCount) {
            height += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options.titleSpacing + options.titleMarginBottom;
        }
        if (combinedBodyLength) {
            const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;
            height += bodyLineItemCount * bodyLineHeight + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options.bodySpacing;
        }
        if (footerLineCount) {
            height += options.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options.footerSpacing;
        }
        let widthPadding = 0;
        const maxLineWidth = function(line) {
            width = Math.max(width, ctx.measureText(line).width + widthPadding);
        };
        ctx.save();
        ctx.font = titleFont.string;
        each(tooltip.title, maxLineWidth);
        ctx.font = bodyFont.string;
        each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);
        widthPadding = options.displayColors ? boxWidth + 2 + options.boxPadding : 0;
        each(body, (bodyItem)=>{
            each(bodyItem.before, maxLineWidth);
            each(bodyItem.lines, maxLineWidth);
            each(bodyItem.after, maxLineWidth);
        });
        widthPadding = 0;
        ctx.font = footerFont.string;
        each(tooltip.footer, maxLineWidth);
        ctx.restore();
        width += padding.width;
        return {
            width,
            height
        };
    }
    function determineYAlign(chart, size) {
        const { y , height  } = size;
        if (y < height / 2) {
            return 'top';
        } else if (y > chart.height - height / 2) {
            return 'bottom';
        }
        return 'center';
    }
    function doesNotFitWithAlign(xAlign, chart, options, size) {
        const { x , width  } = size;
        const caret = options.caretSize + options.caretPadding;
        if (xAlign === 'left' && x + width + caret > chart.width) {
            return true;
        }
        if (xAlign === 'right' && x - width - caret < 0) {
            return true;
        }
    }
    function determineXAlign(chart, options, size, yAlign) {
        const { x , width  } = size;
        const { width: chartWidth , chartArea: { left , right  }  } = chart;
        let xAlign = 'center';
        if (yAlign === 'center') {
            xAlign = x <= (left + right) / 2 ? 'left' : 'right';
        } else if (x <= width / 2) {
            xAlign = 'left';
        } else if (x >= chartWidth - width / 2) {
            xAlign = 'right';
        }
        if (doesNotFitWithAlign(xAlign, chart, options, size)) {
            xAlign = 'center';
        }
        return xAlign;
    }
     function determineAlignment(chart, options, size) {
        const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);
        return {
            xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),
            yAlign
        };
    }
    function alignX(size, xAlign) {
        let { x , width  } = size;
        if (xAlign === 'right') {
            x -= width;
        } else if (xAlign === 'center') {
            x -= width / 2;
        }
        return x;
    }
    function alignY(size, yAlign, paddingAndSize) {
        let { y , height  } = size;
        if (yAlign === 'top') {
            y += paddingAndSize;
        } else if (yAlign === 'bottom') {
            y -= height + paddingAndSize;
        } else {
            y -= height / 2;
        }
        return y;
    }
     function getBackgroundPoint(options, size, alignment, chart) {
        const { caretSize , caretPadding , cornerRadius  } = options;
        const { xAlign , yAlign  } = alignment;
        const paddingAndSize = caretSize + caretPadding;
        const { topLeft , topRight , bottomLeft , bottomRight  } = toTRBLCorners(cornerRadius);
        let x = alignX(size, xAlign);
        const y = alignY(size, yAlign, paddingAndSize);
        if (yAlign === 'center') {
            if (xAlign === 'left') {
                x += paddingAndSize;
            } else if (xAlign === 'right') {
                x -= paddingAndSize;
            }
        } else if (xAlign === 'left') {
            x -= Math.max(topLeft, bottomLeft) + caretSize;
        } else if (xAlign === 'right') {
            x += Math.max(topRight, bottomRight) + caretSize;
        }
        return {
            x: _limitValue(x, 0, chart.width - size.width),
            y: _limitValue(y, 0, chart.height - size.height)
        };
    }
    function getAlignedX(tooltip, align, options) {
        const padding = toPadding(options.padding);
        return align === 'center' ? tooltip.x + tooltip.width / 2 : align === 'right' ? tooltip.x + tooltip.width - padding.right : tooltip.x + padding.left;
    }
     function getBeforeAfterBodyLines(callback) {
        return pushOrConcat([], splitNewlines(callback));
    }
    function createTooltipContext(parent, tooltip, tooltipItems) {
        return createContext(parent, {
            tooltip,
            tooltipItems,
            type: 'tooltip'
        });
    }
    function overrideCallbacks(callbacks, context) {
        const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;
        return override ? callbacks.override(override) : callbacks;
    }
    const defaultCallbacks = {
        beforeTitle: noop,
        title (tooltipItems) {
            if (tooltipItems.length > 0) {
                const item = tooltipItems[0];
                const labels = item.chart.data.labels;
                const labelCount = labels ? labels.length : 0;
                if (this && this.options && this.options.mode === 'dataset') {
                    return item.dataset.label || '';
                } else if (item.label) {
                    return item.label;
                } else if (labelCount > 0 && item.dataIndex < labelCount) {
                    return labels[item.dataIndex];
                }
            }
            return '';
        },
        afterTitle: noop,
        beforeBody: noop,
        beforeLabel: noop,
        label (tooltipItem) {
            if (this && this.options && this.options.mode === 'dataset') {
                return tooltipItem.label + ': ' + tooltipItem.formattedValue || tooltipItem.formattedValue;
            }
            let label = tooltipItem.dataset.label || '';
            if (label) {
                label += ': ';
            }
            const value = tooltipItem.formattedValue;
            if (!isNullOrUndef(value)) {
                label += value;
            }
            return label;
        },
        labelColor (tooltipItem) {
            const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
            const options = meta.controller.getStyle(tooltipItem.dataIndex);
            return {
                borderColor: options.borderColor,
                backgroundColor: options.backgroundColor,
                borderWidth: options.borderWidth,
                borderDash: options.borderDash,
                borderDashOffset: options.borderDashOffset,
                borderRadius: 0
            };
        },
        labelTextColor () {
            return this.options.bodyColor;
        },
        labelPointStyle (tooltipItem) {
            const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
            const options = meta.controller.getStyle(tooltipItem.dataIndex);
            return {
                pointStyle: options.pointStyle,
                rotation: options.rotation
            };
        },
        afterLabel: noop,
        afterBody: noop,
        beforeFooter: noop,
        footer: noop,
        afterFooter: noop
    };
     function invokeCallbackWithFallback(callbacks, name, ctx, arg) {
        const result = callbacks[name].call(ctx, arg);
        if (typeof result === 'undefined') {
            return defaultCallbacks[name].call(ctx, arg);
        }
        return result;
    }
    class Tooltip extends Element$1 {
     static positioners = positioners;
        constructor(config){
            super();
            this.opacity = 0;
            this._active = [];
            this._eventPosition = undefined;
            this._size = undefined;
            this._cachedAnimations = undefined;
            this._tooltipItems = [];
            this.$animations = undefined;
            this.$context = undefined;
            this.chart = config.chart;
            this.options = config.options;
            this.dataPoints = undefined;
            this.title = undefined;
            this.beforeBody = undefined;
            this.body = undefined;
            this.afterBody = undefined;
            this.footer = undefined;
            this.xAlign = undefined;
            this.yAlign = undefined;
            this.x = undefined;
            this.y = undefined;
            this.height = undefined;
            this.width = undefined;
            this.caretX = undefined;
            this.caretY = undefined;
            this.labelColors = undefined;
            this.labelPointStyles = undefined;
            this.labelTextColors = undefined;
        }
        initialize(options) {
            this.options = options;
            this._cachedAnimations = undefined;
            this.$context = undefined;
        }
     _resolveAnimations() {
            const cached = this._cachedAnimations;
            if (cached) {
                return cached;
            }
            const chart = this.chart;
            const options = this.options.setContext(this.getContext());
            const opts = options.enabled && chart.options.animation && options.animations;
            const animations = new Animations(this.chart, opts);
            if (opts._cacheable) {
                this._cachedAnimations = Object.freeze(animations);
            }
            return animations;
        }
     getContext() {
            return this.$context || (this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));
        }
        getTitle(context, options) {
            const { callbacks  } = options;
            const beforeTitle = invokeCallbackWithFallback(callbacks, 'beforeTitle', this, context);
            const title = invokeCallbackWithFallback(callbacks, 'title', this, context);
            const afterTitle = invokeCallbackWithFallback(callbacks, 'afterTitle', this, context);
            let lines = [];
            lines = pushOrConcat(lines, splitNewlines(beforeTitle));
            lines = pushOrConcat(lines, splitNewlines(title));
            lines = pushOrConcat(lines, splitNewlines(afterTitle));
            return lines;
        }
        getBeforeBody(tooltipItems, options) {
            return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, 'beforeBody', this, tooltipItems));
        }
        getBody(tooltipItems, options) {
            const { callbacks  } = options;
            const bodyItems = [];
            each(tooltipItems, (context)=>{
                const bodyItem = {
                    before: [],
                    lines: [],
                    after: []
                };
                const scoped = overrideCallbacks(callbacks, context);
                pushOrConcat(bodyItem.before, splitNewlines(invokeCallbackWithFallback(scoped, 'beforeLabel', this, context)));
                pushOrConcat(bodyItem.lines, invokeCallbackWithFallback(scoped, 'label', this, context));
                pushOrConcat(bodyItem.after, splitNewlines(invokeCallbackWithFallback(scoped, 'afterLabel', this, context)));
                bodyItems.push(bodyItem);
            });
            return bodyItems;
        }
        getAfterBody(tooltipItems, options) {
            return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, 'afterBody', this, tooltipItems));
        }
        getFooter(tooltipItems, options) {
            const { callbacks  } = options;
            const beforeFooter = invokeCallbackWithFallback(callbacks, 'beforeFooter', this, tooltipItems);
            const footer = invokeCallbackWithFallback(callbacks, 'footer', this, tooltipItems);
            const afterFooter = invokeCallbackWithFallback(callbacks, 'afterFooter', this, tooltipItems);
            let lines = [];
            lines = pushOrConcat(lines, splitNewlines(beforeFooter));
            lines = pushOrConcat(lines, splitNewlines(footer));
            lines = pushOrConcat(lines, splitNewlines(afterFooter));
            return lines;
        }
     _createItems(options) {
            const active = this._active;
            const data = this.chart.data;
            const labelColors = [];
            const labelPointStyles = [];
            const labelTextColors = [];
            let tooltipItems = [];
            let i, len;
            for(i = 0, len = active.length; i < len; ++i){
                tooltipItems.push(createTooltipItem(this.chart, active[i]));
            }
            if (options.filter) {
                tooltipItems = tooltipItems.filter((element, index, array)=>options.filter(element, index, array, data));
            }
            if (options.itemSort) {
                tooltipItems = tooltipItems.sort((a, b)=>options.itemSort(a, b, data));
            }
            each(tooltipItems, (context)=>{
                const scoped = overrideCallbacks(options.callbacks, context);
                labelColors.push(invokeCallbackWithFallback(scoped, 'labelColor', this, context));
                labelPointStyles.push(invokeCallbackWithFallback(scoped, 'labelPointStyle', this, context));
                labelTextColors.push(invokeCallbackWithFallback(scoped, 'labelTextColor', this, context));
            });
            this.labelColors = labelColors;
            this.labelPointStyles = labelPointStyles;
            this.labelTextColors = labelTextColors;
            this.dataPoints = tooltipItems;
            return tooltipItems;
        }
        update(changed, replay) {
            const options = this.options.setContext(this.getContext());
            const active = this._active;
            let properties;
            let tooltipItems = [];
            if (!active.length) {
                if (this.opacity !== 0) {
                    properties = {
                        opacity: 0
                    };
                }
            } else {
                const position = positioners[options.position].call(this, active, this._eventPosition);
                tooltipItems = this._createItems(options);
                this.title = this.getTitle(tooltipItems, options);
                this.beforeBody = this.getBeforeBody(tooltipItems, options);
                this.body = this.getBody(tooltipItems, options);
                this.afterBody = this.getAfterBody(tooltipItems, options);
                this.footer = this.getFooter(tooltipItems, options);
                const size = this._size = getTooltipSize(this, options);
                const positionAndSize = Object.assign({}, position, size);
                const alignment = determineAlignment(this.chart, options, positionAndSize);
                const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);
                this.xAlign = alignment.xAlign;
                this.yAlign = alignment.yAlign;
                properties = {
                    opacity: 1,
                    x: backgroundPoint.x,
                    y: backgroundPoint.y,
                    width: size.width,
                    height: size.height,
                    caretX: position.x,
                    caretY: position.y
                };
            }
            this._tooltipItems = tooltipItems;
            this.$context = undefined;
            if (properties) {
                this._resolveAnimations().update(this, properties);
            }
            if (changed && options.external) {
                options.external.call(this, {
                    chart: this.chart,
                    tooltip: this,
                    replay
                });
            }
        }
        drawCaret(tooltipPoint, ctx, size, options) {
            const caretPosition = this.getCaretPosition(tooltipPoint, size, options);
            ctx.lineTo(caretPosition.x1, caretPosition.y1);
            ctx.lineTo(caretPosition.x2, caretPosition.y2);
            ctx.lineTo(caretPosition.x3, caretPosition.y3);
        }
        getCaretPosition(tooltipPoint, size, options) {
            const { xAlign , yAlign  } = this;
            const { caretSize , cornerRadius  } = options;
            const { topLeft , topRight , bottomLeft , bottomRight  } = toTRBLCorners(cornerRadius);
            const { x: ptX , y: ptY  } = tooltipPoint;
            const { width , height  } = size;
            let x1, x2, x3, y1, y2, y3;
            if (yAlign === 'center') {
                y2 = ptY + height / 2;
                if (xAlign === 'left') {
                    x1 = ptX;
                    x2 = x1 - caretSize;
                    y1 = y2 + caretSize;
                    y3 = y2 - caretSize;
                } else {
                    x1 = ptX + width;
                    x2 = x1 + caretSize;
                    y1 = y2 - caretSize;
                    y3 = y2 + caretSize;
                }
                x3 = x1;
            } else {
                if (xAlign === 'left') {
                    x2 = ptX + Math.max(topLeft, bottomLeft) + caretSize;
                } else if (xAlign === 'right') {
                    x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;
                } else {
                    x2 = this.caretX;
                }
                if (yAlign === 'top') {
                    y1 = ptY;
                    y2 = y1 - caretSize;
                    x1 = x2 - caretSize;
                    x3 = x2 + caretSize;
                } else {
                    y1 = ptY + height;
                    y2 = y1 + caretSize;
                    x1 = x2 + caretSize;
                    x3 = x2 - caretSize;
                }
                y3 = y1;
            }
            return {
                x1,
                x2,
                x3,
                y1,
                y2,
                y3
            };
        }
        drawTitle(pt, ctx, options) {
            const title = this.title;
            const length = title.length;
            let titleFont, titleSpacing, i;
            if (length) {
                const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
                pt.x = getAlignedX(this, options.titleAlign, options);
                ctx.textAlign = rtlHelper.textAlign(options.titleAlign);
                ctx.textBaseline = 'middle';
                titleFont = toFont(options.titleFont);
                titleSpacing = options.titleSpacing;
                ctx.fillStyle = options.titleColor;
                ctx.font = titleFont.string;
                for(i = 0; i < length; ++i){
                    ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);
                    pt.y += titleFont.lineHeight + titleSpacing;
                    if (i + 1 === length) {
                        pt.y += options.titleMarginBottom - titleSpacing;
                    }
                }
            }
        }
     _drawColorBox(ctx, pt, i, rtlHelper, options) {
            const labelColor = this.labelColors[i];
            const labelPointStyle = this.labelPointStyles[i];
            const { boxHeight , boxWidth  } = options;
            const bodyFont = toFont(options.bodyFont);
            const colorX = getAlignedX(this, 'left', options);
            const rtlColorX = rtlHelper.x(colorX);
            const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;
            const colorY = pt.y + yOffSet;
            if (options.usePointStyle) {
                const drawOptions = {
                    radius: Math.min(boxWidth, boxHeight) / 2,
                    pointStyle: labelPointStyle.pointStyle,
                    rotation: labelPointStyle.rotation,
                    borderWidth: 1
                };
                const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;
                const centerY = colorY + boxHeight / 2;
                ctx.strokeStyle = options.multiKeyBackground;
                ctx.fillStyle = options.multiKeyBackground;
                drawPoint(ctx, drawOptions, centerX, centerY);
                ctx.strokeStyle = labelColor.borderColor;
                ctx.fillStyle = labelColor.backgroundColor;
                drawPoint(ctx, drawOptions, centerX, centerY);
            } else {
                ctx.lineWidth = isObject$1(labelColor.borderWidth) ? Math.max(...Object.values(labelColor.borderWidth)) : labelColor.borderWidth || 1;
                ctx.strokeStyle = labelColor.borderColor;
                ctx.setLineDash(labelColor.borderDash || []);
                ctx.lineDashOffset = labelColor.borderDashOffset || 0;
                const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth);
                const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - 2);
                const borderRadius = toTRBLCorners(labelColor.borderRadius);
                if (Object.values(borderRadius).some((v)=>v !== 0)) {
                    ctx.beginPath();
                    ctx.fillStyle = options.multiKeyBackground;
                    addRoundedRectPath(ctx, {
                        x: outerX,
                        y: colorY,
                        w: boxWidth,
                        h: boxHeight,
                        radius: borderRadius
                    });
                    ctx.fill();
                    ctx.stroke();
                    ctx.fillStyle = labelColor.backgroundColor;
                    ctx.beginPath();
                    addRoundedRectPath(ctx, {
                        x: innerX,
                        y: colorY + 1,
                        w: boxWidth - 2,
                        h: boxHeight - 2,
                        radius: borderRadius
                    });
                    ctx.fill();
                } else {
                    ctx.fillStyle = options.multiKeyBackground;
                    ctx.fillRect(outerX, colorY, boxWidth, boxHeight);
                    ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);
                    ctx.fillStyle = labelColor.backgroundColor;
                    ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);
                }
            }
            ctx.fillStyle = this.labelTextColors[i];
        }
        drawBody(pt, ctx, options) {
            const { body  } = this;
            const { bodySpacing , bodyAlign , displayColors , boxHeight , boxWidth , boxPadding  } = options;
            const bodyFont = toFont(options.bodyFont);
            let bodyLineHeight = bodyFont.lineHeight;
            let xLinePadding = 0;
            const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
            const fillLineOfText = function(line) {
                ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);
                pt.y += bodyLineHeight + bodySpacing;
            };
            const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
            let bodyItem, textColor, lines, i, j, ilen, jlen;
            ctx.textAlign = bodyAlign;
            ctx.textBaseline = 'middle';
            ctx.font = bodyFont.string;
            pt.x = getAlignedX(this, bodyAlignForCalculation, options);
            ctx.fillStyle = options.bodyColor;
            each(this.beforeBody, fillLineOfText);
            xLinePadding = displayColors && bodyAlignForCalculation !== 'right' ? bodyAlign === 'center' ? boxWidth / 2 + boxPadding : boxWidth + 2 + boxPadding : 0;
            for(i = 0, ilen = body.length; i < ilen; ++i){
                bodyItem = body[i];
                textColor = this.labelTextColors[i];
                ctx.fillStyle = textColor;
                each(bodyItem.before, fillLineOfText);
                lines = bodyItem.lines;
                if (displayColors && lines.length) {
                    this._drawColorBox(ctx, pt, i, rtlHelper, options);
                    bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);
                }
                for(j = 0, jlen = lines.length; j < jlen; ++j){
                    fillLineOfText(lines[j]);
                    bodyLineHeight = bodyFont.lineHeight;
                }
                each(bodyItem.after, fillLineOfText);
            }
            xLinePadding = 0;
            bodyLineHeight = bodyFont.lineHeight;
            each(this.afterBody, fillLineOfText);
            pt.y -= bodySpacing;
        }
        drawFooter(pt, ctx, options) {
            const footer = this.footer;
            const length = footer.length;
            let footerFont, i;
            if (length) {
                const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
                pt.x = getAlignedX(this, options.footerAlign, options);
                pt.y += options.footerMarginTop;
                ctx.textAlign = rtlHelper.textAlign(options.footerAlign);
                ctx.textBaseline = 'middle';
                footerFont = toFont(options.footerFont);
                ctx.fillStyle = options.footerColor;
                ctx.font = footerFont.string;
                for(i = 0; i < length; ++i){
                    ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);
                    pt.y += footerFont.lineHeight + options.footerSpacing;
                }
            }
        }
        drawBackground(pt, ctx, tooltipSize, options) {
            const { xAlign , yAlign  } = this;
            const { x , y  } = pt;
            const { width , height  } = tooltipSize;
            const { topLeft , topRight , bottomLeft , bottomRight  } = toTRBLCorners(options.cornerRadius);
            ctx.fillStyle = options.backgroundColor;
            ctx.strokeStyle = options.borderColor;
            ctx.lineWidth = options.borderWidth;
            ctx.beginPath();
            ctx.moveTo(x + topLeft, y);
            if (yAlign === 'top') {
                this.drawCaret(pt, ctx, tooltipSize, options);
            }
            ctx.lineTo(x + width - topRight, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);
            if (yAlign === 'center' && xAlign === 'right') {
                this.drawCaret(pt, ctx, tooltipSize, options);
            }
            ctx.lineTo(x + width, y + height - bottomRight);
            ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);
            if (yAlign === 'bottom') {
                this.drawCaret(pt, ctx, tooltipSize, options);
            }
            ctx.lineTo(x + bottomLeft, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);
            if (yAlign === 'center' && xAlign === 'left') {
                this.drawCaret(pt, ctx, tooltipSize, options);
            }
            ctx.lineTo(x, y + topLeft);
            ctx.quadraticCurveTo(x, y, x + topLeft, y);
            ctx.closePath();
            ctx.fill();
            if (options.borderWidth > 0) {
                ctx.stroke();
            }
        }
     _updateAnimationTarget(options) {
            const chart = this.chart;
            const anims = this.$animations;
            const animX = anims && anims.x;
            const animY = anims && anims.y;
            if (animX || animY) {
                const position = positioners[options.position].call(this, this._active, this._eventPosition);
                if (!position) {
                    return;
                }
                const size = this._size = getTooltipSize(this, options);
                const positionAndSize = Object.assign({}, position, this._size);
                const alignment = determineAlignment(chart, options, positionAndSize);
                const point = getBackgroundPoint(options, positionAndSize, alignment, chart);
                if (animX._to !== point.x || animY._to !== point.y) {
                    this.xAlign = alignment.xAlign;
                    this.yAlign = alignment.yAlign;
                    this.width = size.width;
                    this.height = size.height;
                    this.caretX = position.x;
                    this.caretY = position.y;
                    this._resolveAnimations().update(this, point);
                }
            }
        }
     _willRender() {
            return !!this.opacity;
        }
        draw(ctx) {
            const options = this.options.setContext(this.getContext());
            let opacity = this.opacity;
            if (!opacity) {
                return;
            }
            this._updateAnimationTarget(options);
            const tooltipSize = {
                width: this.width,
                height: this.height
            };
            const pt = {
                x: this.x,
                y: this.y
            };
            opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;
            const padding = toPadding(options.padding);
            const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
            if (options.enabled && hasTooltipContent) {
                ctx.save();
                ctx.globalAlpha = opacity;
                this.drawBackground(pt, ctx, tooltipSize, options);
                overrideTextDirection(ctx, options.textDirection);
                pt.y += padding.top;
                this.drawTitle(pt, ctx, options);
                this.drawBody(pt, ctx, options);
                this.drawFooter(pt, ctx, options);
                restoreTextDirection(ctx, options.textDirection);
                ctx.restore();
            }
        }
     getActiveElements() {
            return this._active || [];
        }
     setActiveElements(activeElements, eventPosition) {
            const lastActive = this._active;
            const active = activeElements.map(({ datasetIndex , index  })=>{
                const meta = this.chart.getDatasetMeta(datasetIndex);
                if (!meta) {
                    throw new Error('Cannot find a dataset at index ' + datasetIndex);
                }
                return {
                    datasetIndex,
                    element: meta.data[index],
                    index
                };
            });
            const changed = !_elementsEqual(lastActive, active);
            const positionChanged = this._positionChanged(active, eventPosition);
            if (changed || positionChanged) {
                this._active = active;
                this._eventPosition = eventPosition;
                this._ignoreReplayEvents = true;
                this.update(true);
            }
        }
     handleEvent(e, replay, inChartArea = true) {
            if (replay && this._ignoreReplayEvents) {
                return false;
            }
            this._ignoreReplayEvents = false;
            const options = this.options;
            const lastActive = this._active || [];
            const active = this._getActiveElements(e, lastActive, replay, inChartArea);
            const positionChanged = this._positionChanged(active, e);
            const changed = replay || !_elementsEqual(active, lastActive) || positionChanged;
            if (changed) {
                this._active = active;
                if (options.enabled || options.external) {
                    this._eventPosition = {
                        x: e.x,
                        y: e.y
                    };
                    this.update(true, replay);
                }
            }
            return changed;
        }
     _getActiveElements(e, lastActive, replay, inChartArea) {
            const options = this.options;
            if (e.type === 'mouseout') {
                return [];
            }
            if (!inChartArea) {
                return lastActive.filter((i)=>this.chart.data.datasets[i.datasetIndex] && this.chart.getDatasetMeta(i.datasetIndex).controller.getParsed(i.index) !== undefined);
            }
            const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);
            if (options.reverse) {
                active.reverse();
            }
            return active;
        }
     _positionChanged(active, e) {
            const { caretX , caretY , options  } = this;
            const position = positioners[options.position].call(this, active, e);
            return position !== false && (caretX !== position.x || caretY !== position.y);
        }
    }
    var plugin_tooltip = {
        id: 'tooltip',
        _element: Tooltip,
        positioners,
        afterInit (chart, _args, options) {
            if (options) {
                chart.tooltip = new Tooltip({
                    chart,
                    options
                });
            }
        },
        beforeUpdate (chart, _args, options) {
            if (chart.tooltip) {
                chart.tooltip.initialize(options);
            }
        },
        reset (chart, _args, options) {
            if (chart.tooltip) {
                chart.tooltip.initialize(options);
            }
        },
        afterDraw (chart) {
            const tooltip = chart.tooltip;
            if (tooltip && tooltip._willRender()) {
                const args = {
                    tooltip
                };
                if (chart.notifyPlugins('beforeTooltipDraw', {
                    ...args,
                    cancelable: true
                }) === false) {
                    return;
                }
                tooltip.draw(chart.ctx);
                chart.notifyPlugins('afterTooltipDraw', args);
            }
        },
        afterEvent (chart, args) {
            if (chart.tooltip) {
                const useFinalPosition = args.replay;
                if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {
                    args.changed = true;
                }
            }
        },
        defaults: {
            enabled: true,
            external: null,
            position: 'average',
            backgroundColor: 'rgba(0,0,0,0.8)',
            titleColor: '#fff',
            titleFont: {
                weight: 'bold'
            },
            titleSpacing: 2,
            titleMarginBottom: 6,
            titleAlign: 'left',
            bodyColor: '#fff',
            bodySpacing: 2,
            bodyFont: {},
            bodyAlign: 'left',
            footerColor: '#fff',
            footerSpacing: 2,
            footerMarginTop: 6,
            footerFont: {
                weight: 'bold'
            },
            footerAlign: 'left',
            padding: 6,
            caretPadding: 2,
            caretSize: 5,
            cornerRadius: 6,
            boxHeight: (ctx, opts)=>opts.bodyFont.size,
            boxWidth: (ctx, opts)=>opts.bodyFont.size,
            multiKeyBackground: '#fff',
            displayColors: true,
            boxPadding: 0,
            borderColor: 'rgba(0,0,0,0)',
            borderWidth: 0,
            animation: {
                duration: 400,
                easing: 'easeOutQuart'
            },
            animations: {
                numbers: {
                    type: 'number',
                    properties: [
                        'x',
                        'y',
                        'width',
                        'height',
                        'caretX',
                        'caretY'
                    ]
                },
                opacity: {
                    easing: 'linear',
                    duration: 200
                }
            },
            callbacks: defaultCallbacks
        },
        defaultRoutes: {
            bodyFont: 'font',
            footerFont: 'font',
            titleFont: 'font'
        },
        descriptors: {
            _scriptable: (name)=>name !== 'filter' && name !== 'itemSort' && name !== 'external',
            _indexable: false,
            callbacks: {
                _scriptable: false,
                _indexable: false
            },
            animation: {
                _fallback: false
            },
            animations: {
                _fallback: 'animation'
            }
        },
        additionalOptionScopes: [
            'interaction'
        ]
    };

    var plugins = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Colors: plugin_colors,
    Decimation: plugin_decimation,
    Filler: index,
    Legend: plugin_legend,
    SubTitle: plugin_subtitle,
    Title: plugin_title,
    Tooltip: plugin_tooltip
    });

    const addIfString = (labels, raw, index, addedLabels)=>{
        if (typeof raw === 'string') {
            index = labels.push(raw) - 1;
            addedLabels.unshift({
                index,
                label: raw
            });
        } else if (isNaN(raw)) {
            index = null;
        }
        return index;
    };
    function findOrAddLabel(labels, raw, index, addedLabels) {
        const first = labels.indexOf(raw);
        if (first === -1) {
            return addIfString(labels, raw, index, addedLabels);
        }
        const last = labels.lastIndexOf(raw);
        return first !== last ? index : first;
    }
    const validIndex = (index, max)=>index === null ? null : _limitValue(Math.round(index), 0, max);
    function _getLabelForValue(value) {
        const labels = this.getLabels();
        if (value >= 0 && value < labels.length) {
            return labels[value];
        }
        return value;
    }
    class CategoryScale extends Scale {
        static id = 'category';
     static defaults = {
            ticks: {
                callback: _getLabelForValue
            }
        };
        constructor(cfg){
            super(cfg);
             this._startValue = undefined;
            this._valueRange = 0;
            this._addedLabels = [];
        }
        init(scaleOptions) {
            const added = this._addedLabels;
            if (added.length) {
                const labels = this.getLabels();
                for (const { index , label  } of added){
                    if (labels[index] === label) {
                        labels.splice(index, 1);
                    }
                }
                this._addedLabels = [];
            }
            super.init(scaleOptions);
        }
        parse(raw, index) {
            if (isNullOrUndef(raw)) {
                return null;
            }
            const labels = this.getLabels();
            index = isFinite(index) && labels[index] === raw ? index : findOrAddLabel(labels, raw, valueOrDefault(index, raw), this._addedLabels);
            return validIndex(index, labels.length - 1);
        }
        determineDataLimits() {
            const { minDefined , maxDefined  } = this.getUserBounds();
            let { min , max  } = this.getMinMax(true);
            if (this.options.bounds === 'ticks') {
                if (!minDefined) {
                    min = 0;
                }
                if (!maxDefined) {
                    max = this.getLabels().length - 1;
                }
            }
            this.min = min;
            this.max = max;
        }
        buildTicks() {
            const min = this.min;
            const max = this.max;
            const offset = this.options.offset;
            const ticks = [];
            let labels = this.getLabels();
            labels = min === 0 && max === labels.length - 1 ? labels : labels.slice(min, max + 1);
            this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);
            this._startValue = this.min - (offset ? 0.5 : 0);
            for(let value = min; value <= max; value++){
                ticks.push({
                    value
                });
            }
            return ticks;
        }
        getLabelForValue(value) {
            return _getLabelForValue.call(this, value);
        }
     configure() {
            super.configure();
            if (!this.isHorizontal()) {
                this._reversePixels = !this._reversePixels;
            }
        }
        getPixelForValue(value) {
            if (typeof value !== 'number') {
                value = this.parse(value);
            }
            return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
        }
        getPixelForTick(index) {
            const ticks = this.ticks;
            if (index < 0 || index > ticks.length - 1) {
                return null;
            }
            return this.getPixelForValue(ticks[index].value);
        }
        getValueForPixel(pixel) {
            return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);
        }
        getBasePixel() {
            return this.bottom;
        }
    }

    function generateTicks$1(generationOptions, dataRange) {
        const ticks = [];
        const MIN_SPACING = 1e-14;
        const { bounds , step , min , max , precision , count , maxTicks , maxDigits , includeBounds  } = generationOptions;
        const unit = step || 1;
        const maxSpaces = maxTicks - 1;
        const { min: rmin , max: rmax  } = dataRange;
        const minDefined = !isNullOrUndef(min);
        const maxDefined = !isNullOrUndef(max);
        const countDefined = !isNullOrUndef(count);
        const minSpacing = (rmax - rmin) / (maxDigits + 1);
        let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;
        let factor, niceMin, niceMax, numSpaces;
        if (spacing < MIN_SPACING && !minDefined && !maxDefined) {
            return [
                {
                    value: rmin
                },
                {
                    value: rmax
                }
            ];
        }
        numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
        if (numSpaces > maxSpaces) {
            spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;
        }
        if (!isNullOrUndef(precision)) {
            factor = Math.pow(10, precision);
            spacing = Math.ceil(spacing * factor) / factor;
        }
        if (bounds === 'ticks') {
            niceMin = Math.floor(rmin / spacing) * spacing;
            niceMax = Math.ceil(rmax / spacing) * spacing;
        } else {
            niceMin = rmin;
            niceMax = rmax;
        }
        if (minDefined && maxDefined && step && almostWhole((max - min) / step, spacing / 1000)) {
            numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));
            spacing = (max - min) / numSpaces;
            niceMin = min;
            niceMax = max;
        } else if (countDefined) {
            niceMin = minDefined ? min : niceMin;
            niceMax = maxDefined ? max : niceMax;
            numSpaces = count - 1;
            spacing = (niceMax - niceMin) / numSpaces;
        } else {
            numSpaces = (niceMax - niceMin) / spacing;
            if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {
                numSpaces = Math.round(numSpaces);
            } else {
                numSpaces = Math.ceil(numSpaces);
            }
        }
        const decimalPlaces = Math.max(_decimalPlaces(spacing), _decimalPlaces(niceMin));
        factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);
        niceMin = Math.round(niceMin * factor) / factor;
        niceMax = Math.round(niceMax * factor) / factor;
        let j = 0;
        if (minDefined) {
            if (includeBounds && niceMin !== min) {
                ticks.push({
                    value: min
                });
                if (niceMin < min) {
                    j++;
                }
                if (almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {
                    j++;
                }
            } else if (niceMin < min) {
                j++;
            }
        }
        for(; j < numSpaces; ++j){
            const tickValue = Math.round((niceMin + j * spacing) * factor) / factor;
            if (maxDefined && tickValue > max) {
                break;
            }
            ticks.push({
                value: tickValue
            });
        }
        if (maxDefined && includeBounds && niceMax !== max) {
            if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {
                ticks[ticks.length - 1].value = max;
            } else {
                ticks.push({
                    value: max
                });
            }
        } else if (!maxDefined || niceMax === max) {
            ticks.push({
                value: niceMax
            });
        }
        return ticks;
    }
    function relativeLabelSize(value, minSpacing, { horizontal , minRotation  }) {
        const rad = toRadians(minRotation);
        const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 0.001;
        const length = 0.75 * minSpacing * ('' + value).length;
        return Math.min(minSpacing / ratio, length);
    }
    class LinearScaleBase extends Scale {
        constructor(cfg){
            super(cfg);
             this.start = undefined;
             this.end = undefined;
             this._startValue = undefined;
             this._endValue = undefined;
            this._valueRange = 0;
        }
        parse(raw, index) {
            if (isNullOrUndef(raw)) {
                return null;
            }
            if ((typeof raw === 'number' || raw instanceof Number) && !isFinite(+raw)) {
                return null;
            }
            return +raw;
        }
        handleTickRangeOptions() {
            const { beginAtZero  } = this.options;
            const { minDefined , maxDefined  } = this.getUserBounds();
            let { min , max  } = this;
            const setMin = (v)=>min = minDefined ? min : v;
            const setMax = (v)=>max = maxDefined ? max : v;
            if (beginAtZero) {
                const minSign = sign(min);
                const maxSign = sign(max);
                if (minSign < 0 && maxSign < 0) {
                    setMax(0);
                } else if (minSign > 0 && maxSign > 0) {
                    setMin(0);
                }
            }
            if (min === max) {
                let offset = max === 0 ? 1 : Math.abs(max * 0.05);
                setMax(max + offset);
                if (!beginAtZero) {
                    setMin(min - offset);
                }
            }
            this.min = min;
            this.max = max;
        }
        getTickLimit() {
            const tickOpts = this.options.ticks;
            let { maxTicksLimit , stepSize  } = tickOpts;
            let maxTicks;
            if (stepSize) {
                maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;
                if (maxTicks > 1000) {
                    console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);
                    maxTicks = 1000;
                }
            } else {
                maxTicks = this.computeTickLimit();
                maxTicksLimit = maxTicksLimit || 11;
            }
            if (maxTicksLimit) {
                maxTicks = Math.min(maxTicksLimit, maxTicks);
            }
            return maxTicks;
        }
     computeTickLimit() {
            return Number.POSITIVE_INFINITY;
        }
        buildTicks() {
            const opts = this.options;
            const tickOpts = opts.ticks;
            let maxTicks = this.getTickLimit();
            maxTicks = Math.max(2, maxTicks);
            const numericGeneratorOptions = {
                maxTicks,
                bounds: opts.bounds,
                min: opts.min,
                max: opts.max,
                precision: tickOpts.precision,
                step: tickOpts.stepSize,
                count: tickOpts.count,
                maxDigits: this._maxDigits(),
                horizontal: this.isHorizontal(),
                minRotation: tickOpts.minRotation || 0,
                includeBounds: tickOpts.includeBounds !== false
            };
            const dataRange = this._range || this;
            const ticks = generateTicks$1(numericGeneratorOptions, dataRange);
            if (opts.bounds === 'ticks') {
                _setMinAndMaxByKey(ticks, this, 'value');
            }
            if (opts.reverse) {
                ticks.reverse();
                this.start = this.max;
                this.end = this.min;
            } else {
                this.start = this.min;
                this.end = this.max;
            }
            return ticks;
        }
     configure() {
            const ticks = this.ticks;
            let start = this.min;
            let end = this.max;
            super.configure();
            if (this.options.offset && ticks.length) {
                const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;
                start -= offset;
                end += offset;
            }
            this._startValue = start;
            this._endValue = end;
            this._valueRange = end - start;
        }
        getLabelForValue(value) {
            return formatNumber(value, this.chart.options.locale, this.options.ticks.format);
        }
    }

    class LinearScale extends LinearScaleBase {
        static id = 'linear';
     static defaults = {
            ticks: {
                callback: Ticks.formatters.numeric
            }
        };
        determineDataLimits() {
            const { min , max  } = this.getMinMax(true);
            this.min = isNumberFinite(min) ? min : 0;
            this.max = isNumberFinite(max) ? max : 1;
            this.handleTickRangeOptions();
        }
     computeTickLimit() {
            const horizontal = this.isHorizontal();
            const length = horizontal ? this.width : this.height;
            const minRotation = toRadians(this.options.ticks.minRotation);
            const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 0.001;
            const tickFont = this._resolveTickFontOptions(0);
            return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));
        }
        getPixelForValue(value) {
            return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
        }
        getValueForPixel(pixel) {
            return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
        }
    }

    const log10Floor = (v)=>Math.floor(log10(v));
    const changeExponent = (v, m)=>Math.pow(10, log10Floor(v) + m);
    function isMajor(tickVal) {
        const remain = tickVal / Math.pow(10, log10Floor(tickVal));
        return remain === 1;
    }
    function steps(min, max, rangeExp) {
        const rangeStep = Math.pow(10, rangeExp);
        const start = Math.floor(min / rangeStep);
        const end = Math.ceil(max / rangeStep);
        return end - start;
    }
    function startExp(min, max) {
        const range = max - min;
        let rangeExp = log10Floor(range);
        while(steps(min, max, rangeExp) > 10){
            rangeExp++;
        }
        while(steps(min, max, rangeExp) < 10){
            rangeExp--;
        }
        return Math.min(rangeExp, log10Floor(min));
    }
     function generateTicks(generationOptions, { min , max  }) {
        min = finiteOrDefault(generationOptions.min, min);
        const ticks = [];
        const minExp = log10Floor(min);
        let exp = startExp(min, max);
        let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
        const stepSize = Math.pow(10, exp);
        const base = minExp > exp ? Math.pow(10, minExp) : 0;
        const start = Math.round((min - base) * precision) / precision;
        const offset = Math.floor((min - base) / stepSize / 10) * stepSize * 10;
        let significand = Math.floor((start - offset) / Math.pow(10, exp));
        let value = finiteOrDefault(generationOptions.min, Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision);
        while(value < max){
            ticks.push({
                value,
                major: isMajor(value),
                significand
            });
            if (significand >= 10) {
                significand = significand < 15 ? 15 : 20;
            } else {
                significand++;
            }
            if (significand >= 20) {
                exp++;
                significand = 2;
                precision = exp >= 0 ? 1 : precision;
            }
            value = Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision;
        }
        const lastTick = finiteOrDefault(generationOptions.max, value);
        ticks.push({
            value: lastTick,
            major: isMajor(lastTick),
            significand
        });
        return ticks;
    }
    class LogarithmicScale extends Scale {
        static id = 'logarithmic';
     static defaults = {
            ticks: {
                callback: Ticks.formatters.logarithmic,
                major: {
                    enabled: true
                }
            }
        };
        constructor(cfg){
            super(cfg);
             this.start = undefined;
             this.end = undefined;
             this._startValue = undefined;
            this._valueRange = 0;
        }
        parse(raw, index) {
            const value = LinearScaleBase.prototype.parse.apply(this, [
                raw,
                index
            ]);
            if (value === 0) {
                this._zero = true;
                return undefined;
            }
            return isNumberFinite(value) && value > 0 ? value : null;
        }
        determineDataLimits() {
            const { min , max  } = this.getMinMax(true);
            this.min = isNumberFinite(min) ? Math.max(0, min) : null;
            this.max = isNumberFinite(max) ? Math.max(0, max) : null;
            if (this.options.beginAtZero) {
                this._zero = true;
            }
            if (this._zero && this.min !== this._suggestedMin && !isNumberFinite(this._userMin)) {
                this.min = min === changeExponent(this.min, 0) ? changeExponent(this.min, -1) : changeExponent(this.min, 0);
            }
            this.handleTickRangeOptions();
        }
        handleTickRangeOptions() {
            const { minDefined , maxDefined  } = this.getUserBounds();
            let min = this.min;
            let max = this.max;
            const setMin = (v)=>min = minDefined ? min : v;
            const setMax = (v)=>max = maxDefined ? max : v;
            if (min === max) {
                if (min <= 0) {
                    setMin(1);
                    setMax(10);
                } else {
                    setMin(changeExponent(min, -1));
                    setMax(changeExponent(max, +1));
                }
            }
            if (min <= 0) {
                setMin(changeExponent(max, -1));
            }
            if (max <= 0) {
                setMax(changeExponent(min, +1));
            }
            this.min = min;
            this.max = max;
        }
        buildTicks() {
            const opts = this.options;
            const generationOptions = {
                min: this._userMin,
                max: this._userMax
            };
            const ticks = generateTicks(generationOptions, this);
            if (opts.bounds === 'ticks') {
                _setMinAndMaxByKey(ticks, this, 'value');
            }
            if (opts.reverse) {
                ticks.reverse();
                this.start = this.max;
                this.end = this.min;
            } else {
                this.start = this.min;
                this.end = this.max;
            }
            return ticks;
        }
     getLabelForValue(value) {
            return value === undefined ? '0' : formatNumber(value, this.chart.options.locale, this.options.ticks.format);
        }
     configure() {
            const start = this.min;
            super.configure();
            this._startValue = log10(start);
            this._valueRange = log10(this.max) - log10(start);
        }
        getPixelForValue(value) {
            if (value === undefined || value === 0) {
                value = this.min;
            }
            if (value === null || isNaN(value)) {
                return NaN;
            }
            return this.getPixelForDecimal(value === this.min ? 0 : (log10(value) - this._startValue) / this._valueRange);
        }
        getValueForPixel(pixel) {
            const decimal = this.getDecimalForPixel(pixel);
            return Math.pow(10, this._startValue + decimal * this._valueRange);
        }
    }

    function getTickBackdropHeight(opts) {
        const tickOpts = opts.ticks;
        if (tickOpts.display && opts.display) {
            const padding = toPadding(tickOpts.backdropPadding);
            return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults$1.font.size) + padding.height;
        }
        return 0;
    }
    function measureLabelSize(ctx, font, label) {
        label = isArray$1(label) ? label : [
            label
        ];
        return {
            w: _longestText(ctx, font.string, label),
            h: label.length * font.lineHeight
        };
    }
    function determineLimits(angle, pos, size, min, max) {
        if (angle === min || angle === max) {
            return {
                start: pos - size / 2,
                end: pos + size / 2
            };
        } else if (angle < min || angle > max) {
            return {
                start: pos - size,
                end: pos
            };
        }
        return {
            start: pos,
            end: pos + size
        };
    }
     function fitWithPointLabels(scale) {
        const orig = {
            l: scale.left + scale._padding.left,
            r: scale.right - scale._padding.right,
            t: scale.top + scale._padding.top,
            b: scale.bottom - scale._padding.bottom
        };
        const limits = Object.assign({}, orig);
        const labelSizes = [];
        const padding = [];
        const valueCount = scale._pointLabels.length;
        const pointLabelOpts = scale.options.pointLabels;
        const additionalAngle = pointLabelOpts.centerPointLabels ? PI / valueCount : 0;
        for(let i = 0; i < valueCount; i++){
            const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));
            padding[i] = opts.padding;
            const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);
            const plFont = toFont(opts.font);
            const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);
            labelSizes[i] = textSize;
            const angleRadians = _normalizeAngle(scale.getIndexAngle(i) + additionalAngle);
            const angle = Math.round(toDegrees(angleRadians));
            const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
            const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
            updateLimits(limits, orig, angleRadians, hLimits, vLimits);
        }
        scale.setCenterPoint(orig.l - limits.l, limits.r - orig.r, orig.t - limits.t, limits.b - orig.b);
        scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);
    }
    function updateLimits(limits, orig, angle, hLimits, vLimits) {
        const sin = Math.abs(Math.sin(angle));
        const cos = Math.abs(Math.cos(angle));
        let x = 0;
        let y = 0;
        if (hLimits.start < orig.l) {
            x = (orig.l - hLimits.start) / sin;
            limits.l = Math.min(limits.l, orig.l - x);
        } else if (hLimits.end > orig.r) {
            x = (hLimits.end - orig.r) / sin;
            limits.r = Math.max(limits.r, orig.r + x);
        }
        if (vLimits.start < orig.t) {
            y = (orig.t - vLimits.start) / cos;
            limits.t = Math.min(limits.t, orig.t - y);
        } else if (vLimits.end > orig.b) {
            y = (vLimits.end - orig.b) / cos;
            limits.b = Math.max(limits.b, orig.b + y);
        }
    }
    function createPointLabelItem(scale, index, itemOpts) {
        const outerDistance = scale.drawingArea;
        const { extra , additionalAngle , padding , size  } = itemOpts;
        const pointLabelPosition = scale.getPointPosition(index, outerDistance + extra + padding, additionalAngle);
        const angle = Math.round(toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI)));
        const y = yForAngle(pointLabelPosition.y, size.h, angle);
        const textAlign = getTextAlignForAngle(angle);
        const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);
        return {
            visible: true,
            x: pointLabelPosition.x,
            y,
            textAlign,
            left,
            top: y,
            right: left + size.w,
            bottom: y + size.h
        };
    }
    function isNotOverlapped(item, area) {
        if (!area) {
            return true;
        }
        const { left , top , right , bottom  } = item;
        const apexesInArea = _isPointInArea({
            x: left,
            y: top
        }, area) || _isPointInArea({
            x: left,
            y: bottom
        }, area) || _isPointInArea({
            x: right,
            y: top
        }, area) || _isPointInArea({
            x: right,
            y: bottom
        }, area);
        return !apexesInArea;
    }
    function buildPointLabelItems(scale, labelSizes, padding) {
        const items = [];
        const valueCount = scale._pointLabels.length;
        const opts = scale.options;
        const { centerPointLabels , display  } = opts.pointLabels;
        const itemOpts = {
            extra: getTickBackdropHeight(opts) / 2,
            additionalAngle: centerPointLabels ? PI / valueCount : 0
        };
        let area;
        for(let i = 0; i < valueCount; i++){
            itemOpts.padding = padding[i];
            itemOpts.size = labelSizes[i];
            const item = createPointLabelItem(scale, i, itemOpts);
            items.push(item);
            if (display === 'auto') {
                item.visible = isNotOverlapped(item, area);
                if (item.visible) {
                    area = item;
                }
            }
        }
        return items;
    }
    function getTextAlignForAngle(angle) {
        if (angle === 0 || angle === 180) {
            return 'center';
        } else if (angle < 180) {
            return 'left';
        }
        return 'right';
    }
    function leftForTextAlign(x, w, align) {
        if (align === 'right') {
            x -= w;
        } else if (align === 'center') {
            x -= w / 2;
        }
        return x;
    }
    function yForAngle(y, h, angle) {
        if (angle === 90 || angle === 270) {
            y -= h / 2;
        } else if (angle > 270 || angle < 90) {
            y -= h;
        }
        return y;
    }
    function drawPointLabelBox(ctx, opts, item) {
        const { left , top , right , bottom  } = item;
        const { backdropColor  } = opts;
        if (!isNullOrUndef(backdropColor)) {
            const borderRadius = toTRBLCorners(opts.borderRadius);
            const padding = toPadding(opts.backdropPadding);
            ctx.fillStyle = backdropColor;
            const backdropLeft = left - padding.left;
            const backdropTop = top - padding.top;
            const backdropWidth = right - left + padding.width;
            const backdropHeight = bottom - top + padding.height;
            if (Object.values(borderRadius).some((v)=>v !== 0)) {
                ctx.beginPath();
                addRoundedRectPath(ctx, {
                    x: backdropLeft,
                    y: backdropTop,
                    w: backdropWidth,
                    h: backdropHeight,
                    radius: borderRadius
                });
                ctx.fill();
            } else {
                ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);
            }
        }
    }
    function drawPointLabels(scale, labelCount) {
        const { ctx , options: { pointLabels  }  } = scale;
        for(let i = labelCount - 1; i >= 0; i--){
            const item = scale._pointLabelItems[i];
            if (!item.visible) {
                continue;
            }
            const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));
            drawPointLabelBox(ctx, optsAtIndex, item);
            const plFont = toFont(optsAtIndex.font);
            const { x , y , textAlign  } = item;
            renderText(ctx, scale._pointLabels[i], x, y + plFont.lineHeight / 2, plFont, {
                color: optsAtIndex.color,
                textAlign: textAlign,
                textBaseline: 'middle'
            });
        }
    }
    function pathRadiusLine(scale, radius, circular, labelCount) {
        const { ctx  } = scale;
        if (circular) {
            ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);
        } else {
            let pointPosition = scale.getPointPosition(0, radius);
            ctx.moveTo(pointPosition.x, pointPosition.y);
            for(let i = 1; i < labelCount; i++){
                pointPosition = scale.getPointPosition(i, radius);
                ctx.lineTo(pointPosition.x, pointPosition.y);
            }
        }
    }
    function drawRadiusLine(scale, gridLineOpts, radius, labelCount, borderOpts) {
        const ctx = scale.ctx;
        const circular = gridLineOpts.circular;
        const { color , lineWidth  } = gridLineOpts;
        if (!circular && !labelCount || !color || !lineWidth || radius < 0) {
            return;
        }
        ctx.save();
        ctx.strokeStyle = color;
        ctx.lineWidth = lineWidth;
        ctx.setLineDash(borderOpts.dash || []);
        ctx.lineDashOffset = borderOpts.dashOffset;
        ctx.beginPath();
        pathRadiusLine(scale, radius, circular, labelCount);
        ctx.closePath();
        ctx.stroke();
        ctx.restore();
    }
    function createPointLabelContext(parent, index, label) {
        return createContext(parent, {
            label,
            index,
            type: 'pointLabel'
        });
    }
    class RadialLinearScale extends LinearScaleBase {
        static id = 'radialLinear';
     static defaults = {
            display: true,
            animate: true,
            position: 'chartArea',
            angleLines: {
                display: true,
                lineWidth: 1,
                borderDash: [],
                borderDashOffset: 0.0
            },
            grid: {
                circular: false
            },
            startAngle: 0,
            ticks: {
                showLabelBackdrop: true,
                callback: Ticks.formatters.numeric
            },
            pointLabels: {
                backdropColor: undefined,
                backdropPadding: 2,
                display: true,
                font: {
                    size: 10
                },
                callback (label) {
                    return label;
                },
                padding: 5,
                centerPointLabels: false
            }
        };
        static defaultRoutes = {
            'angleLines.color': 'borderColor',
            'pointLabels.color': 'color',
            'ticks.color': 'color'
        };
        static descriptors = {
            angleLines: {
                _fallback: 'grid'
            }
        };
        constructor(cfg){
            super(cfg);
             this.xCenter = undefined;
             this.yCenter = undefined;
             this.drawingArea = undefined;
             this._pointLabels = [];
            this._pointLabelItems = [];
        }
        setDimensions() {
            const padding = this._padding = toPadding(getTickBackdropHeight(this.options) / 2);
            const w = this.width = this.maxWidth - padding.width;
            const h = this.height = this.maxHeight - padding.height;
            this.xCenter = Math.floor(this.left + w / 2 + padding.left);
            this.yCenter = Math.floor(this.top + h / 2 + padding.top);
            this.drawingArea = Math.floor(Math.min(w, h) / 2);
        }
        determineDataLimits() {
            const { min , max  } = this.getMinMax(false);
            this.min = isNumberFinite(min) && !isNaN(min) ? min : 0;
            this.max = isNumberFinite(max) && !isNaN(max) ? max : 0;
            this.handleTickRangeOptions();
        }
     computeTickLimit() {
            return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
        }
        generateTickLabels(ticks) {
            LinearScaleBase.prototype.generateTickLabels.call(this, ticks);
            this._pointLabels = this.getLabels().map((value, index)=>{
                const label = callback(this.options.pointLabels.callback, [
                    value,
                    index
                ], this);
                return label || label === 0 ? label : '';
            }).filter((v, i)=>this.chart.getDataVisibility(i));
        }
        fit() {
            const opts = this.options;
            if (opts.display && opts.pointLabels.display) {
                fitWithPointLabels(this);
            } else {
                this.setCenterPoint(0, 0, 0, 0);
            }
        }
        setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {
            this.xCenter += Math.floor((leftMovement - rightMovement) / 2);
            this.yCenter += Math.floor((topMovement - bottomMovement) / 2);
            this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));
        }
        getIndexAngle(index) {
            const angleMultiplier = TAU / (this._pointLabels.length || 1);
            const startAngle = this.options.startAngle || 0;
            return _normalizeAngle(index * angleMultiplier + toRadians(startAngle));
        }
        getDistanceFromCenterForValue(value) {
            if (isNullOrUndef(value)) {
                return NaN;
            }
            const scalingFactor = this.drawingArea / (this.max - this.min);
            if (this.options.reverse) {
                return (this.max - value) * scalingFactor;
            }
            return (value - this.min) * scalingFactor;
        }
        getValueForDistanceFromCenter(distance) {
            if (isNullOrUndef(distance)) {
                return NaN;
            }
            const scaledDistance = distance / (this.drawingArea / (this.max - this.min));
            return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;
        }
        getPointLabelContext(index) {
            const pointLabels = this._pointLabels || [];
            if (index >= 0 && index < pointLabels.length) {
                const pointLabel = pointLabels[index];
                return createPointLabelContext(this.getContext(), index, pointLabel);
            }
        }
        getPointPosition(index, distanceFromCenter, additionalAngle = 0) {
            const angle = this.getIndexAngle(index) - HALF_PI + additionalAngle;
            return {
                x: Math.cos(angle) * distanceFromCenter + this.xCenter,
                y: Math.sin(angle) * distanceFromCenter + this.yCenter,
                angle
            };
        }
        getPointPositionForValue(index, value) {
            return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));
        }
        getBasePosition(index) {
            return this.getPointPositionForValue(index || 0, this.getBaseValue());
        }
        getPointLabelPosition(index) {
            const { left , top , right , bottom  } = this._pointLabelItems[index];
            return {
                left,
                top,
                right,
                bottom
            };
        }
     drawBackground() {
            const { backgroundColor , grid: { circular  }  } = this.options;
            if (backgroundColor) {
                const ctx = this.ctx;
                ctx.save();
                ctx.beginPath();
                pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);
                ctx.closePath();
                ctx.fillStyle = backgroundColor;
                ctx.fill();
                ctx.restore();
            }
        }
     drawGrid() {
            const ctx = this.ctx;
            const opts = this.options;
            const { angleLines , grid , border  } = opts;
            const labelCount = this._pointLabels.length;
            let i, offset, position;
            if (opts.pointLabels.display) {
                drawPointLabels(this, labelCount);
            }
            if (grid.display) {
                this.ticks.forEach((tick, index)=>{
                    if (index !== 0 || index === 0 && this.min < 0) {
                        offset = this.getDistanceFromCenterForValue(tick.value);
                        const context = this.getContext(index);
                        const optsAtIndex = grid.setContext(context);
                        const optsAtIndexBorder = border.setContext(context);
                        drawRadiusLine(this, optsAtIndex, offset, labelCount, optsAtIndexBorder);
                    }
                });
            }
            if (angleLines.display) {
                ctx.save();
                for(i = labelCount - 1; i >= 0; i--){
                    const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));
                    const { color , lineWidth  } = optsAtIndex;
                    if (!lineWidth || !color) {
                        continue;
                    }
                    ctx.lineWidth = lineWidth;
                    ctx.strokeStyle = color;
                    ctx.setLineDash(optsAtIndex.borderDash);
                    ctx.lineDashOffset = optsAtIndex.borderDashOffset;
                    offset = this.getDistanceFromCenterForValue(opts.reverse ? this.min : this.max);
                    position = this.getPointPosition(i, offset);
                    ctx.beginPath();
                    ctx.moveTo(this.xCenter, this.yCenter);
                    ctx.lineTo(position.x, position.y);
                    ctx.stroke();
                }
                ctx.restore();
            }
        }
     drawBorder() {}
     drawLabels() {
            const ctx = this.ctx;
            const opts = this.options;
            const tickOpts = opts.ticks;
            if (!tickOpts.display) {
                return;
            }
            const startAngle = this.getIndexAngle(0);
            let offset, width;
            ctx.save();
            ctx.translate(this.xCenter, this.yCenter);
            ctx.rotate(startAngle);
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            this.ticks.forEach((tick, index)=>{
                if (index === 0 && this.min >= 0 && !opts.reverse) {
                    return;
                }
                const optsAtIndex = tickOpts.setContext(this.getContext(index));
                const tickFont = toFont(optsAtIndex.font);
                offset = this.getDistanceFromCenterForValue(this.ticks[index].value);
                if (optsAtIndex.showLabelBackdrop) {
                    ctx.font = tickFont.string;
                    width = ctx.measureText(tick.label).width;
                    ctx.fillStyle = optsAtIndex.backdropColor;
                    const padding = toPadding(optsAtIndex.backdropPadding);
                    ctx.fillRect(-width / 2 - padding.left, -offset - tickFont.size / 2 - padding.top, width + padding.width, tickFont.size + padding.height);
                }
                renderText(ctx, tick.label, 0, -offset, tickFont, {
                    color: optsAtIndex.color,
                    strokeColor: optsAtIndex.textStrokeColor,
                    strokeWidth: optsAtIndex.textStrokeWidth
                });
            });
            ctx.restore();
        }
     drawTitle() {}
    }

    const INTERVALS = {
        millisecond: {
            common: true,
            size: 1,
            steps: 1000
        },
        second: {
            common: true,
            size: 1000,
            steps: 60
        },
        minute: {
            common: true,
            size: 60000,
            steps: 60
        },
        hour: {
            common: true,
            size: 3600000,
            steps: 24
        },
        day: {
            common: true,
            size: 86400000,
            steps: 30
        },
        week: {
            common: false,
            size: 604800000,
            steps: 4
        },
        month: {
            common: true,
            size: 2.628e9,
            steps: 12
        },
        quarter: {
            common: false,
            size: 7.884e9,
            steps: 4
        },
        year: {
            common: true,
            size: 3.154e10
        }
    };
     const UNITS =  /* #__PURE__ */ Object.keys(INTERVALS);
     function sorter(a, b) {
        return a - b;
    }
     function parse(scale, input) {
        if (isNullOrUndef(input)) {
            return null;
        }
        const adapter = scale._adapter;
        const { parser , round , isoWeekday  } = scale._parseOpts;
        let value = input;
        if (typeof parser === 'function') {
            value = parser(value);
        }
        if (!isNumberFinite(value)) {
            value = typeof parser === 'string' ? adapter.parse(value,  parser) : adapter.parse(value);
        }
        if (value === null) {
            return null;
        }
        if (round) {
            value = round === 'week' && (isNumber(isoWeekday) || isoWeekday === true) ? adapter.startOf(value, 'isoWeek', isoWeekday) : adapter.startOf(value, round);
        }
        return +value;
    }
     function determineUnitForAutoTicks(minUnit, min, max, capacity) {
        const ilen = UNITS.length;
        for(let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i){
            const interval = INTERVALS[UNITS[i]];
            const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;
            if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
                return UNITS[i];
            }
        }
        return UNITS[ilen - 1];
    }
     function determineUnitForFormatting(scale, numTicks, minUnit, min, max) {
        for(let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--){
            const unit = UNITS[i];
            if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {
                return unit;
            }
        }
        return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
    }
     function determineMajorUnit(unit) {
        for(let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i){
            if (INTERVALS[UNITS[i]].common) {
                return UNITS[i];
            }
        }
    }
     function addTick(ticks, time, timestamps) {
        if (!timestamps) {
            ticks[time] = true;
        } else if (timestamps.length) {
            const { lo , hi  } = _lookup(timestamps, time);
            const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];
            ticks[timestamp] = true;
        }
    }
     function setMajorTicks(scale, ticks, map, majorUnit) {
        const adapter = scale._adapter;
        const first = +adapter.startOf(ticks[0].value, majorUnit);
        const last = ticks[ticks.length - 1].value;
        let major, index;
        for(major = first; major <= last; major = +adapter.add(major, 1, majorUnit)){
            index = map[major];
            if (index >= 0) {
                ticks[index].major = true;
            }
        }
        return ticks;
    }
     function ticksFromTimestamps(scale, values, majorUnit) {
        const ticks = [];
         const map = {};
        const ilen = values.length;
        let i, value;
        for(i = 0; i < ilen; ++i){
            value = values[i];
            map[value] = i;
            ticks.push({
                value,
                major: false
            });
        }
        return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale, ticks, map, majorUnit);
    }
    class TimeScale extends Scale {
        static id = 'time';
     static defaults = {
     bounds: 'data',
            adapters: {},
            time: {
                parser: false,
                unit: false,
                round: false,
                isoWeekday: false,
                minUnit: 'millisecond',
                displayFormats: {}
            },
            ticks: {
     source: 'auto',
                callback: false,
                major: {
                    enabled: false
                }
            }
        };
     constructor(props){
            super(props);
             this._cache = {
                data: [],
                labels: [],
                all: []
            };
             this._unit = 'day';
             this._majorUnit = undefined;
            this._offsets = {};
            this._normalized = false;
            this._parseOpts = undefined;
        }
        init(scaleOpts, opts = {}) {
            const time = scaleOpts.time || (scaleOpts.time = {});
             const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);
            adapter.init(opts);
            mergeIf(time.displayFormats, adapter.formats());
            this._parseOpts = {
                parser: time.parser,
                round: time.round,
                isoWeekday: time.isoWeekday
            };
            super.init(scaleOpts);
            this._normalized = opts.normalized;
        }
     parse(raw, index) {
            if (raw === undefined) {
                return null;
            }
            return parse(this, raw);
        }
        beforeLayout() {
            super.beforeLayout();
            this._cache = {
                data: [],
                labels: [],
                all: []
            };
        }
        determineDataLimits() {
            const options = this.options;
            const adapter = this._adapter;
            const unit = options.time.unit || 'day';
            let { min , max , minDefined , maxDefined  } = this.getUserBounds();
     function _applyBounds(bounds) {
                if (!minDefined && !isNaN(bounds.min)) {
                    min = Math.min(min, bounds.min);
                }
                if (!maxDefined && !isNaN(bounds.max)) {
                    max = Math.max(max, bounds.max);
                }
            }
            if (!minDefined || !maxDefined) {
                _applyBounds(this._getLabelBounds());
                if (options.bounds !== 'ticks' || options.ticks.source !== 'labels') {
                    _applyBounds(this.getMinMax(false));
                }
            }
            min = isNumberFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);
            max = isNumberFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;
            this.min = Math.min(min, max - 1);
            this.max = Math.max(min + 1, max);
        }
     _getLabelBounds() {
            const arr = this.getLabelTimestamps();
            let min = Number.POSITIVE_INFINITY;
            let max = Number.NEGATIVE_INFINITY;
            if (arr.length) {
                min = arr[0];
                max = arr[arr.length - 1];
            }
            return {
                min,
                max
            };
        }
     buildTicks() {
            const options = this.options;
            const timeOpts = options.time;
            const tickOpts = options.ticks;
            const timestamps = tickOpts.source === 'labels' ? this.getLabelTimestamps() : this._generate();
            if (options.bounds === 'ticks' && timestamps.length) {
                this.min = this._userMin || timestamps[0];
                this.max = this._userMax || timestamps[timestamps.length - 1];
            }
            const min = this.min;
            const max = this.max;
            const ticks = _filterBetween(timestamps, min, max);
            this._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min)) : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));
            this._majorUnit = !tickOpts.major.enabled || this._unit === 'year' ? undefined : determineMajorUnit(this._unit);
            this.initOffsets(timestamps);
            if (options.reverse) {
                ticks.reverse();
            }
            return ticksFromTimestamps(this, ticks, this._majorUnit);
        }
        afterAutoSkip() {
            if (this.options.offsetAfterAutoskip) {
                this.initOffsets(this.ticks.map((tick)=>+tick.value));
            }
        }
     initOffsets(timestamps = []) {
            let start = 0;
            let end = 0;
            let first, last;
            if (this.options.offset && timestamps.length) {
                first = this.getDecimalForValue(timestamps[0]);
                if (timestamps.length === 1) {
                    start = 1 - first;
                } else {
                    start = (this.getDecimalForValue(timestamps[1]) - first) / 2;
                }
                last = this.getDecimalForValue(timestamps[timestamps.length - 1]);
                if (timestamps.length === 1) {
                    end = last;
                } else {
                    end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;
                }
            }
            const limit = timestamps.length < 3 ? 0.5 : 0.25;
            start = _limitValue(start, 0, limit);
            end = _limitValue(end, 0, limit);
            this._offsets = {
                start,
                end,
                factor: 1 / (start + 1 + end)
            };
        }
     _generate() {
            const adapter = this._adapter;
            const min = this.min;
            const max = this.max;
            const options = this.options;
            const timeOpts = options.time;
            const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));
            const stepSize = valueOrDefault(options.ticks.stepSize, 1);
            const weekday = minor === 'week' ? timeOpts.isoWeekday : false;
            const hasWeekday = isNumber(weekday) || weekday === true;
            const ticks = {};
            let first = min;
            let time, count;
            if (hasWeekday) {
                first = +adapter.startOf(first, 'isoWeek', weekday);
            }
            first = +adapter.startOf(first, hasWeekday ? 'day' : minor);
            if (adapter.diff(max, min, minor) > 100000 * stepSize) {
                throw new Error(min + ' and ' + max + ' are too far apart with stepSize of ' + stepSize + ' ' + minor);
            }
            const timestamps = options.ticks.source === 'data' && this.getDataTimestamps();
            for(time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++){
                addTick(ticks, time, timestamps);
            }
            if (time === max || options.bounds === 'ticks' || count === 1) {
                addTick(ticks, time, timestamps);
            }
            return Object.keys(ticks).sort(sorter).map((x)=>+x);
        }
     getLabelForValue(value) {
            const adapter = this._adapter;
            const timeOpts = this.options.time;
            if (timeOpts.tooltipFormat) {
                return adapter.format(value, timeOpts.tooltipFormat);
            }
            return adapter.format(value, timeOpts.displayFormats.datetime);
        }
     format(value, format) {
            const options = this.options;
            const formats = options.time.displayFormats;
            const unit = this._unit;
            const fmt = format || formats[unit];
            return this._adapter.format(value, fmt);
        }
     _tickFormatFunction(time, index, ticks, format) {
            const options = this.options;
            const formatter = options.ticks.callback;
            if (formatter) {
                return callback(formatter, [
                    time,
                    index,
                    ticks
                ], this);
            }
            const formats = options.time.displayFormats;
            const unit = this._unit;
            const majorUnit = this._majorUnit;
            const minorFormat = unit && formats[unit];
            const majorFormat = majorUnit && formats[majorUnit];
            const tick = ticks[index];
            const major = majorUnit && majorFormat && tick && tick.major;
            return this._adapter.format(time, format || (major ? majorFormat : minorFormat));
        }
     generateTickLabels(ticks) {
            let i, ilen, tick;
            for(i = 0, ilen = ticks.length; i < ilen; ++i){
                tick = ticks[i];
                tick.label = this._tickFormatFunction(tick.value, i, ticks);
            }
        }
     getDecimalForValue(value) {
            return value === null ? NaN : (value - this.min) / (this.max - this.min);
        }
     getPixelForValue(value) {
            const offsets = this._offsets;
            const pos = this.getDecimalForValue(value);
            return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);
        }
     getValueForPixel(pixel) {
            const offsets = this._offsets;
            const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
            return this.min + pos * (this.max - this.min);
        }
     _getLabelSize(label) {
            const ticksOpts = this.options.ticks;
            const tickLabelWidth = this.ctx.measureText(label).width;
            const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
            const cosRotation = Math.cos(angle);
            const sinRotation = Math.sin(angle);
            const tickFontSize = this._resolveTickFontOptions(0).size;
            return {
                w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,
                h: tickLabelWidth * sinRotation + tickFontSize * cosRotation
            };
        }
     _getLabelCapacity(exampleTime) {
            const timeOpts = this.options.time;
            const displayFormats = timeOpts.displayFormats;
            const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;
            const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [
                exampleTime
            ], this._majorUnit), format);
            const size = this._getLabelSize(exampleLabel);
            const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;
            return capacity > 0 ? capacity : 1;
        }
     getDataTimestamps() {
            let timestamps = this._cache.data || [];
            let i, ilen;
            if (timestamps.length) {
                return timestamps;
            }
            const metas = this.getMatchingVisibleMetas();
            if (this._normalized && metas.length) {
                return this._cache.data = metas[0].controller.getAllParsedValues(this);
            }
            for(i = 0, ilen = metas.length; i < ilen; ++i){
                timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));
            }
            return this._cache.data = this.normalize(timestamps);
        }
     getLabelTimestamps() {
            const timestamps = this._cache.labels || [];
            let i, ilen;
            if (timestamps.length) {
                return timestamps;
            }
            const labels = this.getLabels();
            for(i = 0, ilen = labels.length; i < ilen; ++i){
                timestamps.push(parse(this, labels[i]));
            }
            return this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps);
        }
     normalize(values) {
            return _arrayUnique(values.sort(sorter));
        }
    }

    function interpolate(table, val, reverse) {
        let lo = 0;
        let hi = table.length - 1;
        let prevSource, nextSource, prevTarget, nextTarget;
        if (reverse) {
            if (val >= table[lo].pos && val <= table[hi].pos) {
                ({ lo , hi  } = _lookupByKey(table, 'pos', val));
            }
            ({ pos: prevSource , time: prevTarget  } = table[lo]);
            ({ pos: nextSource , time: nextTarget  } = table[hi]);
        } else {
            if (val >= table[lo].time && val <= table[hi].time) {
                ({ lo , hi  } = _lookupByKey(table, 'time', val));
            }
            ({ time: prevSource , pos: prevTarget  } = table[lo]);
            ({ time: nextSource , pos: nextTarget  } = table[hi]);
        }
        const span = nextSource - prevSource;
        return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;
    }
    class TimeSeriesScale extends TimeScale {
        static id = 'timeseries';
     static defaults = TimeScale.defaults;
     constructor(props){
            super(props);
             this._table = [];
             this._minPos = undefined;
             this._tableRange = undefined;
        }
     initOffsets() {
            const timestamps = this._getTimestampsForTable();
            const table = this._table = this.buildLookupTable(timestamps);
            this._minPos = interpolate(table, this.min);
            this._tableRange = interpolate(table, this.max) - this._minPos;
            super.initOffsets(timestamps);
        }
     buildLookupTable(timestamps) {
            const { min , max  } = this;
            const items = [];
            const table = [];
            let i, ilen, prev, curr, next;
            for(i = 0, ilen = timestamps.length; i < ilen; ++i){
                curr = timestamps[i];
                if (curr >= min && curr <= max) {
                    items.push(curr);
                }
            }
            if (items.length < 2) {
                return [
                    {
                        time: min,
                        pos: 0
                    },
                    {
                        time: max,
                        pos: 1
                    }
                ];
            }
            for(i = 0, ilen = items.length; i < ilen; ++i){
                next = items[i + 1];
                prev = items[i - 1];
                curr = items[i];
                if (Math.round((next + prev) / 2) !== curr) {
                    table.push({
                        time: curr,
                        pos: i / (ilen - 1)
                    });
                }
            }
            return table;
        }
     _generate() {
            const min = this.min;
            const max = this.max;
            let timestamps = super.getDataTimestamps();
            if (!timestamps.includes(min) || !timestamps.length) {
                timestamps.splice(0, 0, min);
            }
            if (!timestamps.includes(max) || timestamps.length === 1) {
                timestamps.push(max);
            }
            return timestamps.sort((a, b)=>a - b);
        }
     _getTimestampsForTable() {
            let timestamps = this._cache.all || [];
            if (timestamps.length) {
                return timestamps;
            }
            const data = this.getDataTimestamps();
            const label = this.getLabelTimestamps();
            if (data.length && label.length) {
                timestamps = this.normalize(data.concat(label));
            } else {
                timestamps = data.length ? data : label;
            }
            timestamps = this._cache.all = timestamps;
            return timestamps;
        }
     getDecimalForValue(value) {
            return (interpolate(this._table, value) - this._minPos) / this._tableRange;
        }
     getValueForPixel(pixel) {
            const offsets = this._offsets;
            const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
            return interpolate(this._table, decimal * this._tableRange + this._minPos, true);
        }
    }

    var scales = /*#__PURE__*/Object.freeze({
    __proto__: null,
    CategoryScale: CategoryScale,
    LinearScale: LinearScale,
    LogarithmicScale: LogarithmicScale,
    RadialLinearScale: RadialLinearScale,
    TimeScale: TimeScale,
    TimeSeriesScale: TimeSeriesScale
    });

    const registerables = [
        controllers,
        elements,
        plugins,
        scales
    ];

    Chart.register(...registerables);

    /* src\Pages\Plant\Details\PlantDetailsPage.svelte generated by Svelte v3.59.2 */
    const file$d = "src\\Pages\\Plant\\Details\\PlantDetailsPage.svelte";

    // (153:4) {:else}
    function create_else_block$3(ctx) {
    	let loader;
    	let current;
    	loader = new Loader({ props: { width: 200 }, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(loader.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(loader, target, anchor);
    			current = true;
    		},
    		p: noop$1,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(loader.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(loader.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(loader, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$3.name,
    		type: "else",
    		source: "(153:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (117:4) {#if plant}
    function create_if_block$5(ctx) {
    	let div3;
    	let div2;
    	let div0;
    	let h1;
    	let t0_value = /*plant*/ ctx[1].name + "";
    	let t0;
    	let t1;
    	let a;
    	let t2;
    	let a_href_value;
    	let t3;
    	let div1;
    	let span0;
    	let t5;
    	let span1;
    	let t6;
    	let span1_class_value;
    	let t7;
    	let button;
    	let t9;
    	let canvas;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div2 = element("div");
    			div0 = element("div");
    			h1 = element("h1");
    			t0 = text(t0_value);
    			t1 = space();
    			a = element("a");
    			t2 = text("Update informatie");
    			t3 = space();
    			div1 = element("div");
    			span0 = element("span");
    			span0.textContent = "Status:";
    			t5 = space();
    			span1 = element("span");
    			t6 = text(/*state*/ ctx[0]);
    			t7 = space();
    			button = element("button");
    			button.textContent = "Dosis water geven";
    			t9 = space();
    			canvas = element("canvas");
    			attr_dev(h1, "class", "text-center text-2xl text-gray-900");
    			add_location(h1, file$d, 120, 20, 4144);
    			attr_dev(a, "class", "ml-2 inline-flex items-center px-3 py-2 text-sm font-medium text-center text-white bg-sky-400 rounded-lg hover:bg-sky-600 focus:ring-4 focus:outline-none focus:ring-blue-300");
    			attr_dev(a, "href", a_href_value = "/#/plants/update/" + /*plant*/ ctx[1].id);
    			add_location(a, file$d, 123, 20, 4278);
    			attr_dev(div0, "class", "flex w-full justify-center items-center");
    			add_location(div0, file$d, 119, 16, 4069);
    			attr_dev(span0, "class", "mr-2");
    			add_location(span0, file$d, 132, 20, 4757);

    			attr_dev(span1, "class", span1_class_value = "ml-2 " + (/*state*/ ctx[0] === 'Geeft water'
    			? 'text-sky-500'
    			: /*state*/ ctx[0] === 'Verbonden'
    				? 'text-green-500'
    				: 'text-red-500'));

    			add_location(span1, file$d, 133, 20, 4812);
    			attr_dev(button, "class", "ml-2 inline-flex items-center px-3 py-2 text-sm font-medium text-center text-white bg-sky-400 rounded-lg hover:bg-sky-600 focus:ring-4 focus:outline-none focus:ring-blue-300");
    			add_location(button, file$d, 143, 20, 5187);
    			attr_dev(div1, "class", "my-3 flex items-center justify-between");
    			add_location(div1, file$d, 131, 16, 4683);
    			attr_dev(div2, "class", "flex flex-col justify-center items-center");
    			add_location(div2, file$d, 118, 12, 3996);
    			attr_dev(div3, "class", "w-1/2");
    			add_location(div3, file$d, 117, 8, 3963);
    			attr_dev(canvas, "class", "w-full");
    			set_style(canvas, "max-height", "750px");
    			attr_dev(canvas, "id", "pumpChart");
    			add_location(canvas, file$d, 151, 8, 5568);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div2);
    			append_dev(div2, div0);
    			append_dev(div0, h1);
    			append_dev(h1, t0);
    			append_dev(div0, t1);
    			append_dev(div0, a);
    			append_dev(a, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, span0);
    			append_dev(div1, t5);
    			append_dev(div1, span1);
    			append_dev(span1, t6);
    			append_dev(div1, t7);
    			append_dev(div1, button);
    			insert_dev(target, t9, anchor);
    			insert_dev(target, canvas, anchor);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*giveWater*/ ctx[2], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*plant*/ 2 && t0_value !== (t0_value = /*plant*/ ctx[1].name + "")) set_data_dev(t0, t0_value);

    			if (dirty & /*plant*/ 2 && a_href_value !== (a_href_value = "/#/plants/update/" + /*plant*/ ctx[1].id)) {
    				attr_dev(a, "href", a_href_value);
    			}

    			if (dirty & /*state*/ 1) set_data_dev(t6, /*state*/ ctx[0]);

    			if (dirty & /*state*/ 1 && span1_class_value !== (span1_class_value = "ml-2 " + (/*state*/ ctx[0] === 'Geeft water'
    			? 'text-sky-500'
    			: /*state*/ ctx[0] === 'Verbonden'
    				? 'text-green-500'
    				: 'text-red-500'))) {
    				attr_dev(span1, "class", span1_class_value);
    			}
    		},
    		i: noop$1,
    		o: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			if (detaching) detach_dev(t9);
    			if (detaching) detach_dev(canvas);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$5.name,
    		type: "if",
    		source: "(117:4) {#if plant}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$e(ctx) {
    	let div;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	const if_block_creators = [create_if_block$5, create_else_block$3];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*plant*/ ctx[1]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if_block.c();
    			attr_dev(div, "class", "flex justify-center flex-col items-center p-5 w-full");
    			add_location(div, file$d, 115, 0, 3870);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if_blocks[current_block_type_index].m(div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$e.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$e($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('PlantDetailsPage', slots, []);
    	const apiContext = new ApiContext();
    	const userContext = new UserContext();
    	let state = "Niet verbonden";
    	let plant = null;
    	let ws = null;
    	let chart;
    	const data = [];

    	function giveWater() {
    		ws.send("p:" + plant.duration);
    	}

    	function updateChart() {
    		if (chart) {
    			chart.data.labels = data.map(d => d.date.toLocaleTimeString("nl-NL", { hour: "2-digit", minute: "2-digit" }));
    			chart.data.datasets[0].data = data.map(d => d.value);
    			chart.update();
    		}
    	}

    	onMount(async () => {
    		const id = parseInt(window.location.href.substring(window.location.href.lastIndexOf("/") + 1));
    		$$invalidate(1, plant = await apiContext.getPlant(id));

    		data.push(...plant.plantValues.map(x => ({
    			date: new Date(x.recordedAt),
    			value: x.pumpState ? 1 : 0
    		})));

    		if (await apiContext.plantIsConnected(id)) {
    			$$invalidate(0, state = "Verbonden");
    		}

    		const token = userContext.token();
    		ws = new WebSocket(`wss://localhost:7196/watch?plantId=${id}&auth=${token}`);

    		ws.onmessage = event => {
    			const message = event.data;

    			if (message.endsWith("0")) {
    				data.push({ date: new Date(), value: 0 });
    				$$invalidate(0, state = "Verbonden");
    			} else if (message.endsWith("1")) {
    				$$invalidate(0, state = "Geeft water");
    				data.push({ date: new Date(), value: 1 });
    			} else {
    				$$invalidate(0, state = "Niet verbonden");
    			}

    			updateChart();
    		};

    		ws.onerror = () => {
    			Swal.fire({
    				title: "Er is iets fout gegaan",
    				text: `Een onverwachte fout is opgetreden. Probeer het later opnieuw. Als de fout blijft optreden, neem contact op met de ontwikkelaar.`
    			});
    		};

    		const ctx = document.getElementById("pumpChart");

    		chart = new Chart(ctx,
    		{
    				type: "line",
    				data: {
    					labels: data.map(d => d.date.toLocaleTimeString("nl-NL", { hour: "2-digit", minute: "2-digit" })),
    					datasets: [
    						{
    							label: "Pompstatus",
    							data: data.map(d => d.value),
    							fill: {
    								target: "origin",
    								above: "rgba(75, 192, 192, 0.4)",
    								below: "transparent"
    							},
    							borderColor: "rgba(75, 192, 192, 1)",
    							backgroundColor: "rgba(75, 192, 192, 0.4)",
    							pointBackgroundColor: "rgba(75, 192, 192, 1)",
    							tension: 0.3
    						}
    					]
    				},
    				options: {
    					scales: {
    						x: {
    							type: "category",
    							title: { display: true, text: "Tijd" }
    						},
    						y: {
    							suggestedMin: 0,
    							suggestedMax: 1,
    							ticks: { stepSize: 1 }
    						}
    					},
    					plugins: {
    						tooltip: {
    							callbacks: {
    								title: tooltipItems => {
    									const index = tooltipItems[0].dataIndex;
    									return data[index].date.toLocaleString();
    								}
    							}
    						}
    					}
    				}
    			});
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<PlantDetailsPage> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		onMount,
    		ApiContext,
    		Loader,
    		UserContext,
    		Swal,
    		Chart,
    		apiContext,
    		userContext,
    		state,
    		plant,
    		ws,
    		chart,
    		data,
    		giveWater,
    		updateChart
    	});

    	$$self.$inject_state = $$props => {
    		if ('state' in $$props) $$invalidate(0, state = $$props.state);
    		if ('plant' in $$props) $$invalidate(1, plant = $$props.plant);
    		if ('ws' in $$props) ws = $$props.ws;
    		if ('chart' in $$props) chart = $$props.chart;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [state, plant, giveWater];
    }

    class PlantDetailsPage extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$e, create_fragment$e, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "PlantDetailsPage",
    			options,
    			id: create_fragment$e.name
    		});
    	}
    }

    /* src\Components\Card.svelte generated by Svelte v3.59.2 */

    const file$c = "src\\Components\\Card.svelte";

    // (12:4) {#if description}
    function create_if_block_1$2(ctx) {
    	let p;
    	let t;

    	const block = {
    		c: function create() {
    			p = element("p");
    			t = text(/*description*/ ctx[1]);
    			attr_dev(p, "class", "mb-3 font-normal text-gray-700");
    			add_location(p, file$c, 12, 8, 339);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    			append_dev(p, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*description*/ 2) set_data_dev(t, /*description*/ ctx[1]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$2.name,
    		type: "if",
    		source: "(12:4) {#if description}",
    		ctx
    	});

    	return block;
    }

    // (20:4) {#if link}
    function create_if_block$4(ctx) {
    	let a;
    	let t;
    	let svg;
    	let path;
    	let a_href_value;

    	const block = {
    		c: function create() {
    			a = element("a");
    			t = text("Meer informatie\r\n            ");
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "stroke", "currentColor");
    			attr_dev(path, "stroke-linecap", "round");
    			attr_dev(path, "stroke-linejoin", "round");
    			attr_dev(path, "stroke-width", "2");
    			attr_dev(path, "d", "M1 5h12m0 0L9 1m4 4L9 9");
    			add_location(path, file$c, 32, 16, 1010);
    			attr_dev(svg, "class", "rtl:rotate-180 w-3.5 h-3.5 ms-2");
    			attr_dev(svg, "aria-hidden", "true");
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "fill", "none");
    			attr_dev(svg, "viewBox", "0 0 14 10");
    			add_location(svg, file$c, 25, 12, 762);
    			attr_dev(a, "href", a_href_value = "/#/" + /*link*/ ctx[2]);
    			attr_dev(a, "class", "self-end inline-flex items-center px-3 py-2 text-sm font-medium text-center text-white bg-sky-400 rounded-lg hover:bg-sky-600 focus:ring-4 focus:outline-none focus:ring-blue-300");
    			add_location(a, file$c, 20, 8, 477);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			append_dev(a, t);
    			append_dev(a, svg);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*link*/ 4 && a_href_value !== (a_href_value = "/#/" + /*link*/ ctx[2])) {
    				attr_dev(a, "href", a_href_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$4.name,
    		type: "if",
    		source: "(20:4) {#if link}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$d(ctx) {
    	let div;
    	let h5;
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let current;
    	let if_block0 = /*description*/ ctx[1] && create_if_block_1$2(ctx);
    	const default_slot_template = /*#slots*/ ctx[4].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
    	let if_block1 = /*link*/ ctx[2] && create_if_block$4(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			h5 = element("h5");
    			t0 = text(/*title*/ ctx[0]);
    			t1 = space();
    			if (if_block0) if_block0.c();
    			t2 = space();
    			if (default_slot) default_slot.c();
    			t3 = space();
    			if (if_block1) if_block1.c();
    			attr_dev(h5, "class", "mb-2 text-2xl font-bold tracking-tight text-gray-900");
    			add_location(h5, file$c, 8, 4, 213);
    			attr_dev(div, "class", "m-3 max-w-sm p-6 bg-white border border-gray-200 rounded-lg shadow-sm");
    			add_location(div, file$c, 5, 0, 117);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, h5);
    			append_dev(h5, t0);
    			append_dev(div, t1);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t2);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			append_dev(div, t3);
    			if (if_block1) if_block1.m(div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (!current || dirty & /*title*/ 1) set_data_dev(t0, /*title*/ ctx[0]);

    			if (/*description*/ ctx[1]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_1$2(ctx);
    					if_block0.c();
    					if_block0.m(div, t2);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[3],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[3])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null),
    						null
    					);
    				}
    			}

    			if (/*link*/ ctx[2]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block$4(ctx);
    					if_block1.c();
    					if_block1.m(div, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			if (default_slot) default_slot.d(detaching);
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$d.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$d($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Card', slots, ['default']);
    	let { title } = $$props;
    	let { description = undefined } = $$props;
    	let { link = undefined } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (title === undefined && !('title' in $$props || $$self.$$.bound[$$self.$$.props['title']])) {
    			console.warn("<Card> was created without expected prop 'title'");
    		}
    	});

    	const writable_props = ['title', 'description', 'link'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Card> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('title' in $$props) $$invalidate(0, title = $$props.title);
    		if ('description' in $$props) $$invalidate(1, description = $$props.description);
    		if ('link' in $$props) $$invalidate(2, link = $$props.link);
    		if ('$$scope' in $$props) $$invalidate(3, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ title, description, link });

    	$$self.$inject_state = $$props => {
    		if ('title' in $$props) $$invalidate(0, title = $$props.title);
    		if ('description' in $$props) $$invalidate(1, description = $$props.description);
    		if ('link' in $$props) $$invalidate(2, link = $$props.link);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [title, description, link, $$scope, slots];
    }

    class Card extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$d, create_fragment$d, safe_not_equal, { title: 0, description: 1, link: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Card",
    			options,
    			id: create_fragment$d.name
    		});
    	}

    	get title() {
    		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get description() {
    		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set description(value) {
    		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get link() {
    		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set link(value) {
    		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\Pages\Plant\Index\PlantIndexPage.svelte generated by Svelte v3.59.2 */

    const { Object: Object_1 } = globals;
    const file$b = "src\\Pages\\Plant\\Index\\PlantIndexPage.svelte";

    function get_each_context(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[3] = list[i];
    	return child_ctx;
    }

    // (37:8) {:else}
    function create_else_block$2(ctx) {
    	let t;
    	let each_1_anchor;
    	let current;
    	let if_block = !/*plants*/ ctx[0].length && create_if_block_2(ctx);
    	let each_value = /*plants*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			t = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, t, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(target, anchor);
    				}
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (!/*plants*/ ctx[0].length) {
    				if (if_block) ; else {
    					if_block = create_if_block_2(ctx);
    					if_block.c();
    					if_block.m(t.parentNode, t);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*plants, undefined*/ 1) {
    				each_value = /*plants*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(t);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$2.name,
    		type: "else",
    		source: "(37:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (35:8) {#if loading}
    function create_if_block$3(ctx) {
    	let i;

    	const block = {
    		c: function create() {
    			i = element("i");
    			i.textContent = "Laden...";
    			add_location(i, file$b, 35, 12, 1280);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i, anchor);
    		},
    		p: noop$1,
    		i: noop$1,
    		o: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$3.name,
    		type: "if",
    		source: "(35:8) {#if loading}",
    		ctx
    	});

    	return block;
    }

    // (38:12) {#if !plants.length}
    function create_if_block_2(ctx) {
    	let i;

    	const block = {
    		c: function create() {
    			i = element("i");
    			i.textContent = "U heeft nog geen planten";
    			add_location(i, file$b, 38, 16, 1364);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2.name,
    		type: "if",
    		source: "(38:12) {#if !plants.length}",
    		ctx
    	});

    	return block;
    }

    // (48:20) {:else}
    function create_else_block_1(ctx) {
    	let div;
    	let span0;
    	let t1;
    	let span1;
    	let t2_value = (/*plant*/ ctx[3].state ? "verbonden" : "Niet verbonden") + "";
    	let t2;
    	let span1_class_value;
    	let t3;
    	let a;
    	let t4;
    	let a_href_value;

    	const block = {
    		c: function create() {
    			div = element("div");
    			span0 = element("span");
    			span0.textContent = "Status:";
    			t1 = space();
    			span1 = element("span");
    			t2 = text(t2_value);
    			t3 = space();
    			a = element("a");
    			t4 = text("Informatie updaten");
    			attr_dev(span0, "class", "mr-2");
    			add_location(span0, file$b, 49, 28, 1828);

    			attr_dev(span1, "class", span1_class_value = "ml-2 " + (/*plant*/ ctx[3].state
    			? 'text-green-500'
    			: 'text-red-500'));

    			add_location(span1, file$b, 50, 28, 1891);
    			attr_dev(div, "class", "my-3 flex justify-between");
    			add_location(div, file$b, 48, 24, 1759);
    			attr_dev(a, "href", a_href_value = "/#/plants/update/" + /*plant*/ ctx[3].id);
    			attr_dev(a, "class", "self-end inline-flex items-center px-3 py-2 text-sm font-medium text-center text-white bg-sky-400 rounded-lg hover:bg-sky-600 focus:ring-4 focus:outline-none focus:ring-blue-300");
    			add_location(a, file$b, 58, 24, 2272);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span0);
    			append_dev(div, t1);
    			append_dev(div, span1);
    			append_dev(span1, t2);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, a, anchor);
    			append_dev(a, t4);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*plants*/ 1 && t2_value !== (t2_value = (/*plant*/ ctx[3].state ? "verbonden" : "Niet verbonden") + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*plants*/ 1 && span1_class_value !== (span1_class_value = "ml-2 " + (/*plant*/ ctx[3].state
    			? 'text-green-500'
    			: 'text-red-500'))) {
    				attr_dev(span1, "class", span1_class_value);
    			}

    			if (dirty & /*plants*/ 1 && a_href_value !== (a_href_value = "/#/plants/update/" + /*plant*/ ctx[3].id)) {
    				attr_dev(a, "href", a_href_value);
    			}
    		},
    		i: noop$1,
    		o: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(a);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1.name,
    		type: "else",
    		source: "(48:20) {:else}",
    		ctx
    	});

    	return block;
    }

    // (44:20) {#if plant.state == undefined}
    function create_if_block_1$1(ctx) {
    	let div;
    	let loader;
    	let current;
    	loader = new Loader({ $$inline: true });

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(loader.$$.fragment);
    			attr_dev(div, "class", "flex justify-center");
    			add_location(div, file$b, 44, 24, 1599);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(loader, div, null);
    			current = true;
    		},
    		p: noop$1,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(loader.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(loader.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(loader);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$1.name,
    		type: "if",
    		source: "(44:20) {#if plant.state == undefined}",
    		ctx
    	});

    	return block;
    }

    // (43:16) <Card link="plants/{plant.id}" title={plant.name}>
    function create_default_slot$1(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let t;
    	let current;
    	const if_block_creators = [create_if_block_1$1, create_else_block_1];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*plant*/ ctx[3].state == undefined) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_1(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			t = space();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, t, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(t.parentNode, t);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$1.name,
    		type: "slot",
    		source: "(43:16) <Card link=\\\"plants/{plant.id}\\\" title={plant.name}>",
    		ctx
    	});

    	return block;
    }

    // (42:12) {#each plants as plant}
    function create_each_block(ctx) {
    	let card;
    	let current;

    	card = new Card({
    			props: {
    				link: "plants/" + /*plant*/ ctx[3].id,
    				title: /*plant*/ ctx[3].name,
    				$$slots: { default: [create_default_slot$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(card.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(card, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const card_changes = {};
    			if (dirty & /*plants*/ 1) card_changes.link = "plants/" + /*plant*/ ctx[3].id;
    			if (dirty & /*plants*/ 1) card_changes.title = /*plant*/ ctx[3].name;

    			if (dirty & /*$$scope, plants*/ 65) {
    				card_changes.$$scope = { dirty, ctx };
    			}

    			card.$set(card_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(card.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(card.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(card, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block.name,
    		type: "each",
    		source: "(42:12) {#each plants as plant}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$c(ctx) {
    	let div2;
    	let div0;
    	let h1;
    	let t1;
    	let a;
    	let t3;
    	let div1;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	const if_block_creators = [create_if_block$3, create_else_block$2];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*loading*/ ctx[1]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			h1 = element("h1");
    			h1.textContent = "Uw planten";
    			t1 = space();
    			a = element("a");
    			a.textContent = "Plant aanmaken";
    			t3 = space();
    			div1 = element("div");
    			if_block.c();
    			attr_dev(h1, "class", "text-center text-2xl mr-4 text-gray-900");
    			add_location(h1, file$b, 23, 8, 923);
    			attr_dev(a, "href", "/#/plants/create");
    			attr_dev(a, "class", "py-2 px-4 border-sky-600 bg-sky-400 text-white rounded-lg");
    			add_location(a, file$b, 25, 8, 1002);
    			attr_dev(div0, "class", "w-full justify-center flex");
    			add_location(div0, file$b, 22, 4, 873);
    			attr_dev(div1, "class", "w-full flex justify-center flex-wrap");
    			add_location(div1, file$b, 33, 4, 1193);
    			attr_dev(div2, "class", "flex flex-col justify-center w-full");
    			add_location(div2, file$b, 21, 0, 818);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			append_dev(div0, h1);
    			append_dev(div0, t1);
    			append_dev(div0, a);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			if_blocks[current_block_type_index].m(div1, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div1, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$c.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$c($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('PlantIndexPage', slots, []);
    	ensureLoggedIn();
    	const apiContext = new ApiContext();
    	let plants = [];
    	let loading = true;

    	onMount(async () => {
    		$$invalidate(0, plants = (await apiContext.getPlants()).map(x => Object.assign(Object.assign({}, x), { state: undefined })));

    		plants.forEach(async plant => {
    			await new Promise(r => setTimeout(r, Math.random() * 1500 + 50));
    			plant.state = await apiContext.plantIsConnected(plant.id);

    			// trigger rerender
    			$$invalidate(0, plants);
    		});

    		$$invalidate(1, loading = false);
    	});

    	const writable_props = [];

    	Object_1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<PlantIndexPage> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		onMount,
    		ApiContext,
    		ensureLoggedIn,
    		Card,
    		Loader,
    		apiContext,
    		plants,
    		loading
    	});

    	$$self.$inject_state = $$props => {
    		if ('plants' in $$props) $$invalidate(0, plants = $$props.plants);
    		if ('loading' in $$props) $$invalidate(1, loading = $$props.loading);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [plants, loading];
    }

    class PlantIndexPage extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$c, create_fragment$c, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "PlantIndexPage",
    			options,
    			id: create_fragment$c.name
    		});
    	}
    }

    /* src\Pages\Plant\Update\UpdatePlantForm.svelte generated by Svelte v3.59.2 */
    const file$a = "src\\Pages\\Plant\\Update\\UpdatePlantForm.svelte";

    function create_fragment$b(ctx) {
    	let form;
    	let span0;
    	let t1;
    	let div0;
    	let formfield0;
    	let t2;
    	let div1;
    	let formfield1;
    	let t3;
    	let div2;
    	let span1;
    	let t5;
    	let input;
    	let t6;
    	let button;
    	let current;
    	let mounted;
    	let dispose;

    	formfield0 = new FormField({
    			props: {
    				value: /*name*/ ctx[1].value,
    				onchange: /*func*/ ctx[5],
    				name: "name",
    				type: "text",
    				maxLength: 255
    			},
    			$$inline: true
    		});

    	formfield1 = new FormField({
    			props: {
    				value: /*duration*/ ctx[2].value,
    				onchange: /*func_1*/ ctx[6],
    				name: "duratie (seconden)",
    				type: "number",
    				max: 300,
    				min: 0
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			form = element("form");
    			span0 = element("span");
    			span0.textContent = "* Verplichte velden";
    			t1 = space();
    			div0 = element("div");
    			create_component(formfield0.$$.fragment);
    			t2 = space();
    			div1 = element("div");
    			create_component(formfield1.$$.fragment);
    			t3 = space();
    			div2 = element("div");
    			span1 = element("span");
    			span1.textContent = "Genereer wachtwoord opnieuw";
    			t5 = space();
    			input = element("input");
    			t6 = space();
    			button = element("button");
    			button.textContent = "Versturen";
    			attr_dev(span0, "class", "text-gray-500 ml-2");
    			add_location(span0, file$a, 59, 4, 1725);
    			attr_dev(div0, "class", "md:w-1/2 w-3/4");
    			add_location(div0, file$a, 60, 4, 1790);
    			attr_dev(div1, "class", "md:w-1/2 w-3/4");
    			add_location(div1, file$a, 70, 4, 2058);
    			add_location(span1, file$a, 82, 8, 2436);
    			attr_dev(input, "type", "checkbox");
    			attr_dev(input, "class", "m-2 w-4 h-4 accent-sky-400");
    			add_location(input, file$a, 83, 8, 2486);
    			attr_dev(div2, "class", "md:w-1/2 w-3/4 items-center flex justify-center");
    			add_location(div2, file$a, 81, 4, 2365);
    			attr_dev(button, "type", "submit");
    			attr_dev(button, "class", "py-2 px-4 border-sky-600 bg-sky-400 text-white rounded-lg");
    			add_location(button, file$a, 90, 4, 2648);
    			attr_dev(form, "action", "");
    			attr_dev(form, "method", "get");
    			attr_dev(form, "class", "p-2 w-full flex-col h-full flex items-center justify-center flex-wrap");
    			add_location(form, file$a, 53, 0, 1571);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, form, anchor);
    			append_dev(form, span0);
    			append_dev(form, t1);
    			append_dev(form, div0);
    			mount_component(formfield0, div0, null);
    			append_dev(form, t2);
    			append_dev(form, div1);
    			mount_component(formfield1, div1, null);
    			append_dev(form, t3);
    			append_dev(form, div2);
    			append_dev(div2, span1);
    			append_dev(div2, t5);
    			append_dev(div2, input);
    			input.checked = /*regeneratePassword*/ ctx[0];
    			append_dev(form, t6);
    			append_dev(form, button);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "change", /*input_change_handler*/ ctx[7]),
    					listen_dev(form, "submit", /*submit*/ ctx[3], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*regeneratePassword*/ 1) {
    				input.checked = /*regeneratePassword*/ ctx[0];
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(formfield0.$$.fragment, local);
    			transition_in(formfield1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(formfield0.$$.fragment, local);
    			transition_out(formfield1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(form);
    			destroy_component(formfield0);
    			destroy_component(formfield1);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$b.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function updateValidity$1(object, value, valid) {
    	object.value = value;
    	object.valid = valid;
    }

    function instance$b($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('UpdatePlantForm', slots, []);
    	let { plant } = $$props;
    	ensureLoggedIn();
    	const name = { valid: true, value: plant.name };
    	const duration = { valid: true, value: plant.duration };
    	let regeneratePassword = false;

    	async function submit(event) {
    		event.preventDefault();

    		if ([duration, name].some(x => !x.valid)) {
    			return;
    		}

    		var context = new ApiContext();

    		const result = await context.updatePlant({
    			duration: duration.value,
    			name: name.value,
    			regeneratePassword,
    			id: plant.id
    		});

    		if (result.password) {
    			await Swal.fire({
    				title: "Plant gepdatet!",
    				text: "De plant is aangemaakt. Om de hydrocomputer te verbinden" + "met de server is een token nodig. Het token is: '" + result.password + "'. Sla deze goed op, deze kan niet teruggehaald worden.",
    				icon: "success"
    			});
    		} else {
    			Swal.fire({
    				title: "Plant gepdatet!",
    				text: "De plant is gepdatet.",
    				icon: "success"
    			});
    		}

    		push("/plants/" + result.id);
    	}

    	$$self.$$.on_mount.push(function () {
    		if (plant === undefined && !('plant' in $$props || $$self.$$.bound[$$self.$$.props['plant']])) {
    			console.warn("<UpdatePlantForm> was created without expected prop 'plant'");
    		}
    	});

    	const writable_props = ['plant'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<UpdatePlantForm> was created with unknown prop '${key}'`);
    	});

    	const func = (value, valid) => updateValidity$1(name, value, valid);
    	const func_1 = (value, valid) => updateValidity$1(duration, value, valid);

    	function input_change_handler() {
    		regeneratePassword = this.checked;
    		$$invalidate(0, regeneratePassword);
    	}

    	$$self.$$set = $$props => {
    		if ('plant' in $$props) $$invalidate(4, plant = $$props.plant);
    	};

    	$$self.$capture_state = () => ({
    		Swal,
    		FormField,
    		ApiContext,
    		push,
    		ensureLoggedIn,
    		plant,
    		name,
    		duration,
    		regeneratePassword,
    		updateValidity: updateValidity$1,
    		submit
    	});

    	$$self.$inject_state = $$props => {
    		if ('plant' in $$props) $$invalidate(4, plant = $$props.plant);
    		if ('regeneratePassword' in $$props) $$invalidate(0, regeneratePassword = $$props.regeneratePassword);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		regeneratePassword,
    		name,
    		duration,
    		submit,
    		plant,
    		func,
    		func_1,
    		input_change_handler
    	];
    }

    class UpdatePlantForm extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$b, create_fragment$b, safe_not_equal, { plant: 4 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "UpdatePlantForm",
    			options,
    			id: create_fragment$b.name
    		});
    	}

    	get plant() {
    		throw new Error("<UpdatePlantForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set plant(value) {
    		throw new Error("<UpdatePlantForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\Pages\Plant\Update\UpdatePlantPage.svelte generated by Svelte v3.59.2 */
    const file$9 = "src\\Pages\\Plant\\Update\\UpdatePlantPage.svelte";

    // (29:4) {:else}
    function create_else_block$1(ctx) {
    	let updateplantform;
    	let current;

    	updateplantform = new UpdatePlantForm({
    			props: { plant: /*plant*/ ctx[0] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(updateplantform.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(updateplantform, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const updateplantform_changes = {};
    			if (dirty & /*plant*/ 1) updateplantform_changes.plant = /*plant*/ ctx[0];
    			updateplantform.$set(updateplantform_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(updateplantform.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(updateplantform.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(updateplantform, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$1.name,
    		type: "else",
    		source: "(29:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (25:4) {#if !plant}
    function create_if_block$2(ctx) {
    	let div;
    	let loader;
    	let current;
    	loader = new Loader({ $$inline: true });

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(loader.$$.fragment);
    			attr_dev(div, "class", "flex justify-center");
    			add_location(div, file$9, 25, 8, 818);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(loader, div, null);
    			current = true;
    		},
    		p: noop$1,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(loader.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(loader.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(loader);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$2.name,
    		type: "if",
    		source: "(25:4) {#if !plant}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$a(ctx) {
    	let div;
    	let h1;
    	let t1;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	const if_block_creators = [create_if_block$2, create_else_block$1];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (!/*plant*/ ctx[0]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			h1 = element("h1");
    			h1.textContent = "Plant updaten";
    			t1 = space();
    			if_block.c();
    			attr_dev(h1, "class", "text-center text-2xl w-full text-gray-900");
    			add_location(h1, file$9, 22, 4, 716);
    			attr_dev(div, "class", "flex flex-col justify-center w-full");
    			add_location(div, file$9, 21, 0, 661);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, h1);
    			append_dev(div, t1);
    			if_blocks[current_block_type_index].m(div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$a.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$a($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('UpdatePlantPage', slots, []);
    	ensureLoggedIn();
    	let plant = null;
    	const apiContext = new ApiContext();

    	onMount(async () => {
    		const id = parseInt(window.location.href.substring(window.location.href.lastIndexOf("/") + 1));
    		$$invalidate(0, plant = await apiContext.getPlant(id));
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<UpdatePlantPage> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		Loader,
    		ApiContext,
    		ensureLoggedIn,
    		UpdatePlantForm,
    		onMount,
    		plant,
    		apiContext
    	});

    	$$self.$inject_state = $$props => {
    		if ('plant' in $$props) $$invalidate(0, plant = $$props.plant);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [plant];
    }

    class UpdatePlantPage extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$a, create_fragment$a, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "UpdatePlantPage",
    			options,
    			id: create_fragment$a.name
    		});
    	}
    }

    var PlantRoutes = {
        "/plants": PlantIndexPage,
        "/plants/create": CreatePlantPage,
    };
    const maps = [
        {
            key: /\/plants\/[0-9]{1,}/,
            value: PlantDetailsPage
        },
        {
            key: /\/plants\/update\/[0-9]{1,}/,
            value: UpdatePlantPage
        }
    ];

    const defer = () => {
        var res, rej;

        var promise = new Promise((resolve, reject) => {
            res = resolve;
            rej = reject;
        });

        promise.resolve = res;
        promise.reject = rej;

        return promise;
    };

    const browser$1 = (() => {
        return typeof window === "object" && typeof window.document === "object";
    })();

    var browser = {exports: {}};

    /**
     * Helpers.
     */

    var ms;
    var hasRequiredMs;

    function requireMs () {
    	if (hasRequiredMs) return ms;
    	hasRequiredMs = 1;
    	var s = 1000;
    	var m = s * 60;
    	var h = m * 60;
    	var d = h * 24;
    	var w = d * 7;
    	var y = d * 365.25;

    	/**
    	 * Parse or format the given `val`.
    	 *
    	 * Options:
    	 *
    	 *  - `long` verbose formatting [false]
    	 *
    	 * @param {String|Number} val
    	 * @param {Object} [options]
    	 * @throws {Error} throw an error if val is not a non-empty string or a number
    	 * @return {String|Number}
    	 * @api public
    	 */

    	ms = function (val, options) {
    	  options = options || {};
    	  var type = typeof val;
    	  if (type === 'string' && val.length > 0) {
    	    return parse(val);
    	  } else if (type === 'number' && isFinite(val)) {
    	    return options.long ? fmtLong(val) : fmtShort(val);
    	  }
    	  throw new Error(
    	    'val is not a non-empty string or a valid number. val=' +
    	      JSON.stringify(val)
    	  );
    	};

    	/**
    	 * Parse the given `str` and return milliseconds.
    	 *
    	 * @param {String} str
    	 * @return {Number}
    	 * @api private
    	 */

    	function parse(str) {
    	  str = String(str);
    	  if (str.length > 100) {
    	    return;
    	  }
    	  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    	    str
    	  );
    	  if (!match) {
    	    return;
    	  }
    	  var n = parseFloat(match[1]);
    	  var type = (match[2] || 'ms').toLowerCase();
    	  switch (type) {
    	    case 'years':
    	    case 'year':
    	    case 'yrs':
    	    case 'yr':
    	    case 'y':
    	      return n * y;
    	    case 'weeks':
    	    case 'week':
    	    case 'w':
    	      return n * w;
    	    case 'days':
    	    case 'day':
    	    case 'd':
    	      return n * d;
    	    case 'hours':
    	    case 'hour':
    	    case 'hrs':
    	    case 'hr':
    	    case 'h':
    	      return n * h;
    	    case 'minutes':
    	    case 'minute':
    	    case 'mins':
    	    case 'min':
    	    case 'm':
    	      return n * m;
    	    case 'seconds':
    	    case 'second':
    	    case 'secs':
    	    case 'sec':
    	    case 's':
    	      return n * s;
    	    case 'milliseconds':
    	    case 'millisecond':
    	    case 'msecs':
    	    case 'msec':
    	    case 'ms':
    	      return n;
    	    default:
    	      return undefined;
    	  }
    	}

    	/**
    	 * Short format for `ms`.
    	 *
    	 * @param {Number} ms
    	 * @return {String}
    	 * @api private
    	 */

    	function fmtShort(ms) {
    	  var msAbs = Math.abs(ms);
    	  if (msAbs >= d) {
    	    return Math.round(ms / d) + 'd';
    	  }
    	  if (msAbs >= h) {
    	    return Math.round(ms / h) + 'h';
    	  }
    	  if (msAbs >= m) {
    	    return Math.round(ms / m) + 'm';
    	  }
    	  if (msAbs >= s) {
    	    return Math.round(ms / s) + 's';
    	  }
    	  return ms + 'ms';
    	}

    	/**
    	 * Long format for `ms`.
    	 *
    	 * @param {Number} ms
    	 * @return {String}
    	 * @api private
    	 */

    	function fmtLong(ms) {
    	  var msAbs = Math.abs(ms);
    	  if (msAbs >= d) {
    	    return plural(ms, msAbs, d, 'day');
    	  }
    	  if (msAbs >= h) {
    	    return plural(ms, msAbs, h, 'hour');
    	  }
    	  if (msAbs >= m) {
    	    return plural(ms, msAbs, m, 'minute');
    	  }
    	  if (msAbs >= s) {
    	    return plural(ms, msAbs, s, 'second');
    	  }
    	  return ms + ' ms';
    	}

    	/**
    	 * Pluralization helper.
    	 */

    	function plural(ms, msAbs, n, name) {
    	  var isPlural = msAbs >= n * 1.5;
    	  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
    	}
    	return ms;
    }

    /**
     * This is the common logic for both the Node.js and web browser
     * implementations of `debug()`.
     */

    function setup(env) {
    	createDebug.debug = createDebug;
    	createDebug.default = createDebug;
    	createDebug.coerce = coerce;
    	createDebug.disable = disable;
    	createDebug.enable = enable;
    	createDebug.enabled = enabled;
    	createDebug.humanize = requireMs();
    	createDebug.destroy = destroy;

    	Object.keys(env).forEach(key => {
    		createDebug[key] = env[key];
    	});

    	/**
    	* The currently active debug mode names, and names to skip.
    	*/

    	createDebug.names = [];
    	createDebug.skips = [];

    	/**
    	* Map of special "%n" handling functions, for the debug "format" argument.
    	*
    	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
    	*/
    	createDebug.formatters = {};

    	/**
    	* Selects a color for a debug namespace
    	* @param {String} namespace The namespace string for the debug instance to be colored
    	* @return {Number|String} An ANSI color code for the given namespace
    	* @api private
    	*/
    	function selectColor(namespace) {
    		let hash = 0;

    		for (let i = 0; i < namespace.length; i++) {
    			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
    			hash |= 0; // Convert to 32bit integer
    		}

    		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    	}
    	createDebug.selectColor = selectColor;

    	/**
    	* Create a debugger with the given `namespace`.
    	*
    	* @param {String} namespace
    	* @return {Function}
    	* @api public
    	*/
    	function createDebug(namespace) {
    		let prevTime;
    		let enableOverride = null;
    		let namespacesCache;
    		let enabledCache;

    		function debug(...args) {
    			// Disabled?
    			if (!debug.enabled) {
    				return;
    			}

    			const self = debug;

    			// Set `diff` timestamp
    			const curr = Number(new Date());
    			const ms = curr - (prevTime || curr);
    			self.diff = ms;
    			self.prev = prevTime;
    			self.curr = curr;
    			prevTime = curr;

    			args[0] = createDebug.coerce(args[0]);

    			if (typeof args[0] !== 'string') {
    				// Anything else let's inspect with %O
    				args.unshift('%O');
    			}

    			// Apply any `formatters` transformations
    			let index = 0;
    			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
    				// If we encounter an escaped % then don't increase the array index
    				if (match === '%%') {
    					return '%';
    				}
    				index++;
    				const formatter = createDebug.formatters[format];
    				if (typeof formatter === 'function') {
    					const val = args[index];
    					match = formatter.call(self, val);

    					// Now we need to remove `args[index]` since it's inlined in the `format`
    					args.splice(index, 1);
    					index--;
    				}
    				return match;
    			});

    			// Apply env-specific formatting (colors, etc.)
    			createDebug.formatArgs.call(self, args);

    			const logFn = self.log || createDebug.log;
    			logFn.apply(self, args);
    		}

    		debug.namespace = namespace;
    		debug.useColors = createDebug.useColors();
    		debug.color = createDebug.selectColor(namespace);
    		debug.extend = extend;
    		debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

    		Object.defineProperty(debug, 'enabled', {
    			enumerable: true,
    			configurable: false,
    			get: () => {
    				if (enableOverride !== null) {
    					return enableOverride;
    				}
    				if (namespacesCache !== createDebug.namespaces) {
    					namespacesCache = createDebug.namespaces;
    					enabledCache = createDebug.enabled(namespace);
    				}

    				return enabledCache;
    			},
    			set: v => {
    				enableOverride = v;
    			}
    		});

    		// Env-specific initialization logic for debug instances
    		if (typeof createDebug.init === 'function') {
    			createDebug.init(debug);
    		}

    		return debug;
    	}

    	function extend(namespace, delimiter) {
    		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
    		newDebug.log = this.log;
    		return newDebug;
    	}

    	/**
    	* Enables a debug mode by namespaces. This can include modes
    	* separated by a colon and wildcards.
    	*
    	* @param {String} namespaces
    	* @api public
    	*/
    	function enable(namespaces) {
    		createDebug.save(namespaces);
    		createDebug.namespaces = namespaces;

    		createDebug.names = [];
    		createDebug.skips = [];

    		const split = (typeof namespaces === 'string' ? namespaces : '')
    			.trim()
    			.replace(' ', ',')
    			.split(',')
    			.filter(Boolean);

    		for (const ns of split) {
    			if (ns[0] === '-') {
    				createDebug.skips.push(ns.slice(1));
    			} else {
    				createDebug.names.push(ns);
    			}
    		}
    	}

    	/**
    	 * Checks if the given string matches a namespace template, honoring
    	 * asterisks as wildcards.
    	 *
    	 * @param {String} search
    	 * @param {String} template
    	 * @return {Boolean}
    	 */
    	function matchesTemplate(search, template) {
    		let searchIndex = 0;
    		let templateIndex = 0;
    		let starIndex = -1;
    		let matchIndex = 0;

    		while (searchIndex < search.length) {
    			if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === '*')) {
    				// Match character or proceed with wildcard
    				if (template[templateIndex] === '*') {
    					starIndex = templateIndex;
    					matchIndex = searchIndex;
    					templateIndex++; // Skip the '*'
    				} else {
    					searchIndex++;
    					templateIndex++;
    				}
    			} else if (starIndex !== -1) { // eslint-disable-line no-negated-condition
    				// Backtrack to the last '*' and try to match more characters
    				templateIndex = starIndex + 1;
    				matchIndex++;
    				searchIndex = matchIndex;
    			} else {
    				return false; // No match
    			}
    		}

    		// Handle trailing '*' in template
    		while (templateIndex < template.length && template[templateIndex] === '*') {
    			templateIndex++;
    		}

    		return templateIndex === template.length;
    	}

    	/**
    	* Disable debug output.
    	*
    	* @return {String} namespaces
    	* @api public
    	*/
    	function disable() {
    		const namespaces = [
    			...createDebug.names,
    			...createDebug.skips.map(namespace => '-' + namespace)
    		].join(',');
    		createDebug.enable('');
    		return namespaces;
    	}

    	/**
    	* Returns true if the given mode name is enabled, false otherwise.
    	*
    	* @param {String} name
    	* @return {Boolean}
    	* @api public
    	*/
    	function enabled(name) {
    		for (const skip of createDebug.skips) {
    			if (matchesTemplate(name, skip)) {
    				return false;
    			}
    		}

    		for (const ns of createDebug.names) {
    			if (matchesTemplate(name, ns)) {
    				return true;
    			}
    		}

    		return false;
    	}

    	/**
    	* Coerce `val`.
    	*
    	* @param {Mixed} val
    	* @return {Mixed}
    	* @api private
    	*/
    	function coerce(val) {
    		if (val instanceof Error) {
    			return val.stack || val.message;
    		}
    		return val;
    	}

    	/**
    	* XXX DO NOT USE. This is a temporary stub function.
    	* XXX It WILL be removed in the next major release.
    	*/
    	function destroy() {
    		console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
    	}

    	createDebug.enable(createDebug.load());

    	return createDebug;
    }

    var common = setup;

    /* eslint-env browser */

    (function (module, exports) {
    	/**
    	 * This is the web browser implementation of `debug()`.
    	 */

    	exports.formatArgs = formatArgs;
    	exports.save = save;
    	exports.load = load;
    	exports.useColors = useColors;
    	exports.storage = localstorage();
    	exports.destroy = (() => {
    		let warned = false;

    		return () => {
    			if (!warned) {
    				warned = true;
    				console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
    			}
    		};
    	})();

    	/**
    	 * Colors.
    	 */

    	exports.colors = [
    		'#0000CC',
    		'#0000FF',
    		'#0033CC',
    		'#0033FF',
    		'#0066CC',
    		'#0066FF',
    		'#0099CC',
    		'#0099FF',
    		'#00CC00',
    		'#00CC33',
    		'#00CC66',
    		'#00CC99',
    		'#00CCCC',
    		'#00CCFF',
    		'#3300CC',
    		'#3300FF',
    		'#3333CC',
    		'#3333FF',
    		'#3366CC',
    		'#3366FF',
    		'#3399CC',
    		'#3399FF',
    		'#33CC00',
    		'#33CC33',
    		'#33CC66',
    		'#33CC99',
    		'#33CCCC',
    		'#33CCFF',
    		'#6600CC',
    		'#6600FF',
    		'#6633CC',
    		'#6633FF',
    		'#66CC00',
    		'#66CC33',
    		'#9900CC',
    		'#9900FF',
    		'#9933CC',
    		'#9933FF',
    		'#99CC00',
    		'#99CC33',
    		'#CC0000',
    		'#CC0033',
    		'#CC0066',
    		'#CC0099',
    		'#CC00CC',
    		'#CC00FF',
    		'#CC3300',
    		'#CC3333',
    		'#CC3366',
    		'#CC3399',
    		'#CC33CC',
    		'#CC33FF',
    		'#CC6600',
    		'#CC6633',
    		'#CC9900',
    		'#CC9933',
    		'#CCCC00',
    		'#CCCC33',
    		'#FF0000',
    		'#FF0033',
    		'#FF0066',
    		'#FF0099',
    		'#FF00CC',
    		'#FF00FF',
    		'#FF3300',
    		'#FF3333',
    		'#FF3366',
    		'#FF3399',
    		'#FF33CC',
    		'#FF33FF',
    		'#FF6600',
    		'#FF6633',
    		'#FF9900',
    		'#FF9933',
    		'#FFCC00',
    		'#FFCC33'
    	];

    	/**
    	 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
    	 * and the Firebug extension (any Firefox version) are known
    	 * to support "%c" CSS customizations.
    	 *
    	 * TODO: add a `localStorage` variable to explicitly enable/disable colors
    	 */

    	// eslint-disable-next-line complexity
    	function useColors() {
    		// NB: In an Electron preload script, document will be defined but not fully
    		// initialized. Since we know we're in Chrome, we'll just detect this case
    		// explicitly
    		if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
    			return true;
    		}

    		// Internet Explorer and Edge do not support colors.
    		if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    			return false;
    		}

    		let m;

    		// Is webkit? http://stackoverflow.com/a/16459606/376773
    		// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
    		// eslint-disable-next-line no-return-assign
    		return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    			// Is firebug? http://stackoverflow.com/a/398120/376773
    			(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    			// Is firefox >= v31?
    			// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    			(typeof navigator !== 'undefined' && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31) ||
    			// Double check webkit in userAgent just in case we are in a worker
    			(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
    	}

    	/**
    	 * Colorize log arguments if enabled.
    	 *
    	 * @api public
    	 */

    	function formatArgs(args) {
    		args[0] = (this.useColors ? '%c' : '') +
    			this.namespace +
    			(this.useColors ? ' %c' : ' ') +
    			args[0] +
    			(this.useColors ? '%c ' : ' ') +
    			'+' + module.exports.humanize(this.diff);

    		if (!this.useColors) {
    			return;
    		}

    		const c = 'color: ' + this.color;
    		args.splice(1, 0, c, 'color: inherit');

    		// The final "%c" is somewhat tricky, because there could be other
    		// arguments passed either before or after the %c, so we need to
    		// figure out the correct index to insert the CSS into
    		let index = 0;
    		let lastC = 0;
    		args[0].replace(/%[a-zA-Z%]/g, match => {
    			if (match === '%%') {
    				return;
    			}
    			index++;
    			if (match === '%c') {
    				// We only are interested in the *last* %c
    				// (the user may have provided their own)
    				lastC = index;
    			}
    		});

    		args.splice(lastC, 0, c);
    	}

    	/**
    	 * Invokes `console.debug()` when available.
    	 * No-op when `console.debug` is not a "function".
    	 * If `console.debug` is not available, falls back
    	 * to `console.log`.
    	 *
    	 * @api public
    	 */
    	exports.log = console.debug || console.log || (() => {});

    	/**
    	 * Save `namespaces`.
    	 *
    	 * @param {String} namespaces
    	 * @api private
    	 */
    	function save(namespaces) {
    		try {
    			if (namespaces) {
    				exports.storage.setItem('debug', namespaces);
    			} else {
    				exports.storage.removeItem('debug');
    			}
    		} catch (error) {
    			// Swallow
    			// XXX (@Qix-) should we be logging these?
    		}
    	}

    	/**
    	 * Load `namespaces`.
    	 *
    	 * @return {String} returns the previously persisted debug modes
    	 * @api private
    	 */
    	function load() {
    		let r;
    		try {
    			r = exports.storage.getItem('debug');
    		} catch (error) {
    			// Swallow
    			// XXX (@Qix-) should we be logging these?
    		}

    		// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
    		if (!r && typeof process !== 'undefined' && 'env' in process) {
    			r = process.env.DEBUG;
    		}

    		return r;
    	}

    	/**
    	 * Localstorage attempts to return the localstorage.
    	 *
    	 * This is necessary because safari throws
    	 * when a user disables cookies/localstorage
    	 * and you attempt to access it.
    	 *
    	 * @return {LocalStorage}
    	 * @api private
    	 */

    	function localstorage() {
    		try {
    			// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
    			// The Browser also has localStorage in the global context.
    			return localStorage;
    		} catch (error) {
    			// Swallow
    			// XXX (@Qix-) should we be logging these?
    		}
    	}

    	module.exports = common(exports);

    	const {formatters} = module.exports;

    	/**
    	 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
    	 */

    	formatters.j = function (v) {
    		try {
    			return JSON.stringify(v);
    		} catch (error) {
    			return '[UnexpectedJSONParseError]: ' + error.message;
    		}
    	}; 
    } (browser, browser.exports));

    var browserExports = browser.exports;
    var createDebug = /*@__PURE__*/getDefaultExportFromCjs(browserExports);

    /* node_modules\svelte-recaptcha-v2\src\Recaptcha.svelte generated by Svelte v3.59.2 */

    const { console: console_1 } = globals;
    const file$8 = "node_modules\\svelte-recaptcha-v2\\src\\Recaptcha.svelte";

    function create_fragment$9(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "id", "googleRecaptchaDiv");
    			attr_dev(div, "class", "g-recaptcha");
    			add_location(div, file$8, 330, 0, 10340);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		p: noop$1,
    		i: noop$1,
    		o: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$9.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    let recaptcha;
    let observer = defer();

    function instance$9($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Recaptcha', slots, []);
    	const dbg = createDebug("{Recaptcha}");
    	const debug = dbg;
    	const dispatch = createEventDispatcher();
    	let { sitekey } = $$props;
    	let { badge = "top" } = $$props;
    	let { size = "invisible" } = $$props;
    	let { sleepTime = 0 } = $$props;

    	/*wait time before starting injection*/
    	let instanceId = null;

    	/*behold the recaptcha instance*/
    	let retryTimer = null;

    	/*setInterval tracker for captcha*/
    	let wait = null;

    	/*promise to wait*/
    	let recaptchaModal = null;

    	/*div that houses recaptcha iframe*/
    	let iframeSrc = "google.com/recaptcha/api2/bframe";

    	/*src path of google's injected iframe - used with the timer*/
    	let openObserver = null;

    	/*observer tracker*/
    	let closeObserver = null;

    	/*observer tracker*/
    	/*---------------------------------------------| dispatchers |--*/
    	const eventEmitters = {
    		onExpired: async () => {
    			debug("expired?");
    			recaptcha.reset(instanceId);
    		},
    		onError: async err => {
    			const debug = dbg.extend("onError");
    			debug("an error occured during initialization");
    			dispatch("error", { msg: "please check your site key" });
    			captcha.errors.push("empty");
    			recaptcha.reset(instanceId);
    		},
    		onSuccess: async token => {
    			const debug = dbg.extend("onSuccess");
    			debug("dispatching success, we have a token");
    			dispatch("success", { msg: "ok", token });
    			setTimeout(() => recaptcha.reset(instanceId), 1000);
    			debug("resetting, google needs allowed time if visible recaptcha..");
    			observer = defer();
    			debug("resetting observer");
    		},
    		onReady: () => {
    			const debug = dbg.extend("onReady");
    			dispatch("ready");
    			debug("captcha is ready and available in DOM");
    		},
    		onOpen: mutations => {
    			const debug = dbg.extend("onOpen");
    			dispatch("open");
    			debug("captcha decided to ask a challange");
    		},
    		onClose: mutations => {
    			const debug = dbg.extend("onClose");

    			if (browser$1 && mutations.length === 1 && !window.grecaptcha.getResponse()) {
    				debug("captcha window was closed");
    				dispatch("close");
    			} /*
       close mutation fires twice, probably because
       of event bubbling or something. we also want
       to avoid signalling when user solves the captcha.
       */
    		}
    	}; /*
        these emitters are referenced to google recaptcha so
        we can track its status through svelte.
        */

    	/*------------------------------------------| event-handlers |--*/
    	const captcha = {
    		ready: false,
    		/*captcha loading state*/
    		errors: [],
    		retryTimer: false,
    		/*setInterval timer to update state*/
    		isLoaded: () => {
    			const debug = dbg.extend("isLoaded");

    			captcha.ready = browser$1 && window && window.grecaptcha && window.grecaptcha.ready && document.getElementsByTagName("iframe").find(x => {
    				return x.src.includes(iframeSrc);
    			})
    			? true
    			: false;

    			debug("captcha.isLoaded(): " + captcha.ready);
    			return captcha.ready;
    		},
    		stopTimer: () => {
    			const debug = dbg.extend("stopTimer");
    			debug("stopping timer");
    			clearInterval(captcha.retryTimer);
    		},
    		startTimer: () => {
    			const debug = dbg.extend("startTimer");
    			debug("check in 1s intervals");

    			captcha.retryTimer = setInterval(
    				() => {
    					debug("checking every second");

    					if (captcha.isLoaded()) {
    						captcha.stopTimer();
    						captcha.modal();
    						captcha.openHandle();
    						captcha.closeHandle();
    						eventEmitters.onReady();
    					}

    					if (captcha.errors.length > 3) {
    						captcha.wipe();
    						debug("too many errors, no recaptcha for you at this  time");
    					}
    				},
    				1000
    			);
    		},
    		modal: () => {
    			const debug = dbg.extend("modal");
    			debug("finding recaptcha iframe");
    			const iframe = document.getElementsByTagName("iframe");

    			recaptchaModal = iframe.find(x => {
    				return x.src.includes(iframeSrc);
    			}).parentNode.parentNode;
    		},
    		openHandle: () => {
    			const debug = dbg.extend("openHandler");
    			debug("adding observer");

    			openObserver = new MutationObserver(x => {
    					return recaptchaModal.style.opacity == 1 && eventEmitters.onOpen(x);
    				});

    			openObserver.observe(recaptchaModal, {
    				attributes: true,
    				attributeFilter: ["style"]
    			});
    		},
    		closeHandle: () => {
    			const debug = dbg.extend("closeHandle");
    			debug("adding observer");

    			closeObserver = new MutationObserver(x => {
    					return recaptchaModal.style.opacity == 0 && eventEmitters.onClose(x);
    				});

    			closeObserver.observe(recaptchaModal, {
    				attributes: true,
    				attributeFilter: ["style"]
    			});
    		},
    		inject: () => {
    			const debug = dbg.extend("inject");
    			debug("initializing API, merging google API to svelte recaptcha");
    			recaptcha = window.grecaptcha;

    			/*
     associate window component to svelte, this allows us
     to export grecaptcha methods in parent components.
     */
    			window.grecaptcha.ready(() => {
    				instanceId = grecaptcha.render("googleRecaptchaDiv", {
    					badge,
    					sitekey,
    					"callback": eventEmitters.onSuccess,
    					"expired-callback": eventEmitters.onExpired,
    					"error-callback": eventEmitters.onError,
    					size
    				});
    			});
    		},
    		wipe: () => {
    			const debug = dbg.extend("onDestroy");

    			try {
    				if (browser$1) {
    					clearInterval(captcha.retryTimer);
    					debug("cleaning up clearInterval");

    					if (recaptcha) {
    						recaptcha.reset(instanceId);
    						debug("resetting captcha api");
    						delete window.grecaptcha;
    						delete window.apiLoaded;
    						delete window.recaptchaCloseListener;
    						debug("deleting window.grecaptcha");
    						if (openObserver) openObserver.disconnect();
    						if (closeObserver) closeObserver.disconnect();

    						document.querySelectorAll("script[src*=recaptcha]").forEach(script => {
    							script.remove();
    							debug("deleting google script tag");
    						});

    						document.querySelectorAll("iframe[src*=recaptcha]").forEach(iframe => {
    							iframe.remove();
    							debug("deleting google iframe");
    						});
    					}
    				}
    			} catch(err) {
    				console.log(err.message);
    			} /*
       extremely important to cleanup our mess, otherwise
       everytime the component is invoked, a new recaptcha
       iframe will get instated. Also, with SSR we need to
       make sure all this stuff is wrapped within browser.
       */
    		}
    	};

    	const apiLoaded = async () => {
    		const debug = dbg.extend("apiLoaded");
    		debug("invoked, resolving deferred promise");
    		wait.resolve(true);
    	};

    	onMount(async () => {
    		const debug = dbg.extend("onMount");
    		if (browser$1) window.apiLoaded = apiLoaded;
    		debug("associate apiLoad to window object");

    		if (sleepTime) {
    			debug("sleeping for a bit before inserting recaptcha script");
    			await sleep(sleepTime);
    		}

    		if (browser$1) {
    			const script = document.createElement("script");
    			script.id = "googleRecaptchaScript";
    			script.src = `https://www.google.com/recaptcha/api.js?render=explicit&sitekey{sitekey}&onload=apiLoaded`;
    			script.async = true;
    			script.defer = true;
    			document.head.appendChild(script);
    		}

    		wait = defer();
    		debug("waiting for google api to finish loading");
    		await Promise.resolve(wait);
    		debug("deferred promise was resolved...");
    		if (browser$1) captcha.inject();
    		debug("injecting captcha code");
    		if (browser$1) HTMLCollection.prototype.find = Array.prototype.find;

    		/*needed to detect iframe for open, close events*/
    		captcha.startTimer();

    		debug("polling for captcha to appear in DOM");
    	});

    	onDestroy(async () => {
    		dbg.extend("onDestroy");
    		captcha.wipe();
    	});

    	const sleep = seconds => new Promise(resolve => setTimeout(resolve, seconds * 1000)).catch(err => console.log("caught"));

    	$$self.$$.on_mount.push(function () {
    		if (sitekey === undefined && !('sitekey' in $$props || $$self.$$.bound[$$self.$$.props['sitekey']])) {
    			console_1.warn("<Recaptcha> was created without expected prop 'sitekey'");
    		}
    	});

    	const writable_props = ['sitekey', 'badge', 'size', 'sleepTime'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn(`<Recaptcha> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('sitekey' in $$props) $$invalidate(0, sitekey = $$props.sitekey);
    		if ('badge' in $$props) $$invalidate(1, badge = $$props.badge);
    		if ('size' in $$props) $$invalidate(2, size = $$props.size);
    		if ('sleepTime' in $$props) $$invalidate(3, sleepTime = $$props.sleepTime);
    	};

    	$$self.$capture_state = () => ({
    		defer,
    		recaptcha,
    		observer,
    		createEventDispatcher,
    		onMount,
    		onDestroy,
    		createDebug,
    		browser: browser$1,
    		dbg,
    		debug,
    		dispatch,
    		sitekey,
    		badge,
    		size,
    		sleepTime,
    		instanceId,
    		retryTimer,
    		wait,
    		recaptchaModal,
    		iframeSrc,
    		openObserver,
    		closeObserver,
    		eventEmitters,
    		captcha,
    		apiLoaded,
    		sleep
    	});

    	$$self.$inject_state = $$props => {
    		if ('sitekey' in $$props) $$invalidate(0, sitekey = $$props.sitekey);
    		if ('badge' in $$props) $$invalidate(1, badge = $$props.badge);
    		if ('size' in $$props) $$invalidate(2, size = $$props.size);
    		if ('sleepTime' in $$props) $$invalidate(3, sleepTime = $$props.sleepTime);
    		if ('instanceId' in $$props) instanceId = $$props.instanceId;
    		if ('retryTimer' in $$props) retryTimer = $$props.retryTimer;
    		if ('wait' in $$props) wait = $$props.wait;
    		if ('recaptchaModal' in $$props) recaptchaModal = $$props.recaptchaModal;
    		if ('iframeSrc' in $$props) iframeSrc = $$props.iframeSrc;
    		if ('openObserver' in $$props) openObserver = $$props.openObserver;
    		if ('closeObserver' in $$props) closeObserver = $$props.closeObserver;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [sitekey, badge, size, sleepTime];
    }

    class Recaptcha extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$9, create_fragment$9, safe_not_equal, {
    			sitekey: 0,
    			badge: 1,
    			size: 2,
    			sleepTime: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Recaptcha",
    			options,
    			id: create_fragment$9.name
    		});
    	}

    	get sitekey() {
    		throw new Error("<Recaptcha>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sitekey(value) {
    		throw new Error("<Recaptcha>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get badge() {
    		throw new Error("<Recaptcha>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set badge(value) {
    		throw new Error("<Recaptcha>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error("<Recaptcha>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<Recaptcha>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sleepTime() {
    		throw new Error("<Recaptcha>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sleepTime(value) {
    		throw new Error("<Recaptcha>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    function updateValidity(object, value, valid) {
        object.value = value;
        object.valid = valid;
    }
    const firstName = {
        value: undefined,
        valid: false,
    };
    const lastName = {
        value: undefined,
        valid: false,
    };
    const email = {
        value: undefined,
        valid: false,
    };
    const phone = {
        value: undefined,
        valid: false,
    };
    const subject = {
        value: undefined,
        valid: false,
    };
    const message = {
        value: undefined,
        valid: false,
    };

    /* src\Pages\Default\Contact\ContactForm.svelte generated by Svelte v3.59.2 */

    const file$7 = "src\\Pages\\Default\\Contact\\ContactForm.svelte";

    // (139:12) {:else}
    function create_else_block(ctx) {
    	let recaptcha;
    	let current;

    	recaptcha = new Recaptcha({
    			props: {
    				sitekey: "6LezsNMqAAAAACJzRSKBytTCjIU5ClHsTirQenV7",
    				size: "normal"
    			},
    			$$inline: true
    		});

    	recaptcha.$on("success", /*captchaCleared*/ ctx[2]);

    	const block = {
    		c: function create() {
    			create_component(recaptcha.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(recaptcha, target, anchor);
    			current = true;
    		},
    		p: noop$1,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(recaptcha.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(recaptcha.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(recaptcha, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block.name,
    		type: "else",
    		source: "(139:12) {:else}",
    		ctx
    	});

    	return block;
    }

    // (135:36) 
    function create_if_block_1(ctx) {
    	let button;

    	const block = {
    		c: function create() {
    			button = element("button");
    			button.textContent = "Versturen";
    			attr_dev(button, "type", "submit");
    			attr_dev(button, "class", "py-2 px-4 border-sky-600 bg-sky-400 text-white rounded-lg");
    			add_location(button, file$7, 135, 16, 4802);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    		},
    		p: noop$1,
    		i: noop$1,
    		o: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1.name,
    		type: "if",
    		source: "(135:36) ",
    		ctx
    	});

    	return block;
    }

    // (100:12) {#if isLoading}
    function create_if_block$1(ctx) {
    	let button;
    	let svg;
    	let g1;
    	let circle;
    	let animateTransform;
    	let g0;

    	const block = {
    		c: function create() {
    			button = element("button");
    			svg = svg_element("svg");
    			g1 = svg_element("g");
    			circle = svg_element("circle");
    			animateTransform = svg_element("animateTransform");
    			g0 = svg_element("g");
    			attr_dev(animateTransform, "keyTimes", "0;1");
    			attr_dev(animateTransform, "values", "0 50 50;360 50 50");
    			attr_dev(animateTransform, "dur", "1s");
    			attr_dev(animateTransform, "repeatCount", "indefinite");
    			attr_dev(animateTransform, "type", "rotate");
    			attr_dev(animateTransform, "attributeName", "transform");
    			add_location(animateTransform, file$7, 121, 32, 4176);
    			attr_dev(circle, "stroke-dasharray", "164.93361431346415 56.97787143782138");
    			attr_dev(circle, "r", "35");
    			attr_dev(circle, "stroke-width", "10");
    			attr_dev(circle, "stroke", "white");
    			attr_dev(circle, "fill", "none");
    			attr_dev(circle, "cy", "50");
    			attr_dev(circle, "cx", "50");
    			add_location(circle, file$7, 112, 28, 3749);
    			add_location(g0, file$7, 130, 28, 4654);
    			add_location(g1, file$7, 111, 24, 3716);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "viewBox", "0 0 100 100");
    			attr_dev(svg, "preserveAspectRatio", "xMidYMid");
    			attr_dev(svg, "width", "50");
    			attr_dev(svg, "height", "50");
    			set_style(svg, "shape-rendering", "auto");
    			set_style(svg, "display", "block");
    			add_location(svg, file$7, 103, 20, 3355);
    			attr_dev(button, "class", "mt-3 py-2 px-4 border-sky-600 bg-sky-400 text-white rounded-lg");
    			add_location(button, file$7, 100, 16, 3215);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, svg);
    			append_dev(svg, g1);
    			append_dev(g1, circle);
    			append_dev(circle, animateTransform);
    			append_dev(g1, g0);
    		},
    		p: noop$1,
    		i: noop$1,
    		o: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$1.name,
    		type: "if",
    		source: "(100:12) {#if isLoading}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$8(ctx) {
    	let form;
    	let span;
    	let t1;
    	let div7;
    	let div0;
    	let formfield0;
    	let t2;
    	let div1;
    	let formfield1;
    	let t3;
    	let div2;
    	let formfield2;
    	let t4;
    	let div3;
    	let formfield3;
    	let t5;
    	let div4;
    	let formfield4;
    	let t6;
    	let div5;
    	let formfield5;
    	let t7;
    	let div6;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	let mounted;
    	let dispose;

    	formfield0 = new FormField({
    			props: {
    				onchange: /*func*/ ctx[4],
    				name: "voornaam"
    			},
    			$$inline: true
    		});

    	formfield1 = new FormField({
    			props: {
    				onchange: /*func_1*/ ctx[5],
    				name: "achternaam"
    			},
    			$$inline: true
    		});

    	formfield2 = new FormField({
    			props: {
    				onchange: /*func_2*/ ctx[6],
    				type: "email",
    				name: "Uw email"
    			},
    			$$inline: true
    		});

    	formfield3 = new FormField({
    			props: {
    				onchange: /*func_3*/ ctx[7],
    				type: "tel",
    				name: "Uw telefoonnummer",
    				required: false
    			},
    			$$inline: true
    		});

    	formfield4 = new FormField({
    			props: {
    				onchange: /*func_4*/ ctx[8],
    				maxLength: 200,
    				name: "Onderwerp"
    			},
    			$$inline: true
    		});

    	formfield5 = new FormField({
    			props: {
    				type: "longtext",
    				onchange: /*func_5*/ ctx[9],
    				name: "Bericht",
    				required: true
    			},
    			$$inline: true
    		});

    	const if_block_creators = [create_if_block$1, create_if_block_1, create_else_block];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*isLoading*/ ctx[0]) return 0;
    		if (/*showSubmitBtn*/ ctx[1]) return 1;
    		return 2;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			form = element("form");
    			span = element("span");
    			span.textContent = "* Verplichte velden";
    			t1 = space();
    			div7 = element("div");
    			div0 = element("div");
    			create_component(formfield0.$$.fragment);
    			t2 = space();
    			div1 = element("div");
    			create_component(formfield1.$$.fragment);
    			t3 = space();
    			div2 = element("div");
    			create_component(formfield2.$$.fragment);
    			t4 = space();
    			div3 = element("div");
    			create_component(formfield3.$$.fragment);
    			t5 = space();
    			div4 = element("div");
    			create_component(formfield4.$$.fragment);
    			t6 = space();
    			div5 = element("div");
    			create_component(formfield5.$$.fragment);
    			t7 = space();
    			div6 = element("div");
    			if_block.c();
    			attr_dev(span, "class", "text-gray-500 ml-2");
    			add_location(span, file$7, 44, 4, 1498);
    			attr_dev(div0, "class", "w-1/2");
    			add_location(div0, file$7, 46, 8, 1615);
    			attr_dev(div1, "class", "w-1/2");
    			add_location(div1, file$7, 54, 8, 1842);
    			attr_dev(div2, "class", "w-full");
    			add_location(div2, file$7, 62, 8, 2070);
    			attr_dev(div3, "class", "w-full");
    			add_location(div3, file$7, 70, 8, 2303);
    			attr_dev(div4, "class", "w-full");
    			add_location(div4, file$7, 79, 8, 2577);
    			attr_dev(div5, "class", "w-full");
    			add_location(div5, file$7, 88, 8, 2837);
    			attr_dev(div6, "class", "w-full flex justify-center");
    			add_location(div6, file$7, 98, 8, 3128);
    			attr_dev(div7, "class", "w-full h-full flex flex-wrap");
    			add_location(div7, file$7, 45, 4, 1563);
    			attr_dev(form, "action", "");
    			attr_dev(form, "method", "get");
    			attr_dev(form, "class", "p-2");
    			add_location(form, file$7, 43, 0, 1432);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, form, anchor);
    			append_dev(form, span);
    			append_dev(form, t1);
    			append_dev(form, div7);
    			append_dev(div7, div0);
    			mount_component(formfield0, div0, null);
    			append_dev(div7, t2);
    			append_dev(div7, div1);
    			mount_component(formfield1, div1, null);
    			append_dev(div7, t3);
    			append_dev(div7, div2);
    			mount_component(formfield2, div2, null);
    			append_dev(div7, t4);
    			append_dev(div7, div3);
    			mount_component(formfield3, div3, null);
    			append_dev(div7, t5);
    			append_dev(div7, div4);
    			mount_component(formfield4, div4, null);
    			append_dev(div7, t6);
    			append_dev(div7, div5);
    			mount_component(formfield5, div5, null);
    			append_dev(div7, t7);
    			append_dev(div7, div6);
    			if_blocks[current_block_type_index].m(div6, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(form, "submit", /*submit*/ ctx[3], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div6, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(formfield0.$$.fragment, local);
    			transition_in(formfield1.$$.fragment, local);
    			transition_in(formfield2.$$.fragment, local);
    			transition_in(formfield3.$$.fragment, local);
    			transition_in(formfield4.$$.fragment, local);
    			transition_in(formfield5.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(formfield0.$$.fragment, local);
    			transition_out(formfield1.$$.fragment, local);
    			transition_out(formfield2.$$.fragment, local);
    			transition_out(formfield3.$$.fragment, local);
    			transition_out(formfield4.$$.fragment, local);
    			transition_out(formfield5.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(form);
    			destroy_component(formfield0);
    			destroy_component(formfield1);
    			destroy_component(formfield2);
    			destroy_component(formfield3);
    			destroy_component(formfield4);
    			destroy_component(formfield5);
    			if_blocks[current_block_type_index].d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$8.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$8($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ContactForm', slots, []);
    	let isLoading = false;
    	let showSubmitBtn = false;

    	function captchaCleared() {
    		$$invalidate(1, showSubmitBtn = true);
    	}

    	async function submit(event) {
    		event.preventDefault();
    		const validationArr = [message, subject, phone, email, lastName, firstName];

    		if (validationArr.some(e => !e.valid)) {
    			return;
    		}

    		$$invalidate(0, isLoading = true);
    		var context = new ApiContext();

    		var result = await context.submitContactForm({
    			message: message.value,
    			subject: subject.value,
    			phone: phone.value,
    			email: email.value,
    			name: (firstName.value + " " + lastName.value).trim()
    		});

    		await Swal.fire({
    			title: result ? "Verstuurd!" : "Er is iets fout gegaan",
    			text: result
    			? "Je bericht is aangekomen. Binnen een paar dagen zullen we contact met je opnemen"
    			: "We kunnen je bericht op het moment niet versturen. Probeer het later opnieuw.",
    			icon: result ? "success" : "error"
    		});

    		$$invalidate(0, isLoading = false);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ContactForm> was created with unknown prop '${key}'`);
    	});

    	const func = (value, valid) => updateValidity(firstName, value, valid);
    	const func_1 = (value, valid) => updateValidity(lastName, value, valid);
    	const func_2 = (value, valid) => updateValidity(email, value, valid);
    	const func_3 = (value, valid) => updateValidity(phone, value, valid);
    	const func_4 = (value, valid) => updateValidity(message, value, valid);
    	const func_5 = (value, valid) => updateValidity(subject, value, valid);

    	$$self.$capture_state = () => ({
    		FormField,
    		ApiContext,
    		Swal,
    		Recaptcha,
    		message,
    		subject,
    		phone,
    		email,
    		lastName,
    		firstName,
    		updateValidity,
    		isLoading,
    		showSubmitBtn,
    		captchaCleared,
    		submit
    	});

    	$$self.$inject_state = $$props => {
    		if ('isLoading' in $$props) $$invalidate(0, isLoading = $$props.isLoading);
    		if ('showSubmitBtn' in $$props) $$invalidate(1, showSubmitBtn = $$props.showSubmitBtn);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		isLoading,
    		showSubmitBtn,
    		captchaCleared,
    		submit,
    		func,
    		func_1,
    		func_2,
    		func_3,
    		func_4,
    		func_5
    	];
    }

    class ContactForm extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$8, create_fragment$8, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ContactForm",
    			options,
    			id: create_fragment$8.name
    		});
    	}
    }

    /* src\Pages\Default\Contact\ContactPage.svelte generated by Svelte v3.59.2 */
    const file$6 = "src\\Pages\\Default\\Contact\\ContactPage.svelte";

    function create_fragment$7(ctx) {
    	let div;
    	let h1;
    	let t1;
    	let contactform;
    	let current;
    	contactform = new ContactForm({ $$inline: true });

    	const block = {
    		c: function create() {
    			div = element("div");
    			h1 = element("h1");
    			h1.textContent = "Contact opnemen met Sil Gosker";
    			t1 = space();
    			create_component(contactform.$$.fragment);
    			attr_dev(h1, "class", "text-center text-2xl w-full text-gray-900");
    			add_location(h1, file$6, 6, 4, 133);
    			attr_dev(div, "class", "flex flex-col justify-center w-full");
    			add_location(div, file$6, 5, 0, 78);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, h1);
    			append_dev(div, t1);
    			mount_component(contactform, div, null);
    			current = true;
    		},
    		p: noop$1,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(contactform.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(contactform.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(contactform);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$7.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$7($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ContactPage', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ContactPage> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ ContactForm });
    	return [];
    }

    class ContactPage extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$7, create_fragment$7, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ContactPage",
    			options,
    			id: create_fragment$7.name
    		});
    	}
    }

    /*!
     * Glide.js v3.7.1
     * (c) 2013-2024 Jdrzej Chaubek (https://github.com/jedrzejchalubek/)
     * Released under the MIT License.
     */

    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);

      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);

        if (enumerableOnly) {
          symbols = symbols.filter(function (sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        }

        keys.push.apply(keys, symbols);
      }

      return keys;
    }

    function _objectSpread2(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};

        if (i % 2) {
          ownKeys(Object(source), true).forEach(function (key) {
            _defineProperty(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function (key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }

      return target;
    }

    function _typeof(obj) {
      "@babel/helpers - typeof";

      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function (obj) {
          return typeof obj;
        };
      } else {
        _typeof = function (obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
      }

      return _typeof(obj);
    }

    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      return Constructor;
    }

    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }

    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }

      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass) _setPrototypeOf(subClass, superClass);
    }

    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf(o);
    }

    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };

      return _setPrototypeOf(o, p);
    }

    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;

      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
        return true;
      } catch (e) {
        return false;
      }
    }

    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return self;
    }

    function _possibleConstructorReturn(self, call) {
      if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
      } else if (call !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
      }

      return _assertThisInitialized(self);
    }

    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();

      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived),
            result;

        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;

          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }

        return _possibleConstructorReturn(this, result);
      };
    }

    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (object === null) break;
      }

      return object;
    }

    function _get() {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
      } else {
        _get = function _get(target, property, receiver) {
          var base = _superPropBase(target, property);

          if (!base) return;
          var desc = Object.getOwnPropertyDescriptor(base, property);

          if (desc.get) {
            return desc.get.call(arguments.length < 3 ? target : receiver);
          }

          return desc.value;
        };
      }

      return _get.apply(this, arguments);
    }

    var defaults = {
      /**
       * Type of the movement.
       *
       * Available types:
       * `slider` - Rewinds slider to the start/end when it reaches the first or last slide.
       * `carousel` - Changes slides without starting over when it reaches the first or last slide.
       *
       * @type {String}
       */
      type: 'slider',

      /**
       * Start at specific slide number defined with zero-based index.
       *
       * @type {Number}
       */
      startAt: 0,

      /**
       * A number of slides visible on the single viewport.
       *
       * @type {Number}
       */
      perView: 1,

      /**
       * Focus currently active slide at a specified position in the track.
       *
       * Available inputs:
       * `center` - Current slide will be always focused at the center of a track.
       * `0,1,2,3...` - Current slide will be focused on the specified zero-based index.
       *
       * @type {String|Number}
       */
      focusAt: 0,

      /**
       * A size of the gap added between slides.
       *
       * @type {Number}
       */
      gap: 10,

      /**
       * Change slides after a specified interval. Use `false` for turning off autoplay.
       *
       * @type {Number|Boolean}
       */
      autoplay: false,

      /**
       * Stop autoplay on mouseover event.
       *
       * @type {Boolean}
       */
      hoverpause: true,

      /**
       * Allow for changing slides with left and right keyboard arrows.
       *
       * @type {Boolean}
       */
      keyboard: true,

      /**
       * Stop running `perView` number of slides from the end. Use this
       * option if you don't want to have an empty space after
       * a slider. Works only with `slider` type and a
       * non-centered `focusAt` setting.
       *
       * @type {Boolean}
       */
      bound: false,

      /**
       * Minimal swipe distance needed to change the slide. Use `false` for turning off a swiping.
       *
       * @type {Number|Boolean}
       */
      swipeThreshold: 80,

      /**
       * Minimal mouse drag distance needed to change the slide. Use `false` for turning off a dragging.
       *
       * @type {Number|Boolean}
       */
      dragThreshold: 120,

      /**
       * A number of slides moved on single swipe.
       *
       * Available types:
       * `` - Moves slider by one slide per swipe
       * `|` - Moves slider between views per swipe (number of slides defined in `perView` options)
       *
       * @type {String}
       */
      perSwipe: '',

      /**
       * Moving distance ratio of the slides on a swiping and dragging.
       *
       * @type {Number}
       */
      touchRatio: 0.5,

      /**
       * Angle required to activate slides moving on swiping or dragging.
       *
       * @type {Number}
       */
      touchAngle: 45,

      /**
       * Duration of the animation in milliseconds.
       *
       * @type {Number}
       */
      animationDuration: 400,

      /**
       * Allows looping the `slider` type. Slider will rewind to the first/last slide when it's at the start/end.
       *
       * @type {Boolean}
       */
      rewind: true,

      /**
       * Duration of the rewinding animation of the `slider` type in milliseconds.
       *
       * @type {Number}
       */
      rewindDuration: 800,

      /**
       * Easing function for the animation.
       *
       * @type {String}
       */
      animationTimingFunc: 'cubic-bezier(.165, .840, .440, 1)',

      /**
       * Wait for the animation to finish until the next user input can be processed
       *
       * @type {boolean}
       */
      waitForTransition: true,

      /**
       * Throttle costly events at most once per every wait milliseconds.
       *
       * @type {Number}
       */
      throttle: 10,

      /**
       * Moving direction mode.
       *
       * Available inputs:
       * - 'ltr' - left to right movement,
       * - 'rtl' - right to left movement.
       *
       * @type {String}
       */
      direction: 'ltr',

      /**
       * The distance value of the next and previous viewports which
       * have to peek in the current view. Accepts number and
       * pixels as a string. Left and right peeking can be
       * set up separately with a directions object.
       *
       * For example:
       * `100` - Peek 100px on the both sides.
       * { before: 100, after: 50 }` - Peek 100px on the left side and 50px on the right side.
       *
       * @type {Number|String|Object}
       */
      peek: 0,

      /**
       * Defines how many clones of current viewport will be generated.
       *
       * @type {Number}
       */
      cloningRatio: 1,

      /**
       * Collection of options applied at specified media breakpoints.
       * For example: display two slides per view under 800px.
       * `{
       *   '800px': {
       *     perView: 2
       *   }
       * }`
       */
      breakpoints: {},

      /**
       * Collection of internally used HTML classes.
       *
       * @todo Refactor `slider` and `carousel` properties to single `type: { slider: '', carousel: '' }` object
       * @type {Object}
       */
      classes: {
        swipeable: 'glide--swipeable',
        dragging: 'glide--dragging',
        direction: {
          ltr: 'glide--ltr',
          rtl: 'glide--rtl'
        },
        type: {
          slider: 'glide--slider',
          carousel: 'glide--carousel'
        },
        slide: {
          clone: 'glide__slide--clone',
          active: 'glide__slide--active'
        },
        arrow: {
          disabled: 'glide__arrow--disabled'
        },
        nav: {
          active: 'glide__bullet--active'
        }
      }
    };

    /**
     * Outputs warning message to the bowser console.
     *
     * @param  {String} msg
     * @return {Void}
     */
    function warn(msg) {
      console.error("[Glide warn]: ".concat(msg));
    }

    /**
     * Converts value entered as number
     * or string to integer value.
     *
     * @param {String} value
     * @returns {Number}
     */
    function toInt(value) {
      return parseInt(value);
    }
    /**
     * Converts value entered as number
     * or string to flat value.
     *
     * @param {String} value
     * @returns {Number}
     */

    function toFloat(value) {
      return parseFloat(value);
    }
    /**
     * Indicates whether the specified value is a string.
     *
     * @param  {*}   value
     * @return {Boolean}
     */

    function isString(value) {
      return typeof value === 'string';
    }
    /**
     * Indicates whether the specified value is an object.
     *
     * @param  {*} value
     * @return {Boolean}
     *
     * @see https://github.com/jashkenas/underscore
     */

    function isObject(value) {
      var type = _typeof(value);

      return type === 'function' || type === 'object' && !!value; // eslint-disable-line no-mixed-operators
    }
    /**
     * Indicates whether the specified value is a function.
     *
     * @param  {*} value
     * @return {Boolean}
     */

    function isFunction(value) {
      return typeof value === 'function';
    }
    /**
     * Indicates whether the specified value is undefined.
     *
     * @param  {*} value
     * @return {Boolean}
     */

    function isUndefined(value) {
      return typeof value === 'undefined';
    }
    /**
     * Indicates whether the specified value is an array.
     *
     * @param  {*} value
     * @return {Boolean}
     */

    function isArray(value) {
      return value.constructor === Array;
    }

    /**
     * Creates and initializes specified collection of extensions.
     * Each extension receives access to instance of glide and rest of components.
     *
     * @param {Object} glide
     * @param {Object} extensions
     *
     * @returns {Object}
     */

    function mount(glide, extensions, events) {
      var components = {};

      for (var name in extensions) {
        if (isFunction(extensions[name])) {
          components[name] = extensions[name](glide, components, events);
        } else {
          warn('Extension must be a function');
        }
      }

      for (var _name in components) {
        if (isFunction(components[_name].mount)) {
          components[_name].mount();
        }
      }

      return components;
    }

    /**
     * Defines getter and setter property on the specified object.
     *
     * @param  {Object} obj         Object where property has to be defined.
     * @param  {String} prop        Name of the defined property.
     * @param  {Object} definition  Get and set definitions for the property.
     * @return {Void}
     */
    function define(obj, prop, definition) {
      Object.defineProperty(obj, prop, definition);
    }
    /**
     * Sorts aphabetically object keys.
     *
     * @param  {Object} obj
     * @return {Object}
     */

    function sortKeys(obj) {
      return Object.keys(obj).sort().reduce(function (r, k) {
        r[k] = obj[k];
        return r[k], r;
      }, {});
    }
    /**
     * Merges passed settings object with default options.
     *
     * @param  {Object} defaults
     * @param  {Object} settings
     * @return {Object}
     */

    function mergeOptions(defaults, settings) {
      var options = Object.assign({}, defaults, settings); // `Object.assign` do not deeply merge objects, so we
      // have to do it manually for every nested object
      // in options. Although it does not look smart,
      // it's smaller and faster than some fancy
      // merging deep-merge algorithm script.

      if (settings.hasOwnProperty('classes')) {
        options.classes = Object.assign({}, defaults.classes, settings.classes);
        var properties = ['direction', 'type', 'slide', 'arrow', 'nav'];
        properties.forEach(function (property) {
          if (settings.classes.hasOwnProperty(property)) {
            options.classes[property] = _objectSpread2(_objectSpread2({}, defaults.classes[property]), settings.classes[property]);
          }
        });
      }

      if (settings.hasOwnProperty('breakpoints')) {
        options.breakpoints = Object.assign({}, defaults.breakpoints, settings.breakpoints);
      }

      return options;
    }

    var EventsBus = /*#__PURE__*/function () {
      /**
       * Construct a EventBus instance.
       *
       * @param {Object} events
       */
      function EventsBus() {
        var events = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck(this, EventsBus);

        this.events = events;
        this.hop = events.hasOwnProperty;
      }
      /**
       * Adds listener to the specifed event.
       *
       * @param {String|Array} event
       * @param {Function} handler
       */


      _createClass(EventsBus, [{
        key: "on",
        value: function on(event, handler) {
          if (isArray(event)) {
            for (var i = 0; i < event.length; i++) {
              this.on(event[i], handler);
            }

            return;
          } // Create the event's object if not yet created


          if (!this.hop.call(this.events, event)) {
            this.events[event] = [];
          } // Add the handler to queue


          var index = this.events[event].push(handler) - 1; // Provide handle back for removal of event

          return {
            remove: function remove() {
              delete this.events[event][index];
            }
          };
        }
        /**
         * Runs registered handlers for specified event.
         *
         * @param {String|Array} event
         * @param {Object=} context
         */

      }, {
        key: "emit",
        value: function emit(event, context) {
          if (isArray(event)) {
            for (var i = 0; i < event.length; i++) {
              this.emit(event[i], context);
            }

            return;
          } // If the event doesn't exist, or there's no handlers in queue, just leave


          if (!this.hop.call(this.events, event)) {
            return;
          } // Cycle through events queue, fire!


          this.events[event].forEach(function (item) {
            item(context || {});
          });
        }
      }]);

      return EventsBus;
    }();

    var Glide$1 = /*#__PURE__*/function () {
      /**
       * Construct glide.
       *
       * @param  {String} selector
       * @param  {Object} options
       */
      function Glide(selector) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        _classCallCheck(this, Glide);

        this._c = {};
        this._t = [];
        this._e = new EventsBus();
        this.disabled = false;
        this.selector = selector;
        this.settings = mergeOptions(defaults, options);
        this.index = this.settings.startAt;
      }
      /**
       * Initializes glide.
       *
       * @param {Object} extensions Collection of extensions to initialize.
       * @return {Glide}
       */


      _createClass(Glide, [{
        key: "mount",
        value: function mount$1() {
          var extensions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

          this._e.emit('mount.before');

          if (isObject(extensions)) {
            this._c = mount(this, extensions, this._e);
          } else {
            warn('You need to provide a object on `mount()`');
          }

          this._e.emit('mount.after');

          return this;
        }
        /**
         * Collects an instance `translate` transformers.
         *
         * @param  {Array} transformers Collection of transformers.
         * @return {Void}
         */

      }, {
        key: "mutate",
        value: function mutate() {
          var transformers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

          if (isArray(transformers)) {
            this._t = transformers;
          } else {
            warn('You need to provide a array on `mutate()`');
          }

          return this;
        }
        /**
         * Updates glide with specified settings.
         *
         * @param {Object} settings
         * @return {Glide}
         */

      }, {
        key: "update",
        value: function update() {
          var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          this.settings = mergeOptions(this.settings, settings);

          if (settings.hasOwnProperty('startAt')) {
            this.index = settings.startAt;
          }

          this._e.emit('update');

          return this;
        }
        /**
         * Change slide with specified pattern. A pattern must be in the special format:
         * `>` - Move one forward
         * `<` - Move one backward
         * `={i}` - Go to {i} zero-based slide (eq. '=1', will go to second slide)
         * `>>` - Rewinds to end (last slide)
         * `<<` - Rewinds to start (first slide)
         * `|>` - Move one viewport forward
         * `|<` - Move one viewport backward
         *
         * @param {String} pattern
         * @return {Glide}
         */

      }, {
        key: "go",
        value: function go(pattern) {
          this._c.Run.make(pattern);

          return this;
        }
        /**
         * Move track by specified distance.
         *
         * @param {String} distance
         * @return {Glide}
         */

      }, {
        key: "move",
        value: function move(distance) {
          this._c.Transition.disable();

          this._c.Move.make(distance);

          return this;
        }
        /**
         * Destroy instance and revert all changes done by this._c.
         *
         * @return {Glide}
         */

      }, {
        key: "destroy",
        value: function destroy() {
          this._e.emit('destroy');

          return this;
        }
        /**
         * Start instance autoplaying.
         *
         * @param {Boolean|Number} interval Run autoplaying with passed interval regardless of `autoplay` settings
         * @return {Glide}
         */

      }, {
        key: "play",
        value: function play() {
          var interval = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

          if (interval) {
            this.settings.autoplay = interval;
          }

          this._e.emit('play');

          return this;
        }
        /**
         * Stop instance autoplaying.
         *
         * @return {Glide}
         */

      }, {
        key: "pause",
        value: function pause() {
          this._e.emit('pause');

          return this;
        }
        /**
         * Sets glide into a idle status.
         *
         * @return {Glide}
         */

      }, {
        key: "disable",
        value: function disable() {
          this.disabled = true;
          return this;
        }
        /**
         * Sets glide into a active status.
         *
         * @return {Glide}
         */

      }, {
        key: "enable",
        value: function enable() {
          this.disabled = false;
          return this;
        }
        /**
         * Adds cuutom event listener with handler.
         *
         * @param  {String|Array} event
         * @param  {Function} handler
         * @return {Glide}
         */

      }, {
        key: "on",
        value: function on(event, handler) {
          this._e.on(event, handler);

          return this;
        }
        /**
         * Checks if glide is a precised type.
         *
         * @param  {String} name
         * @return {Boolean}
         */

      }, {
        key: "isType",
        value: function isType(name) {
          return this.settings.type === name;
        }
        /**
         * Gets value of the core options.
         *
         * @return {Object}
         */

      }, {
        key: "settings",
        get: function get() {
          return this._o;
        }
        /**
         * Sets value of the core options.
         *
         * @param  {Object} o
         * @return {Void}
         */
        ,
        set: function set(o) {
          if (isObject(o)) {
            this._o = o;
          } else {
            warn('Options must be an `object` instance.');
          }
        }
        /**
         * Gets current index of the slider.
         *
         * @return {Object}
         */

      }, {
        key: "index",
        get: function get() {
          return this._i;
        }
        /**
         * Sets current index a slider.
         *
         * @return {Object}
         */
        ,
        set: function set(i) {
          this._i = toInt(i);
        }
        /**
         * Gets type name of the slider.
         *
         * @return {String}
         */

      }, {
        key: "type",
        get: function get() {
          return this.settings.type;
        }
        /**
         * Gets value of the idle status.
         *
         * @return {Boolean}
         */

      }, {
        key: "disabled",
        get: function get() {
          return this._d;
        }
        /**
         * Sets value of the idle status.
         *
         * @return {Boolean}
         */
        ,
        set: function set(status) {
          this._d = !!status;
        }
      }]);

      return Glide;
    }();

    function Run (Glide, Components, Events) {
      var Run = {
        /**
         * Initializes autorunning of the glide.
         *
         * @return {Void}
         */
        mount: function mount() {
          this._o = false;
        },

        /**
         * Makes glides running based on the passed moving schema.
         *
         * @param {String} move
         */
        make: function make(move) {
          var _this = this;

          if (!Glide.disabled) {
            !Glide.settings.waitForTransition || Glide.disable();
            this.move = move;
            Events.emit('run.before', this.move);
            this.calculate();
            Events.emit('run', this.move);
            Components.Transition.after(function () {
              if (_this.isStart()) {
                Events.emit('run.start', _this.move);
              }

              if (_this.isEnd()) {
                Events.emit('run.end', _this.move);
              }

              if (_this.isOffset()) {
                _this._o = false;
                Events.emit('run.offset', _this.move);
              }

              Events.emit('run.after', _this.move);
              Glide.enable();
            });
          }
        },

        /**
         * Calculates current index based on defined move.
         *
         * @return {Number|Undefined}
         */
        calculate: function calculate() {
          var move = this.move,
              length = this.length;
          var steps = move.steps,
              direction = move.direction; // By default assume that size of view is equal to one slide

          var viewSize = 1; // While direction is `=` we want jump to
          // a specified index described in steps.

          if (direction === '=') {
            // Check if bound is true, 
            // as we want to avoid whitespaces.
            if (Glide.settings.bound && toInt(steps) > length) {
              Glide.index = length;
              return;
            }

            Glide.index = steps;
            return;
          } // When pattern is equal to `>>` we want
          // fast forward to the last slide.


          if (direction === '>' && steps === '>') {
            Glide.index = length;
            return;
          } // When pattern is equal to `<<` we want
          // fast forward to the first slide.


          if (direction === '<' && steps === '<') {
            Glide.index = 0;
            return;
          } // pagination movement


          if (direction === '|') {
            viewSize = Glide.settings.perView || 1;
          } // we are moving forward


          if (direction === '>' || direction === '|' && steps === '>') {
            var index = calculateForwardIndex(viewSize);

            if (index > length) {
              this._o = true;
            }

            Glide.index = normalizeForwardIndex(index, viewSize);
            return;
          } // we are moving backward


          if (direction === '<' || direction === '|' && steps === '<') {
            var _index = calculateBackwardIndex(viewSize);

            if (_index < 0) {
              this._o = true;
            }

            Glide.index = normalizeBackwardIndex(_index, viewSize);
            return;
          }

          warn("Invalid direction pattern [".concat(direction).concat(steps, "] has been used"));
        },

        /**
         * Checks if we are on the first slide.
         *
         * @return {Boolean}
         */
        isStart: function isStart() {
          return Glide.index <= 0;
        },

        /**
         * Checks if we are on the last slide.
         *
         * @return {Boolean}
         */
        isEnd: function isEnd() {
          return Glide.index >= this.length;
        },

        /**
         * Checks if we are making a offset run.
         *
         * @param {String} direction
         * @return {Boolean}
         */
        isOffset: function isOffset() {
          var direction = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;

          if (!direction) {
            return this._o;
          }

          if (!this._o) {
            return false;
          } // did we view to the right?


          if (direction === '|>') {
            return this.move.direction === '|' && this.move.steps === '>';
          } // did we view to the left?


          if (direction === '|<') {
            return this.move.direction === '|' && this.move.steps === '<';
          }

          return this.move.direction === direction;
        },

        /**
         * Checks if bound mode is active
         *
         * @return {Boolean}
         */
        isBound: function isBound() {
          return Glide.isType('slider') && Glide.settings.focusAt !== 'center' && Glide.settings.bound;
        }
      };
      /**
       * Returns index value to move forward/to the right
       *
       * @param viewSize
       * @returns {Number}
       */

      function calculateForwardIndex(viewSize) {
        var index = Glide.index;

        if (Glide.isType('carousel')) {
          return index + viewSize;
        }

        return index + (viewSize - index % viewSize);
      }
      /**
       * Normalizes the given forward index based on glide settings, preventing it to exceed certain boundaries
       *
       * @param index
       * @param length
       * @param viewSize
       * @returns {Number}
       */


      function normalizeForwardIndex(index, viewSize) {
        var length = Run.length;

        if (index <= length) {
          return index;
        }

        if (Glide.isType('carousel')) {
          return index - (length + 1);
        }

        if (Glide.settings.rewind) {
          // bound does funny things with the length, therefor we have to be certain
          // that we are on the last possible index value given by bound
          if (Run.isBound() && !Run.isEnd()) {
            return length;
          }

          return 0;
        }

        if (Run.isBound()) {
          return length;
        }

        return Math.floor(length / viewSize) * viewSize;
      }
      /**
       * Calculates index value to move backward/to the left
       *
       * @param viewSize
       * @returns {Number}
       */


      function calculateBackwardIndex(viewSize) {
        var index = Glide.index;

        if (Glide.isType('carousel')) {
          return index - viewSize;
        } // ensure our back navigation results in the same index as a forward navigation
        // to experience a homogeneous paging


        var view = Math.ceil(index / viewSize);
        return (view - 1) * viewSize;
      }
      /**
       * Normalizes the given backward index based on glide settings, preventing it to exceed certain boundaries
       *
       * @param index
       * @param length
       * @param viewSize
       * @returns {*}
       */


      function normalizeBackwardIndex(index, viewSize) {
        var length = Run.length;

        if (index >= 0) {
          return index;
        }

        if (Glide.isType('carousel')) {
          return index + (length + 1);
        }

        if (Glide.settings.rewind) {
          // bound does funny things with the length, therefor we have to be certain
          // that we are on first possible index value before we to rewind to the length given by bound
          if (Run.isBound() && Run.isStart()) {
            return length;
          }

          return Math.floor(length / viewSize) * viewSize;
        }

        return 0;
      }

      define(Run, 'move', {
        /**
         * Gets value of the move schema.
         *
         * @returns {Object}
         */
        get: function get() {
          return this._m;
        },

        /**
         * Sets value of the move schema.
         *
         * @returns {Object}
         */
        set: function set(value) {
          var step = value.substr(1);
          this._m = {
            direction: value.substr(0, 1),
            steps: step ? toInt(step) ? toInt(step) : step : 0
          };
        }
      });
      define(Run, 'length', {
        /**
         * Gets value of the running distance based
         * on zero-indexing number of slides.
         *
         * @return {Number}
         */
        get: function get() {
          var settings = Glide.settings;
          var length = Components.Html.slides.length; // If the `bound` option is active, a maximum running distance should be
          // reduced by `perView` and `focusAt` settings. Running distance
          // should end before creating an empty space after instance.

          if (this.isBound()) {
            return length - 1 - (toInt(settings.perView) - 1) + toInt(settings.focusAt);
          }

          return length - 1;
        }
      });
      define(Run, 'offset', {
        /**
         * Gets status of the offsetting flag.
         *
         * @return {Boolean}
         */
        get: function get() {
          return this._o;
        }
      });
      return Run;
    }

    /**
     * Returns a current time.
     *
     * @return {Number}
     */
    function now() {
      return new Date().getTime();
    }

    /**
     * Returns a function, that, when invoked, will only be triggered
     * at most once during a given window of time.
     *
     * @param {Function} func
     * @param {Number} wait
     * @param {Object=} options
     * @return {Function}
     *
     * @see https://github.com/jashkenas/underscore
     */

    function throttle(func, wait) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var timeout, context, args, result;
      var previous = 0;

      var later = function later() {
        previous = options.leading === false ? 0 : now();
        timeout = null;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      };

      var throttled = function throttled() {
        var at = now();
        if (!previous && options.leading === false) previous = at;
        var remaining = wait - (at - previous);
        context = this;
        args = arguments;

        if (remaining <= 0 || remaining > wait) {
          if (timeout) {
            clearTimeout(timeout);
            timeout = null;
          }

          previous = at;
          result = func.apply(context, args);
          if (!timeout) context = args = null;
        } else if (!timeout && options.trailing !== false) {
          timeout = setTimeout(later, remaining);
        }

        return result;
      };

      throttled.cancel = function () {
        clearTimeout(timeout);
        previous = 0;
        timeout = context = args = null;
      };

      return throttled;
    }

    var MARGIN_TYPE = {
      ltr: ['marginLeft', 'marginRight'],
      rtl: ['marginRight', 'marginLeft']
    };
    function Gaps (Glide, Components, Events) {
      var Gaps = {
        /**
         * Applies gaps between slides. First and last
         * slides do not receive it's edge margins.
         *
         * @param {HTMLCollection} slides
         * @return {Void}
         */
        apply: function apply(slides) {
          for (var i = 0, len = slides.length; i < len; i++) {
            var style = slides[i].style;
            var direction = Components.Direction.value;

            if (i !== 0) {
              style[MARGIN_TYPE[direction][0]] = "".concat(this.value / 2, "px");
            } else {
              style[MARGIN_TYPE[direction][0]] = '';
            }

            if (i !== slides.length - 1) {
              style[MARGIN_TYPE[direction][1]] = "".concat(this.value / 2, "px");
            } else {
              style[MARGIN_TYPE[direction][1]] = '';
            }
          }
        },

        /**
         * Removes gaps from the slides.
         *
         * @param {HTMLCollection} slides
         * @returns {Void}
        */
        remove: function remove(slides) {
          for (var i = 0, len = slides.length; i < len; i++) {
            var style = slides[i].style;
            style.marginLeft = '';
            style.marginRight = '';
          }
        }
      };
      define(Gaps, 'value', {
        /**
         * Gets value of the gap.
         *
         * @returns {Number}
         */
        get: function get() {
          return toInt(Glide.settings.gap);
        }
      });
      define(Gaps, 'grow', {
        /**
         * Gets additional dimensions value caused by gaps.
         * Used to increase width of the slides wrapper.
         *
         * @returns {Number}
         */
        get: function get() {
          return Gaps.value * Components.Sizes.length;
        }
      });
      define(Gaps, 'reductor', {
        /**
         * Gets reduction value caused by gaps.
         * Used to subtract width of the slides.
         *
         * @returns {Number}
         */
        get: function get() {
          var perView = Glide.settings.perView;
          return Gaps.value * (perView - 1) / perView;
        }
      });
      /**
       * Apply calculated gaps:
       * - after building, so slides (including clones) will receive proper margins
       * - on updating via API, to recalculate gaps with new options
       */

      Events.on(['build.after', 'update'], throttle(function () {
        Gaps.apply(Components.Html.wrapper.children);
      }, 30));
      /**
       * Remove gaps:
       * - on destroying to bring markup to its inital state
       */

      Events.on('destroy', function () {
        Gaps.remove(Components.Html.wrapper.children);
      });
      return Gaps;
    }

    /**
     * Finds siblings nodes of the passed node.
     *
     * @param  {Element} node
     * @return {Array}
     */
    function siblings(node) {
      if (node && node.parentNode) {
        var n = node.parentNode.firstChild;
        var matched = [];

        for (; n; n = n.nextSibling) {
          if (n.nodeType === 1 && n !== node) {
            matched.push(n);
          }
        }

        return matched;
      }

      return [];
    }
    /**
     * Coerces a NodeList to an Array.
     *
     * @param  {NodeList} nodeList
     * @return {Array}
     */

    function toArray(nodeList) {
      return Array.prototype.slice.call(nodeList);
    }

    var TRACK_SELECTOR = '[data-glide-el="track"]';
    function Html (Glide, Components, Events) {
      var Html = {
        /**
         * Setup slider HTML nodes.
         *
         * @param {Glide} glide
         */
        mount: function mount() {
          this.root = Glide.selector;
          this.track = this.root.querySelector(TRACK_SELECTOR);
          this.collectSlides();
        },

        /**
         * Collect slides
         */
        collectSlides: function collectSlides() {
          this.slides = toArray(this.wrapper.children).filter(function (slide) {
            return !slide.classList.contains(Glide.settings.classes.slide.clone);
          });
        }
      };
      define(Html, 'root', {
        /**
         * Gets node of the glide main element.
         *
         * @return {Object}
         */
        get: function get() {
          return Html._r;
        },

        /**
         * Sets node of the glide main element.
         *
         * @return {Object}
         */
        set: function set(r) {
          if (isString(r)) {
            r = document.querySelector(r);
          }

          if (r !== null) {
            Html._r = r;
          } else {
            warn('Root element must be a existing Html node');
          }
        }
      });
      define(Html, 'track', {
        /**
         * Gets node of the glide track with slides.
         *
         * @return {Object}
         */
        get: function get() {
          return Html._t;
        },

        /**
         * Sets node of the glide track with slides.
         *
         * @return {Object}
         */
        set: function set(t) {
          Html._t = t;
        }
      });
      define(Html, 'wrapper', {
        /**
         * Gets node of the slides wrapper.
         *
         * @return {Object}
         */
        get: function get() {
          return Html.track.children[0];
        }
      });
      /**
       * Add/remove/reorder dynamic slides
       */

      Events.on('update', function () {
        Html.collectSlides();
      });
      return Html;
    }

    function Peek (Glide, Components, Events) {
      var Peek = {
        /**
         * Setups how much to peek based on settings.
         *
         * @return {Void}
         */
        mount: function mount() {
          this.value = Glide.settings.peek;
        }
      };
      define(Peek, 'value', {
        /**
         * Gets value of the peek.
         *
         * @returns {Number|Object}
         */
        get: function get() {
          return Peek._v;
        },

        /**
         * Sets value of the peek.
         *
         * @param {Number|Object} value
         * @return {Void}
         */
        set: function set(value) {
          if (isObject(value)) {
            value.before = toInt(value.before);
            value.after = toInt(value.after);
          } else {
            value = toInt(value);
          }

          Peek._v = value;
        }
      });
      define(Peek, 'reductor', {
        /**
         * Gets reduction value caused by peek.
         *
         * @returns {Number}
         */
        get: function get() {
          var value = Peek.value;
          var perView = Glide.settings.perView;

          if (isObject(value)) {
            return value.before / perView + value.after / perView;
          }

          return value * 2 / perView;
        }
      });
      /**
       * Recalculate peeking sizes on:
       * - when resizing window to update to proper percents
       */

      Events.on(['resize', 'update'], function () {
        Peek.mount();
      });
      return Peek;
    }

    function Move (Glide, Components, Events) {
      var Move = {
        /**
         * Constructs move component.
         *
         * @returns {Void}
         */
        mount: function mount() {
          this._o = 0;
        },

        /**
         * Calculates a movement value based on passed offset and currently active index.
         *
         * @param  {Number} offset
         * @return {Void}
         */
        make: function make() {
          var _this = this;

          var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
          this.offset = offset;
          Events.emit('move', {
            movement: this.value
          });
          Components.Transition.after(function () {
            Events.emit('move.after', {
              movement: _this.value
            });
          });
        }
      };
      define(Move, 'offset', {
        /**
         * Gets an offset value used to modify current translate.
         *
         * @return {Object}
         */
        get: function get() {
          return Move._o;
        },

        /**
         * Sets an offset value used to modify current translate.
         *
         * @return {Object}
         */
        set: function set(value) {
          Move._o = !isUndefined(value) ? toInt(value) : 0;
        }
      });
      define(Move, 'translate', {
        /**
         * Gets a raw movement value.
         *
         * @return {Number}
         */
        get: function get() {
          return Components.Sizes.slideWidth * Glide.index;
        }
      });
      define(Move, 'value', {
        /**
         * Gets an actual movement value corrected by offset.
         *
         * @return {Number}
         */
        get: function get() {
          var offset = this.offset;
          var translate = this.translate;

          if (Components.Direction.is('rtl')) {
            return translate + offset;
          }

          return translate - offset;
        }
      });
      /**
       * Make movement to proper slide on:
       * - before build, so glide will start at `startAt` index
       * - on each standard run to move to newly calculated index
       */

      Events.on(['build.before', 'run'], function () {
        Move.make();
      });
      return Move;
    }

    function Sizes (Glide, Components, Events) {
      var Sizes = {
        /**
         * Setups dimensions of slides.
         *
         * @return {Void}
         */
        setupSlides: function setupSlides() {
          var width = "".concat(this.slideWidth, "px");
          var slides = Components.Html.slides;

          for (var i = 0; i < slides.length; i++) {
            slides[i].style.width = width;
          }
        },

        /**
         * Setups dimensions of slides wrapper.
         *
         * @return {Void}
         */
        setupWrapper: function setupWrapper() {
          Components.Html.wrapper.style.width = "".concat(this.wrapperSize, "px");
        },

        /**
         * Removes applied styles from HTML elements.
         *
         * @returns {Void}
         */
        remove: function remove() {
          var slides = Components.Html.slides;

          for (var i = 0; i < slides.length; i++) {
            slides[i].style.width = '';
          }

          Components.Html.wrapper.style.width = '';
        }
      };
      define(Sizes, 'length', {
        /**
         * Gets count number of the slides.
         *
         * @return {Number}
         */
        get: function get() {
          return Components.Html.slides.length;
        }
      });
      define(Sizes, 'width', {
        /**
         * Gets width value of the slider (visible area).
         *
         * @return {Number}
         */
        get: function get() {
          return Components.Html.track.offsetWidth;
        }
      });
      define(Sizes, 'wrapperSize', {
        /**
         * Gets size of the slides wrapper.
         *
         * @return {Number}
         */
        get: function get() {
          return Sizes.slideWidth * Sizes.length + Components.Gaps.grow + Components.Clones.grow;
        }
      });
      define(Sizes, 'slideWidth', {
        /**
         * Gets width value of a single slide.
         *
         * @return {Number}
         */
        get: function get() {
          return Sizes.width / Glide.settings.perView - Components.Peek.reductor - Components.Gaps.reductor;
        }
      });
      /**
       * Apply calculated glide's dimensions:
       * - before building, so other dimensions (e.g. translate) will be calculated propertly
       * - when resizing window to recalculate sildes dimensions
       * - on updating via API, to calculate dimensions based on new options
       */

      Events.on(['build.before', 'resize', 'update'], function () {
        Sizes.setupSlides();
        Sizes.setupWrapper();
      });
      /**
       * Remove calculated glide's dimensions:
       * - on destoting to bring markup to its inital state
       */

      Events.on('destroy', function () {
        Sizes.remove();
      });
      return Sizes;
    }

    function Build (Glide, Components, Events) {
      var Build = {
        /**
         * Init glide building. Adds classes, sets
         * dimensions and setups initial state.
         *
         * @return {Void}
         */
        mount: function mount() {
          Events.emit('build.before');
          this.typeClass();
          this.activeClass();
          Events.emit('build.after');
        },

        /**
         * Adds `type` class to the glide element.
         *
         * @return {Void}
         */
        typeClass: function typeClass() {
          Components.Html.root.classList.add(Glide.settings.classes.type[Glide.settings.type]);
        },

        /**
         * Sets active class to current slide.
         *
         * @return {Void}
         */
        activeClass: function activeClass() {
          var classes = Glide.settings.classes;
          var slide = Components.Html.slides[Glide.index];

          if (slide) {
            slide.classList.add(classes.slide.active);
            siblings(slide).forEach(function (sibling) {
              sibling.classList.remove(classes.slide.active);
            });
          }
        },

        /**
         * Removes HTML classes applied at building.
         *
         * @return {Void}
         */
        removeClasses: function removeClasses() {
          var _Glide$settings$class = Glide.settings.classes,
              type = _Glide$settings$class.type,
              slide = _Glide$settings$class.slide;
          Components.Html.root.classList.remove(type[Glide.settings.type]);
          Components.Html.slides.forEach(function (sibling) {
            sibling.classList.remove(slide.active);
          });
        }
      };
      /**
       * Clear building classes:
       * - on destroying to bring HTML to its initial state
       * - on updating to remove classes before remounting component
       */

      Events.on(['destroy', 'update'], function () {
        Build.removeClasses();
      });
      /**
       * Remount component:
       * - on resizing of the window to calculate new dimensions
       * - on updating settings via API
       */

      Events.on(['resize', 'update'], function () {
        Build.mount();
      });
      /**
       * Swap active class of current slide:
       * - after each move to the new index
       */

      Events.on('move.after', function () {
        Build.activeClass();
      });
      return Build;
    }

    function Clones (Glide, Components, Events) {
      var Clones = {
        /**
         * Create pattern map and collect slides to be cloned.
         */
        mount: function mount() {
          this.items = [];

          if (Glide.isType('carousel')) {
            this.items = this.collect();
          }
        },

        /**
         * Collect clones with pattern.
         *
         * @return {[]}
         */
        collect: function collect() {
          var items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
          var slides = Components.Html.slides;
          var _Glide$settings = Glide.settings,
              perView = _Glide$settings.perView,
              classes = _Glide$settings.classes,
              cloningRatio = _Glide$settings.cloningRatio;

          if (slides.length > 0) {
            var peekIncrementer = +!!Glide.settings.peek;
            var cloneCount = perView + peekIncrementer + Math.round(perView / 2);
            var append = slides.slice(0, cloneCount).reverse();
            var prepend = slides.slice(cloneCount * -1);

            for (var r = 0; r < Math.max(cloningRatio, Math.floor(perView / slides.length)); r++) {
              for (var i = 0; i < append.length; i++) {
                var clone = append[i].cloneNode(true);
                clone.classList.add(classes.slide.clone);
                items.push(clone);
              }

              for (var _i = 0; _i < prepend.length; _i++) {
                var _clone = prepend[_i].cloneNode(true);

                _clone.classList.add(classes.slide.clone);

                items.unshift(_clone);
              }
            }
          }

          return items;
        },

        /**
         * Append cloned slides with generated pattern.
         *
         * @return {Void}
         */
        append: function append() {
          var items = this.items;
          var _Components$Html = Components.Html,
              wrapper = _Components$Html.wrapper,
              slides = _Components$Html.slides;
          var half = Math.floor(items.length / 2);
          var prepend = items.slice(0, half).reverse();
          var append = items.slice(half * -1).reverse();
          var width = "".concat(Components.Sizes.slideWidth, "px");

          for (var i = 0; i < append.length; i++) {
            wrapper.appendChild(append[i]);
          }

          for (var _i2 = 0; _i2 < prepend.length; _i2++) {
            wrapper.insertBefore(prepend[_i2], slides[0]);
          }

          for (var _i3 = 0; _i3 < items.length; _i3++) {
            items[_i3].style.width = width;
          }
        },

        /**
         * Remove all cloned slides.
         *
         * @return {Void}
         */
        remove: function remove() {
          var items = this.items;

          for (var i = 0; i < items.length; i++) {
            Components.Html.wrapper.removeChild(items[i]);
          }
        }
      };
      define(Clones, 'grow', {
        /**
         * Gets additional dimensions value caused by clones.
         *
         * @return {Number}
         */
        get: function get() {
          return (Components.Sizes.slideWidth + Components.Gaps.value) * Clones.items.length;
        }
      });
      /**
       * Append additional slide's clones:
       * - while glide's type is `carousel`
       */

      Events.on('update', function () {
        Clones.remove();
        Clones.mount();
        Clones.append();
      });
      /**
       * Append additional slide's clones:
       * - while glide's type is `carousel`
       */

      Events.on('build.before', function () {
        if (Glide.isType('carousel')) {
          Clones.append();
        }
      });
      /**
       * Remove clones HTMLElements:
       * - on destroying, to bring HTML to its initial state
       */

      Events.on('destroy', function () {
        Clones.remove();
      });
      return Clones;
    }

    var EventsBinder = /*#__PURE__*/function () {
      /**
       * Construct a EventsBinder instance.
       */
      function EventsBinder() {
        var listeners = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck(this, EventsBinder);

        this.listeners = listeners;
      }
      /**
       * Adds events listeners to arrows HTML elements.
       *
       * @param  {String|Array} events
       * @param  {Element|Window|Document} el
       * @param  {Function} closure
       * @param  {Boolean|Object} capture
       * @return {Void}
       */


      _createClass(EventsBinder, [{
        key: "on",
        value: function on(events, el, closure) {
          var capture = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

          if (isString(events)) {
            events = [events];
          }

          for (var i = 0; i < events.length; i++) {
            this.listeners[events[i]] = closure;
            el.addEventListener(events[i], this.listeners[events[i]], capture);
          }
        }
        /**
         * Removes event listeners from arrows HTML elements.
         *
         * @param  {String|Array} events
         * @param  {Element|Window|Document} el
         * @param  {Boolean|Object} capture
         * @return {Void}
         */

      }, {
        key: "off",
        value: function off(events, el) {
          var capture = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

          if (isString(events)) {
            events = [events];
          }

          for (var i = 0; i < events.length; i++) {
            el.removeEventListener(events[i], this.listeners[events[i]], capture);
          }
        }
        /**
         * Destroy collected listeners.
         *
         * @returns {Void}
         */

      }, {
        key: "destroy",
        value: function destroy() {
          delete this.listeners;
        }
      }]);

      return EventsBinder;
    }();

    function Resize (Glide, Components, Events) {
      /**
       * Instance of the binder for DOM Events.
       *
       * @type {EventsBinder}
       */
      var Binder = new EventsBinder();
      var Resize = {
        /**
         * Initializes window bindings.
         */
        mount: function mount() {
          this.bind();
        },

        /**
         * Binds `rezsize` listener to the window.
         * It's a costly event, so we are debouncing it.
         *
         * @return {Void}
         */
        bind: function bind() {
          Binder.on('resize', window, throttle(function () {
            Events.emit('resize');
          }, Glide.settings.throttle));
        },

        /**
         * Unbinds listeners from the window.
         *
         * @return {Void}
         */
        unbind: function unbind() {
          Binder.off('resize', window);
        }
      };
      /**
       * Remove bindings from window:
       * - on destroying, to remove added EventListener
       */

      Events.on('destroy', function () {
        Resize.unbind();
        Binder.destroy();
      });
      return Resize;
    }

    var VALID_DIRECTIONS = ['ltr', 'rtl'];
    var FLIPED_MOVEMENTS = {
      '>': '<',
      '<': '>',
      '=': '='
    };
    function Direction (Glide, Components, Events) {
      var Direction = {
        /**
         * Setups gap value based on settings.
         *
         * @return {Void}
         */
        mount: function mount() {
          this.value = Glide.settings.direction;
        },

        /**
         * Resolves pattern based on direction value
         *
         * @param {String} pattern
         * @returns {String}
         */
        resolve: function resolve(pattern) {
          var token = pattern.slice(0, 1);

          if (this.is('rtl')) {
            return pattern.split(token).join(FLIPED_MOVEMENTS[token]);
          }

          return pattern;
        },

        /**
         * Checks value of direction mode.
         *
         * @param {String} direction
         * @returns {Boolean}
         */
        is: function is(direction) {
          return this.value === direction;
        },

        /**
         * Applies direction class to the root HTML element.
         *
         * @return {Void}
         */
        addClass: function addClass() {
          Components.Html.root.classList.add(Glide.settings.classes.direction[this.value]);
        },

        /**
         * Removes direction class from the root HTML element.
         *
         * @return {Void}
         */
        removeClass: function removeClass() {
          Components.Html.root.classList.remove(Glide.settings.classes.direction[this.value]);
        }
      };
      define(Direction, 'value', {
        /**
         * Gets value of the direction.
         *
         * @returns {Number}
         */
        get: function get() {
          return Direction._v;
        },

        /**
         * Sets value of the direction.
         *
         * @param {String} value
         * @return {Void}
         */
        set: function set(value) {
          if (VALID_DIRECTIONS.indexOf(value) > -1) {
            Direction._v = value;
          } else {
            warn('Direction value must be `ltr` or `rtl`');
          }
        }
      });
      /**
       * Clear direction class:
       * - on destroy to bring HTML to its initial state
       * - on update to remove class before reappling bellow
       */

      Events.on(['destroy', 'update'], function () {
        Direction.removeClass();
      });
      /**
       * Remount component:
       * - on update to reflect changes in direction value
       */

      Events.on('update', function () {
        Direction.mount();
      });
      /**
       * Apply direction class:
       * - before building to apply class for the first time
       * - on updating to reapply direction class that may changed
       */

      Events.on(['build.before', 'update'], function () {
        Direction.addClass();
      });
      return Direction;
    }

    /**
     * Reflects value of glide movement.
     *
     * @param  {Object} Glide
     * @param  {Object} Components
     * @return {Object}
     */
    function Rtl (Glide, Components) {
      return {
        /**
         * Negates the passed translate if glide is in RTL option.
         *
         * @param  {Number} translate
         * @return {Number}
         */
        modify: function modify(translate) {
          if (Components.Direction.is('rtl')) {
            return -translate;
          }

          return translate;
        }
      };
    }

    /**
     * Updates glide movement with a `gap` settings.
     *
     * @param  {Object} Glide
     * @param  {Object} Components
     * @return {Object}
     */
    function Gap (Glide, Components) {
      return {
        /**
         * Modifies passed translate value with number in the `gap` settings.
         *
         * @param  {Number} translate
         * @return {Number}
         */
        modify: function modify(translate) {
          var multiplier = Math.floor(translate / Components.Sizes.slideWidth);
          return translate + Components.Gaps.value * multiplier;
        }
      };
    }

    /**
     * Updates glide movement with width of additional clones width.
     *
     * @param  {Object} Glide
     * @param  {Object} Components
     * @return {Object}
     */
    function Grow (Glide, Components) {
      return {
        /**
         * Adds to the passed translate width of the half of clones.
         *
         * @param  {Number} translate
         * @return {Number}
         */
        modify: function modify(translate) {
          return translate + Components.Clones.grow / 2;
        }
      };
    }

    /**
     * Updates glide movement with a `peek` settings.
     *
     * @param  {Object} Glide
     * @param  {Object} Components
     * @return {Object}
     */

    function Peeking (Glide, Components) {
      return {
        /**
         * Modifies passed translate value with a `peek` setting.
         *
         * @param  {Number} translate
         * @return {Number}
         */
        modify: function modify(translate) {
          if (Glide.settings.focusAt >= 0) {
            var peek = Components.Peek.value;

            if (isObject(peek)) {
              return translate - peek.before;
            }

            return translate - peek;
          }

          return translate;
        }
      };
    }

    /**
     * Updates glide movement with a `focusAt` settings.
     *
     * @param  {Object} Glide
     * @param  {Object} Components
     * @return {Object}
     */
    function Focusing (Glide, Components) {
      return {
        /**
         * Modifies passed translate value with index in the `focusAt` setting.
         *
         * @param  {Number} translate
         * @return {Number}
         */
        modify: function modify(translate) {
          var gap = Components.Gaps.value;
          var width = Components.Sizes.width;
          var focusAt = Glide.settings.focusAt;
          var slideWidth = Components.Sizes.slideWidth;

          if (focusAt === 'center') {
            return translate - (width / 2 - slideWidth / 2);
          }

          return translate - slideWidth * focusAt - gap * focusAt;
        }
      };
    }

    /**
     * Applies diffrent transformers on translate value.
     *
     * @param  {Object} Glide
     * @param  {Object} Components
     * @return {Object}
     */

    function mutator (Glide, Components, Events) {
      /**
       * Merge instance transformers with collection of default transformers.
       * It's important that the Rtl component be last on the list,
       * so it reflects all previous transformations.
       *
       * @type {Array}
       */
      var TRANSFORMERS = [Gap, Grow, Peeking, Focusing].concat(Glide._t, [Rtl]);
      return {
        /**
         * Piplines translate value with registered transformers.
         *
         * @param  {Number} translate
         * @return {Number}
         */
        mutate: function mutate(translate) {
          for (var i = 0; i < TRANSFORMERS.length; i++) {
            var transformer = TRANSFORMERS[i];

            if (isFunction(transformer) && isFunction(transformer().modify)) {
              translate = transformer(Glide, Components, Events).modify(translate);
            } else {
              warn('Transformer should be a function that returns an object with `modify()` method');
            }
          }

          return translate;
        }
      };
    }

    function Translate (Glide, Components, Events) {
      var Translate = {
        /**
         * Sets value of translate on HTML element.
         *
         * @param {Number} value
         * @return {Void}
         */
        set: function set(value) {
          var transform = mutator(Glide, Components).mutate(value);
          var translate3d = "translate3d(".concat(-1 * transform, "px, 0px, 0px)");
          Components.Html.wrapper.style.mozTransform = translate3d; // needed for supported Firefox 10-15

          Components.Html.wrapper.style.webkitTransform = translate3d; // needed for supported Chrome 10-35, Safari 5.1-8, and Opera 15-22

          Components.Html.wrapper.style.transform = translate3d;
        },

        /**
         * Removes value of translate from HTML element.
         *
         * @return {Void}
         */
        remove: function remove() {
          Components.Html.wrapper.style.transform = '';
        },

        /**
         * @return {number}
         */
        getStartIndex: function getStartIndex() {
          var length = Components.Sizes.length;
          var index = Glide.index;
          var perView = Glide.settings.perView;

          if (Components.Run.isOffset('>') || Components.Run.isOffset('|>')) {
            return length + (index - perView);
          } // "modulo length" converts an index that equals length to zero


          return (index + perView) % length;
        },

        /**
         * @return {number}
         */
        getTravelDistance: function getTravelDistance() {
          var travelDistance = Components.Sizes.slideWidth * Glide.settings.perView;

          if (Components.Run.isOffset('>') || Components.Run.isOffset('|>')) {
            // reverse travel distance so that we don't have to change subtract operations
            return travelDistance * -1;
          }

          return travelDistance;
        }
      };
      /**
       * Set new translate value:
       * - on move to reflect index change
       * - on updating via API to reflect possible changes in options
       */

      Events.on('move', function (context) {
        if (!Glide.isType('carousel') || !Components.Run.isOffset()) {
          return Translate.set(context.movement);
        }

        Components.Transition.after(function () {
          Events.emit('translate.jump');
          Translate.set(Components.Sizes.slideWidth * Glide.index);
        });
        var startWidth = Components.Sizes.slideWidth * Components.Translate.getStartIndex();
        return Translate.set(startWidth - Components.Translate.getTravelDistance());
      });
      /**
       * Remove translate:
       * - on destroying to bring markup to its inital state
       */

      Events.on('destroy', function () {
        Translate.remove();
      });
      return Translate;
    }

    function Transition (Glide, Components, Events) {
      /**
       * Holds inactivity status of transition.
       * When true transition is not applied.
       *
       * @type {Boolean}
       */
      var disabled = false;
      var Transition = {
        /**
         * Composes string of the CSS transition.
         *
         * @param {String} property
         * @return {String}
         */
        compose: function compose(property) {
          var settings = Glide.settings;

          if (disabled) {
            return "".concat(property, " 0ms ").concat(settings.animationTimingFunc);
          }

          return "".concat(property, " ").concat(this.duration, "ms ").concat(settings.animationTimingFunc);
        },

        /**
         * Sets value of transition on HTML element.
         *
         * @param {String=} property
         * @return {Void}
         */
        set: function set() {
          var property = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'transform';
          Components.Html.wrapper.style.transition = this.compose(property);
        },

        /**
         * Removes value of transition from HTML element.
         *
         * @return {Void}
         */
        remove: function remove() {
          Components.Html.wrapper.style.transition = '';
        },

        /**
         * Runs callback after animation.
         *
         * @param  {Function} callback
         * @return {Void}
         */
        after: function after(callback) {
          setTimeout(function () {
            callback();
          }, this.duration);
        },

        /**
         * Enable transition.
         *
         * @return {Void}
         */
        enable: function enable() {
          disabled = false;
          this.set();
        },

        /**
         * Disable transition.
         *
         * @return {Void}
         */
        disable: function disable() {
          disabled = true;
          this.set();
        }
      };
      define(Transition, 'duration', {
        /**
         * Gets duration of the transition based
         * on currently running animation type.
         *
         * @return {Number}
         */
        get: function get() {
          var settings = Glide.settings;

          if (Glide.isType('slider') && Components.Run.offset) {
            return settings.rewindDuration;
          }

          return settings.animationDuration;
        }
      });
      /**
       * Set transition `style` value:
       * - on each moving, because it may be cleared by offset move
       */

      Events.on('move', function () {
        Transition.set();
      });
      /**
       * Disable transition:
       * - before initial build to avoid transitioning from `0` to `startAt` index
       * - while resizing window and recalculating dimensions
       * - on jumping from offset transition at start and end edges in `carousel` type
       */

      Events.on(['build.before', 'resize', 'translate.jump'], function () {
        Transition.disable();
      });
      /**
       * Enable transition:
       * - on each running, because it may be disabled by offset move
       */

      Events.on('run', function () {
        Transition.enable();
      });
      /**
       * Remove transition:
       * - on destroying to bring markup to its inital state
       */

      Events.on('destroy', function () {
        Transition.remove();
      });
      return Transition;
    }

    /**
     * Test via a getter in the options object to see
     * if the passive property is accessed.
     *
     * @see https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md#feature-detection
     */
    var supportsPassive = false;

    try {
      var opts = Object.defineProperty({}, 'passive', {
        get: function get() {
          supportsPassive = true;
        }
      });
      window.addEventListener('testPassive', null, opts);
      window.removeEventListener('testPassive', null, opts);
    } catch (e) {}

    var supportsPassive$1 = supportsPassive;

    var START_EVENTS = ['touchstart', 'mousedown'];
    var MOVE_EVENTS = ['touchmove', 'mousemove'];
    var END_EVENTS = ['touchend', 'touchcancel', 'mouseup', 'mouseleave'];
    var MOUSE_EVENTS = ['mousedown', 'mousemove', 'mouseup', 'mouseleave'];
    function Swipe (Glide, Components, Events) {
      /**
       * Instance of the binder for DOM Events.
       *
       * @type {EventsBinder}
       */
      var Binder = new EventsBinder();
      var swipeSin = 0;
      var swipeStartX = 0;
      var swipeStartY = 0;
      var disabled = false;
      var capture = supportsPassive$1 ? {
        passive: true
      } : false;
      var Swipe = {
        /**
         * Initializes swipe bindings.
         *
         * @return {Void}
         */
        mount: function mount() {
          this.bindSwipeStart();
        },

        /**
         * Handler for `swipestart` event. Calculates entry points of the user's tap.
         *
         * @param {Object} event
         * @return {Void}
         */
        start: function start(event) {
          if (!disabled && !Glide.disabled) {
            this.disable();
            var swipe = this.touches(event);
            swipeSin = null;
            swipeStartX = toInt(swipe.pageX);
            swipeStartY = toInt(swipe.pageY);
            this.bindSwipeMove();
            this.bindSwipeEnd();
            Events.emit('swipe.start');
          }
        },

        /**
         * Handler for `swipemove` event. Calculates user's tap angle and distance.
         *
         * @param {Object} event
         */
        move: function move(event) {
          if (!Glide.disabled) {
            var _Glide$settings = Glide.settings,
                touchAngle = _Glide$settings.touchAngle,
                touchRatio = _Glide$settings.touchRatio,
                classes = _Glide$settings.classes;
            var swipe = this.touches(event);
            var subExSx = toInt(swipe.pageX) - swipeStartX;
            var subEySy = toInt(swipe.pageY) - swipeStartY;
            var powEX = Math.abs(subExSx << 2);
            var powEY = Math.abs(subEySy << 2);
            var swipeHypotenuse = Math.sqrt(powEX + powEY);
            var swipeCathetus = Math.sqrt(powEY);
            swipeSin = Math.asin(swipeCathetus / swipeHypotenuse);

            if (swipeSin * 180 / Math.PI < touchAngle) {
              event.stopPropagation();
              Components.Move.make(subExSx * toFloat(touchRatio));
              Components.Html.root.classList.add(classes.dragging);
              Events.emit('swipe.move');
            } else {
              return false;
            }
          }
        },

        /**
         * Handler for `swipeend` event. Finitializes user's tap and decides about glide move.
         *
         * @param {Object} event
         * @return {Void}
         */
        end: function end(event) {
          if (!Glide.disabled) {
            var _Glide$settings2 = Glide.settings,
                perSwipe = _Glide$settings2.perSwipe,
                touchAngle = _Glide$settings2.touchAngle,
                classes = _Glide$settings2.classes;
            var swipe = this.touches(event);
            var threshold = this.threshold(event);
            var swipeDistance = swipe.pageX - swipeStartX;
            var swipeDeg = swipeSin * 180 / Math.PI;
            this.enable();

            if (swipeDistance > threshold && swipeDeg < touchAngle) {
              Components.Run.make(Components.Direction.resolve("".concat(perSwipe, "<")));
            } else if (swipeDistance < -threshold && swipeDeg < touchAngle) {
              Components.Run.make(Components.Direction.resolve("".concat(perSwipe, ">")));
            } else {
              // While swipe don't reach distance apply previous transform.
              Components.Move.make();
            }

            Components.Html.root.classList.remove(classes.dragging);
            this.unbindSwipeMove();
            this.unbindSwipeEnd();
            Events.emit('swipe.end');
          }
        },

        /**
         * Binds swipe's starting event.
         *
         * @return {Void}
         */
        bindSwipeStart: function bindSwipeStart() {
          var _this = this;

          var _Glide$settings3 = Glide.settings,
              swipeThreshold = _Glide$settings3.swipeThreshold,
              dragThreshold = _Glide$settings3.dragThreshold;

          if (swipeThreshold) {
            Binder.on(START_EVENTS[0], Components.Html.wrapper, function (event) {
              _this.start(event);
            }, capture);
          }

          if (dragThreshold) {
            Binder.on(START_EVENTS[1], Components.Html.wrapper, function (event) {
              _this.start(event);
            }, capture);
          }
        },

        /**
         * Unbinds swipe's starting event.
         *
         * @return {Void}
         */
        unbindSwipeStart: function unbindSwipeStart() {
          Binder.off(START_EVENTS[0], Components.Html.wrapper, capture);
          Binder.off(START_EVENTS[1], Components.Html.wrapper, capture);
        },

        /**
         * Binds swipe's moving event.
         *
         * @return {Void}
         */
        bindSwipeMove: function bindSwipeMove() {
          var _this2 = this;

          Binder.on(MOVE_EVENTS, Components.Html.wrapper, throttle(function (event) {
            _this2.move(event);
          }, Glide.settings.throttle), capture);
        },

        /**
         * Unbinds swipe's moving event.
         *
         * @return {Void}
         */
        unbindSwipeMove: function unbindSwipeMove() {
          Binder.off(MOVE_EVENTS, Components.Html.wrapper, capture);
        },

        /**
         * Binds swipe's ending event.
         *
         * @return {Void}
         */
        bindSwipeEnd: function bindSwipeEnd() {
          var _this3 = this;

          Binder.on(END_EVENTS, Components.Html.wrapper, function (event) {
            _this3.end(event);
          });
        },

        /**
         * Unbinds swipe's ending event.
         *
         * @return {Void}
         */
        unbindSwipeEnd: function unbindSwipeEnd() {
          Binder.off(END_EVENTS, Components.Html.wrapper);
        },

        /**
         * Normalizes event touches points accorting to different types.
         *
         * @param {Object} event
         */
        touches: function touches(event) {
          if (MOUSE_EVENTS.indexOf(event.type) > -1) {
            return event;
          }

          return event.touches[0] || event.changedTouches[0];
        },

        /**
         * Gets value of minimum swipe distance settings based on event type.
         *
         * @return {Number}
         */
        threshold: function threshold(event) {
          var settings = Glide.settings;

          if (MOUSE_EVENTS.indexOf(event.type) > -1) {
            return settings.dragThreshold;
          }

          return settings.swipeThreshold;
        },

        /**
         * Enables swipe event.
         *
         * @return {self}
         */
        enable: function enable() {
          disabled = false;
          Components.Transition.enable();
          return this;
        },

        /**
         * Disables swipe event.
         *
         * @return {self}
         */
        disable: function disable() {
          disabled = true;
          Components.Transition.disable();
          return this;
        }
      };
      /**
       * Add component class:
       * - after initial building
       */

      Events.on('build.after', function () {
        Components.Html.root.classList.add(Glide.settings.classes.swipeable);
      });
      /**
       * Remove swiping bindings:
       * - on destroying, to remove added EventListeners
       */

      Events.on('destroy', function () {
        Swipe.unbindSwipeStart();
        Swipe.unbindSwipeMove();
        Swipe.unbindSwipeEnd();
        Binder.destroy();
      });
      return Swipe;
    }

    function Images (Glide, Components, Events) {
      /**
       * Instance of the binder for DOM Events.
       *
       * @type {EventsBinder}
       */
      var Binder = new EventsBinder();
      var Images = {
        /**
         * Binds listener to glide wrapper.
         *
         * @return {Void}
         */
        mount: function mount() {
          this.bind();
        },

        /**
         * Binds `dragstart` event on wrapper to prevent dragging images.
         *
         * @return {Void}
         */
        bind: function bind() {
          Binder.on('dragstart', Components.Html.wrapper, this.dragstart);
        },

        /**
         * Unbinds `dragstart` event on wrapper.
         *
         * @return {Void}
         */
        unbind: function unbind() {
          Binder.off('dragstart', Components.Html.wrapper);
        },

        /**
         * Event handler. Prevents dragging.
         *
         * @return {Void}
         */
        dragstart: function dragstart(event) {
          event.preventDefault();
        }
      };
      /**
       * Remove bindings from images:
       * - on destroying, to remove added EventListeners
       */

      Events.on('destroy', function () {
        Images.unbind();
        Binder.destroy();
      });
      return Images;
    }

    function Anchors (Glide, Components, Events) {
      /**
       * Instance of the binder for DOM Events.
       *
       * @type {EventsBinder}
       */
      var Binder = new EventsBinder();
      /**
       * Holds detaching status of anchors.
       * Prevents detaching of already detached anchors.
       *
       * @private
       * @type {Boolean}
       */

      var detached = false;
      /**
       * Holds preventing status of anchors.
       * If `true` redirection after click will be disabled.
       *
       * @private
       * @type {Boolean}
       */

      var prevented = false;
      var Anchors = {
        /**
         * Setups a initial state of anchors component.
         *
         * @returns {Void}
         */
        mount: function mount() {
          /**
           * Holds collection of anchors elements.
           *
           * @private
           * @type {HTMLCollection}
           */
          this._a = Components.Html.wrapper.querySelectorAll('a');
          this.bind();
        },

        /**
         * Binds events to anchors inside a track.
         *
         * @return {Void}
         */
        bind: function bind() {
          Binder.on('click', Components.Html.wrapper, this.click);
        },

        /**
         * Unbinds events attached to anchors inside a track.
         *
         * @return {Void}
         */
        unbind: function unbind() {
          Binder.off('click', Components.Html.wrapper);
        },

        /**
         * Handler for click event. Prevents clicks when glide is in `prevent` status.
         *
         * @param  {Object} event
         * @return {Void}
         */
        click: function click(event) {
          if (prevented) {
            event.stopPropagation();
            event.preventDefault();
          }
        },

        /**
         * Detaches anchors click event inside glide.
         *
         * @return {self}
         */
        detach: function detach() {
          prevented = true;

          if (!detached) {
            for (var i = 0; i < this.items.length; i++) {
              this.items[i].draggable = false;
            }

            detached = true;
          }

          return this;
        },

        /**
         * Attaches anchors click events inside glide.
         *
         * @return {self}
         */
        attach: function attach() {
          prevented = false;

          if (detached) {
            for (var i = 0; i < this.items.length; i++) {
              this.items[i].draggable = true;
            }

            detached = false;
          }

          return this;
        }
      };
      define(Anchors, 'items', {
        /**
         * Gets collection of the arrows HTML elements.
         *
         * @return {HTMLElement[]}
         */
        get: function get() {
          return Anchors._a;
        }
      });
      /**
       * Detach anchors inside slides:
       * - on swiping, so they won't redirect to its `href` attributes
       */

      Events.on('swipe.move', function () {
        Anchors.detach();
      });
      /**
       * Attach anchors inside slides:
       * - after swiping and transitions ends, so they can redirect after click again
       */

      Events.on('swipe.end', function () {
        Components.Transition.after(function () {
          Anchors.attach();
        });
      });
      /**
       * Unbind anchors inside slides:
       * - on destroying, to bring anchors to its initial state
       */

      Events.on('destroy', function () {
        Anchors.attach();
        Anchors.unbind();
        Binder.destroy();
      });
      return Anchors;
    }

    var NAV_SELECTOR = '[data-glide-el="controls[nav]"]';
    var CONTROLS_SELECTOR = '[data-glide-el^="controls"]';
    var PREVIOUS_CONTROLS_SELECTOR = "".concat(CONTROLS_SELECTOR, " [data-glide-dir*=\"<\"]");
    var NEXT_CONTROLS_SELECTOR = "".concat(CONTROLS_SELECTOR, " [data-glide-dir*=\">\"]");
    function Controls (Glide, Components, Events) {
      /**
       * Instance of the binder for DOM Events.
       *
       * @type {EventsBinder}
       */
      var Binder = new EventsBinder();
      var capture = supportsPassive$1 ? {
        passive: true
      } : false;
      var Controls = {
        /**
         * Inits arrows. Binds events listeners
         * to the arrows HTML elements.
         *
         * @return {Void}
         */
        mount: function mount() {
          /**
           * Collection of navigation HTML elements.
           *
           * @private
           * @type {HTMLCollection}
           */
          this._n = Components.Html.root.querySelectorAll(NAV_SELECTOR);
          /**
           * Collection of controls HTML elements.
           *
           * @private
           * @type {HTMLCollection}
           */

          this._c = Components.Html.root.querySelectorAll(CONTROLS_SELECTOR);
          /**
           * Collection of arrow control HTML elements.
           *
           * @private
           * @type {Object}
           */

          this._arrowControls = {
            previous: Components.Html.root.querySelectorAll(PREVIOUS_CONTROLS_SELECTOR),
            next: Components.Html.root.querySelectorAll(NEXT_CONTROLS_SELECTOR)
          };
          this.addBindings();
        },

        /**
         * Sets active class to current slide.
         *
         * @return {Void}
         */
        setActive: function setActive() {
          for (var i = 0; i < this._n.length; i++) {
            this.addClass(this._n[i].children);
          }
        },

        /**
         * Removes active class to current slide.
         *
         * @return {Void}
         */
        removeActive: function removeActive() {
          for (var i = 0; i < this._n.length; i++) {
            this.removeClass(this._n[i].children);
          }
        },

        /**
         * Toggles active class on items inside navigation.
         *
         * @param  {HTMLElement} controls
         * @return {Void}
         */
        addClass: function addClass(controls) {
          var settings = Glide.settings;
          var item = controls[Glide.index];

          if (!item) {
            return;
          }

          item.classList.add(settings.classes.nav.active);
          siblings(item).forEach(function (sibling) {
            sibling.classList.remove(settings.classes.nav.active);
          });
        },

        /**
         * Removes active class from active control.
         *
         * @param  {HTMLElement} controls
         * @return {Void}
         */
        removeClass: function removeClass(controls) {
          var item = controls[Glide.index];
          item === null || item === void 0 ? void 0 : item.classList.remove(Glide.settings.classes.nav.active);
        },

        /**
         * Calculates, removes or adds `Glide.settings.classes.disabledArrow` class on the control arrows
         */
        setArrowState: function setArrowState() {
          if (Glide.settings.rewind) {
            return;
          }

          var next = Controls._arrowControls.next;
          var previous = Controls._arrowControls.previous;
          this.resetArrowState(next, previous);

          if (Glide.index === 0) {
            this.disableArrow(previous);
          }

          if (Glide.index === Components.Run.length) {
            this.disableArrow(next);
          }
        },

        /**
         * Removes `Glide.settings.classes.disabledArrow` from given NodeList elements
         *
         * @param {NodeList[]} lists
         */
        resetArrowState: function resetArrowState() {
          var settings = Glide.settings;

          for (var _len = arguments.length, lists = new Array(_len), _key = 0; _key < _len; _key++) {
            lists[_key] = arguments[_key];
          }

          lists.forEach(function (list) {
            toArray(list).forEach(function (element) {
              element.classList.remove(settings.classes.arrow.disabled);
            });
          });
        },

        /**
         * Adds `Glide.settings.classes.disabledArrow` to given NodeList elements
         *
         * @param {NodeList[]} lists
         */
        disableArrow: function disableArrow() {
          var settings = Glide.settings;

          for (var _len2 = arguments.length, lists = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            lists[_key2] = arguments[_key2];
          }

          lists.forEach(function (list) {
            toArray(list).forEach(function (element) {
              element.classList.add(settings.classes.arrow.disabled);
            });
          });
        },

        /**
         * Adds handles to the each group of controls.
         *
         * @return {Void}
         */
        addBindings: function addBindings() {
          for (var i = 0; i < this._c.length; i++) {
            this.bind(this._c[i].children);
          }
        },

        /**
         * Removes handles from the each group of controls.
         *
         * @return {Void}
         */
        removeBindings: function removeBindings() {
          for (var i = 0; i < this._c.length; i++) {
            this.unbind(this._c[i].children);
          }
        },

        /**
         * Binds events to arrows HTML elements.
         *
         * @param {HTMLCollection} elements
         * @return {Void}
         */
        bind: function bind(elements) {
          for (var i = 0; i < elements.length; i++) {
            Binder.on('click', elements[i], this.click);
            Binder.on('touchstart', elements[i], this.click, capture);
          }
        },

        /**
         * Unbinds events binded to the arrows HTML elements.
         *
         * @param {HTMLCollection} elements
         * @return {Void}
         */
        unbind: function unbind(elements) {
          for (var i = 0; i < elements.length; i++) {
            Binder.off(['click', 'touchstart'], elements[i]);
          }
        },

        /**
         * Handles `click` event on the arrows HTML elements.
         * Moves slider in direction given via the
         * `data-glide-dir` attribute.
         *
         * @param {Object} event
         * @return {void}
         */
        click: function click(event) {
          if (!supportsPassive$1 && event.type === 'touchstart') {
            event.preventDefault();
          }

          var direction = event.currentTarget.getAttribute('data-glide-dir');
          Components.Run.make(Components.Direction.resolve(direction));
        }
      };
      define(Controls, 'items', {
        /**
         * Gets collection of the controls HTML elements.
         *
         * @return {HTMLElement[]}
         */
        get: function get() {
          return Controls._c;
        }
      });
      /**
       * Swap active class of current navigation item:
       * - after mounting to set it to initial index
       * - after each move to the new index
       */

      Events.on(['mount.after', 'move.after'], function () {
        Controls.setActive();
      });
      /**
       * Add or remove disabled class of arrow elements
       */

      Events.on(['mount.after', 'run'], function () {
        Controls.setArrowState();
      });
      /**
       * Remove bindings and HTML Classes:
       * - on destroying, to bring markup to its initial state
       */

      Events.on('destroy', function () {
        Controls.removeBindings();
        Controls.removeActive();
        Binder.destroy();
      });
      return Controls;
    }

    function Keyboard (Glide, Components, Events) {
      /**
       * Instance of the binder for DOM Events.
       *
       * @type {EventsBinder}
       */
      var Binder = new EventsBinder();
      var Keyboard = {
        /**
         * Binds keyboard events on component mount.
         *
         * @return {Void}
         */
        mount: function mount() {
          if (Glide.settings.keyboard) {
            this.bind();
          }
        },

        /**
         * Adds keyboard press events.
         *
         * @return {Void}
         */
        bind: function bind() {
          Binder.on('keyup', document, this.press);
        },

        /**
         * Removes keyboard press events.
         *
         * @return {Void}
         */
        unbind: function unbind() {
          Binder.off('keyup', document);
        },

        /**
         * Handles keyboard's arrows press and moving glide foward and backward.
         *
         * @param  {Object} event
         * @return {Void}
         */
        press: function press(event) {
          var perSwipe = Glide.settings.perSwipe;
          var arrowSymbols = {
            ArrowRight: '>',
            ArrowLeft: '<'
          };

          if (['ArrowRight', 'ArrowLeft'].includes(event.code)) {
            Components.Run.make(Components.Direction.resolve("".concat(perSwipe).concat(arrowSymbols[event.code])));
          }
        }
      };
      /**
       * Remove bindings from keyboard:
       * - on destroying to remove added events
       * - on updating to remove events before remounting
       */

      Events.on(['destroy', 'update'], function () {
        Keyboard.unbind();
      });
      /**
       * Remount component
       * - on updating to reflect potential changes in settings
       */

      Events.on('update', function () {
        Keyboard.mount();
      });
      /**
       * Destroy binder:
       * - on destroying to remove listeners
       */

      Events.on('destroy', function () {
        Binder.destroy();
      });
      return Keyboard;
    }

    function Autoplay (Glide, Components, Events) {
      /**
       * Instance of the binder for DOM Events.
       *
       * @type {EventsBinder}
       */
      var Binder = new EventsBinder();
      var Autoplay = {
        /**
         * Initializes autoplaying and events.
         *
         * @return {Void}
         */
        mount: function mount() {
          this.enable();
          this.start();

          if (Glide.settings.hoverpause) {
            this.bind();
          }
        },

        /**
         * Enables autoplaying
         *
         * @returns {Void}
         */
        enable: function enable() {
          this._e = true;
        },

        /**
         * Disables autoplaying.
         *
         * @returns {Void}
         */
        disable: function disable() {
          this._e = false;
        },

        /**
         * Starts autoplaying in configured interval.
         *
         * @param {Boolean|Number} force Run autoplaying with passed interval regardless of `autoplay` settings
         * @return {Void}
         */
        start: function start() {
          var _this = this;

          if (!this._e) {
            return;
          }

          this.enable();

          if (Glide.settings.autoplay) {
            if (isUndefined(this._i)) {
              this._i = setInterval(function () {
                _this.stop();

                Components.Run.make('>');

                _this.start();

                Events.emit('autoplay');
              }, this.time);
            }
          }
        },

        /**
         * Stops autorunning of the glide.
         *
         * @return {Void}
         */
        stop: function stop() {
          this._i = clearInterval(this._i);
        },

        /**
         * Stops autoplaying while mouse is over glide's area.
         *
         * @return {Void}
         */
        bind: function bind() {
          var _this2 = this;

          Binder.on('mouseover', Components.Html.root, function () {
            if (_this2._e) {
              _this2.stop();
            }
          });
          Binder.on('mouseout', Components.Html.root, function () {
            if (_this2._e) {
              _this2.start();
            }
          });
        },

        /**
         * Unbind mouseover events.
         *
         * @returns {Void}
         */
        unbind: function unbind() {
          Binder.off(['mouseover', 'mouseout'], Components.Html.root);
        }
      };
      define(Autoplay, 'time', {
        /**
         * Gets time period value for the autoplay interval. Prioritizes
         * times in `data-glide-autoplay` attrubutes over options.
         *
         * @return {Number}
         */
        get: function get() {
          var autoplay = Components.Html.slides[Glide.index].getAttribute('data-glide-autoplay');

          if (autoplay) {
            return toInt(autoplay);
          }

          return toInt(Glide.settings.autoplay);
        }
      });
      /**
       * Stop autoplaying and unbind events:
       * - on destroying, to clear defined interval
       * - on updating via API to reset interval that may changed
       */

      Events.on(['destroy', 'update'], function () {
        Autoplay.unbind();
      });
      /**
       * Stop autoplaying:
       * - before each run, to restart autoplaying
       * - on pausing via API
       * - on destroying, to clear defined interval
       * - while starting a swipe
       * - on updating via API to reset interval that may changed
       */

      Events.on(['run.before', 'swipe.start', 'update'], function () {
        Autoplay.stop();
      });
      Events.on(['pause', 'destroy'], function () {
        Autoplay.disable();
        Autoplay.stop();
      });
      /**
       * Start autoplaying:
       * - after each run, to restart autoplaying
       * - on playing via API
       * - while ending a swipe
       */

      Events.on(['run.after', 'swipe.end'], function () {
        Autoplay.start();
      });
      /**
       * Start autoplaying:
       * - after each run, to restart autoplaying
       * - on playing via API
       * - while ending a swipe
       */

      Events.on(['play'], function () {
        Autoplay.enable();
        Autoplay.start();
      });
      /**
       * Remount autoplaying:
       * - on updating via API to reset interval that may changed
       */

      Events.on('update', function () {
        Autoplay.mount();
      });
      /**
       * Destroy a binder:
       * - on destroying glide instance to clearup listeners
       */

      Events.on('destroy', function () {
        Binder.destroy();
      });
      return Autoplay;
    }

    /**
     * Sorts keys of breakpoint object so they will be ordered from lower to bigger.
     *
     * @param {Object} points
     * @returns {Object}
     */

    function sortBreakpoints(points) {
      if (isObject(points)) {
        return sortKeys(points);
      } else {
        warn("Breakpoints option must be an object");
      }

      return {};
    }

    function Breakpoints (Glide, Components, Events) {
      /**
       * Instance of the binder for DOM Events.
       *
       * @type {EventsBinder}
       */
      var Binder = new EventsBinder();
      /**
       * Holds reference to settings.
       *
       * @type {Object}
       */

      var settings = Glide.settings;
      /**
       * Holds reference to breakpoints object in settings. Sorts breakpoints
       * from smaller to larger. It is required in order to proper
       * matching currently active breakpoint settings.
       *
       * @type {Object}
       */

      var points = sortBreakpoints(settings.breakpoints);
      /**
       * Cache initial settings before overwritting.
       *
       * @type {Object}
       */

      var defaults = Object.assign({}, settings);
      var Breakpoints = {
        /**
         * Matches settings for currectly matching media breakpoint.
         *
         * @param {Object} points
         * @returns {Object}
         */
        match: function match(points) {
          if (typeof window.matchMedia !== 'undefined') {
            for (var point in points) {
              if (points.hasOwnProperty(point)) {
                if (window.matchMedia("(max-width: ".concat(point, "px)")).matches) {
                  return points[point];
                }
              }
            }
          }

          return defaults;
        }
      };
      /**
       * Overwrite instance settings with currently matching breakpoint settings.
       * This happens right after component initialization.
       */

      Object.assign(settings, Breakpoints.match(points));
      /**
       * Update glide with settings of matched brekpoint:
       * - window resize to update slider
       */

      Binder.on('resize', window, throttle(function () {
        Glide.settings = mergeOptions(settings, Breakpoints.match(points));
      }, Glide.settings.throttle));
      /**
       * Resort and update default settings:
       * - on reinit via API, so breakpoint matching will be performed with options
       */

      Events.on('update', function () {
        points = sortBreakpoints(points);
        defaults = Object.assign({}, settings);
      });
      /**
       * Unbind resize listener:
       * - on destroying, to bring markup to its initial state
       */

      Events.on('destroy', function () {
        Binder.off('resize', window);
      });
      return Breakpoints;
    }

    var COMPONENTS = {
      // Required
      Html: Html,
      Translate: Translate,
      Transition: Transition,
      Direction: Direction,
      Peek: Peek,
      Sizes: Sizes,
      Gaps: Gaps,
      Move: Move,
      Clones: Clones,
      Resize: Resize,
      Build: Build,
      Run: Run,
      // Optional
      Swipe: Swipe,
      Images: Images,
      Anchors: Anchors,
      Controls: Controls,
      Keyboard: Keyboard,
      Autoplay: Autoplay,
      Breakpoints: Breakpoints
    };

    var Glide = /*#__PURE__*/function (_Core) {
      _inherits(Glide, _Core);

      var _super = _createSuper(Glide);

      function Glide() {
        _classCallCheck(this, Glide);

        return _super.apply(this, arguments);
      }

      _createClass(Glide, [{
        key: "mount",
        value: function mount() {
          var extensions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          return _get(_getPrototypeOf(Glide.prototype), "mount", this).call(this, Object.assign({}, COMPONENTS, extensions));
        }
      }]);

      return Glide;
    }(Glide$1);

    /* src\Components\SlideShow.svelte generated by Svelte v3.59.2 */
    const file$5 = "src\\Components\\SlideShow.svelte";

    function create_fragment$6(ctx) {
    	let div2;
    	let div0;
    	let ul;
    	let t0;
    	let div1;
    	let button0;
    	let t2;
    	let button1;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[1].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[0], null);

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			ul = element("ul");
    			if (default_slot) default_slot.c();
    			t0 = space();
    			div1 = element("div");
    			button0 = element("button");
    			button0.textContent = "Vorige";
    			t2 = space();
    			button1 = element("button");
    			button1.textContent = "Volgende";
    			attr_dev(ul, "class", "glide__slides");
    			add_location(ul, file$5, 12, 8, 284);
    			attr_dev(div0, "class", "glide__track");
    			attr_dev(div0, "data-glide-el", "track");
    			add_location(div0, file$5, 11, 4, 226);
    			attr_dev(button0, "class", "glide__arrow glide__arrow--left border text-gray-900 ml-16 px-4 py-2 shadow-lg rounded");
    			attr_dev(button0, "data-glide-dir", "<");
    			add_location(button0, file$5, 18, 8, 454);
    			attr_dev(button1, "class", "glide__arrow glide__arrow--right border text-gray-900 mr-16 px-4 py-2 shadow-lg rounded");
    			attr_dev(button1, "data-glide-dir", ">");
    			add_location(button1, file$5, 21, 8, 628);
    			attr_dev(div1, "class", "mt-4 glide__arrows flex justify-between");
    			attr_dev(div1, "data-glide-el", "controls");
    			add_location(div1, file$5, 17, 4, 366);
    			attr_dev(div2, "class", "glide");
    			add_location(div2, file$5, 10, 0, 201);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			append_dev(div0, ul);

    			if (default_slot) {
    				default_slot.m(ul, null);
    			}

    			append_dev(div2, t0);
    			append_dev(div2, div1);
    			append_dev(div1, button0);
    			append_dev(div1, t2);
    			append_dev(div1, button1);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 1)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[0],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[0])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[0], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$6.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$6($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('SlideShow', slots, ['default']);

    	onMount(() => {
    		const glide = new Glide(".glide");
    		glide.mount();
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SlideShow> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('$$scope' in $$props) $$invalidate(0, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ Glide, onMount });
    	return [$$scope, slots];
    }

    class SlideShow extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$6, create_fragment$6, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SlideShow",
    			options,
    			id: create_fragment$6.name
    		});
    	}
    }

    /* src\Components\Slide.svelte generated by Svelte v3.59.2 */

    const file$4 = "src\\Components\\Slide.svelte";

    function create_fragment$5(ctx) {
    	let li;
    	let div;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[1].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[0], null);

    	const block = {
    		c: function create() {
    			li = element("li");
    			div = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(div, "class", "max-w-sm max-h-sm rounded overflow-hidden shadow-lg");
    			add_location(div, file$4, 2, 4, 80);
    			attr_dev(li, "class", "glide__slide p-4 flex justify-center border content-center ");
    			add_location(li, file$4, 1, 0, 2);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, div);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 1)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[0],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[0])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[0], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$5.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$5($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Slide', slots, ['default']);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Slide> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('$$scope' in $$props) $$invalidate(0, $$scope = $$props.$$scope);
    	};

    	return [$$scope, slots];
    }

    class Slide extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$5, create_fragment$5, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Slide",
    			options,
    			id: create_fragment$5.name
    		});
    	}
    }

    /* src\Pages\Default\Home\WhoAmI.svelte generated by Svelte v3.59.2 */

    const file$3 = "src\\Pages\\Default\\Home\\WhoAmI.svelte";

    function create_fragment$4(ctx) {
    	let div;
    	let p0;
    	let t1;
    	let br0;
    	let t2;
    	let p1;
    	let t4;
    	let br1;
    	let t5;
    	let p2;
    	let t7;
    	let br2;
    	let t8;
    	let p3;
    	let t10;
    	let br3;
    	let t11;
    	let p4;

    	const block = {
    		c: function create() {
    			div = element("div");
    			p0 = element("p");
    			p0.textContent = "Zeker! Hier is een \"Wie ben ik\"-tekst die aansluit bij jouw interesses, projecten en schrijfstijl:";
    			t1 = space();
    			br0 = element("br");
    			t2 = space();
    			p1 = element("p");
    			p1.textContent = "Ik ben een uitgesproken en vrolijke tech-liefhebber met een voorliefde voor diepgaande kennis en praktisch toepasbare oplossingen.\r\n        Of het nu gaat om .NET, Blazor, Svelte- ik hou ervan om technologie niet alleen te begrijpen, maar ook te laten\r\n        werken zoals k dat wil.";
    			t4 = space();
    			br1 = element("br");
    			t5 = space();
    			p2 = element("p");
    			p2.textContent = "Naast softwareontwikkeling ben ik een motorrijder in hart en nieren.\r\n        Mijn reis begon op een 50cc handgeschakelde brommer, maar ik kijk al vooruit naar een Triumph Bonneville T120.";
    			t7 = space();
    			br2 = element("br");
    			t8 = space();
    			p3 = element("p");
    			p3.textContent = "Ik ben kritisch, analytisch en altijd op zoek naar efficintie.\r\n        Dat zie je terug in hoe ik software bouw, maar ook in hoe ik mijn workflow optimaliseer.\r\n        Tools zoals AutoHotkey, StrokeIt en andere gepersonaliseerde software zijn  voor mij geen gimmicks,\r\n        maar tools om mijn systeem precies naar mijn hand te zetten.";
    			t10 = space();
    			br3 = element("br");
    			t11 = space();
    			p4 = element("p");
    			p4.textContent = "En als ik niet aan het lezen, gamen of coderen ben, ben ik waarschijnlijk onderweg\r\n         op zoek naar nieuwe routes, zowel op de weg als in mijn carrire.";
    			add_location(p0, file$3, 1, 4, 23);
    			add_location(br0, file$3, 4, 4, 150);
    			add_location(p1, file$3, 5, 4, 162);
    			add_location(br1, file$3, 10, 4, 476);
    			add_location(p2, file$3, 11, 4, 488);
    			add_location(br2, file$3, 15, 4, 705);
    			add_location(p3, file$3, 16, 4, 717);
    			add_location(br3, file$3, 22, 4, 1086);
    			add_location(p4, file$3, 23, 4, 1098);
    			attr_dev(div, "class", "p-4");
    			add_location(div, file$3, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, p0);
    			append_dev(div, t1);
    			append_dev(div, br0);
    			append_dev(div, t2);
    			append_dev(div, p1);
    			append_dev(div, t4);
    			append_dev(div, br1);
    			append_dev(div, t5);
    			append_dev(div, p2);
    			append_dev(div, t7);
    			append_dev(div, br2);
    			append_dev(div, t8);
    			append_dev(div, p3);
    			append_dev(div, t10);
    			append_dev(div, br3);
    			append_dev(div, t11);
    			append_dev(div, p4);
    		},
    		p: noop$1,
    		i: noop$1,
    		o: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$4.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$4($$self, $$props) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('WhoAmI', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<WhoAmI> was created with unknown prop '${key}'`);
    	});

    	return [];
    }

    class WhoAmI extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$4, create_fragment$4, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "WhoAmI",
    			options,
    			id: create_fragment$4.name
    		});
    	}
    }

    /* src\Pages\Default\Home\Skills.svelte generated by Svelte v3.59.2 */
    const file$2 = "src\\Pages\\Default\\Home\\Skills.svelte";

    function create_fragment$3(ctx) {
    	let h2;
    	let t1;
    	let div;
    	let canvas;

    	const block = {
    		c: function create() {
    			h2 = element("h2");
    			h2.textContent = "Mijn skills";
    			t1 = space();
    			div = element("div");
    			canvas = element("canvas");
    			attr_dev(h2, "class", "text-center text-3xl w-full text-gray-900");
    			add_location(h2, file$2, 47, 0, 1359);
    			attr_dev(canvas, "height", "300");
    			attr_dev(canvas, "id", "skill_canvas");
    			add_location(canvas, file$2, 49, 4, 1474);
    			attr_dev(div, "class", "p-4 sm:w-full sm:h-1/12");
    			add_location(div, file$2, 48, 0, 1431);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h2, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div, anchor);
    			append_dev(div, canvas);
    		},
    		p: noop$1,
    		i: noop$1,
    		o: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h2);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Skills', slots, []);

    	const data = [
    		{
    			name: 'C#, .NET (Core & Framework)',
    			value: 100
    		},
    		{
    			name: 'ASP.NET (Core & Framework)',
    			value: 100
    		},
    		{ name: 'Blazor', value: 90 },
    		{ name: 'JavaScript', value: 90 },
    		{ name: 'Entity Framework', value: 85 },
    		{ name: 'Dapper', value: 85 },
    		{ name: 'ECMA-335 / (C)IL', value: 60 }
    	];

    	onMount(() => {
    		new Chart(document.getElementById("skill_canvas"),
    		{
    				type: 'bar',
    				data: {
    					labels: data.map(e => e.name),
    					datasets: [
    						{
    							label: "Mijn niveau",
    							data: data.map(e => e.value)
    						}
    					]
    				},
    				options: {
    					indexAxis: screen.width >= 640 ? 'x' : 'y',
    					elements: { bar: { borderWidth: 1 } },
    					responsive: true,
    					plugins: { legend: { display: false } },
    					maintainAspectRatio: false
    				}
    			});
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Skills> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ Chart, onMount, data });
    	return [];
    }

    class Skills extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3, create_fragment$3, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Skills",
    			options,
    			id: create_fragment$3.name
    		});
    	}
    }

    /* src\Pages\Default\Home\HomePage.svelte generated by Svelte v3.59.2 */
    const file$1 = "src\\Pages\\Default\\Home\\HomePage.svelte";

    // (19:16) <Slide>
    function create_default_slot_7(ctx) {
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			img = element("img");
    			attr_dev(img, "class", "h-64");
    			if (!src_url_equal(img.src, img_src_value = "/images/photo_pretty.jpeg")) attr_dev(img, "src", img_src_value);
    			add_location(img, file$1, 19, 20, 539);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		p: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7.name,
    		type: "slot",
    		source: "(19:16) <Slide>",
    		ctx
    	});

    	return block;
    }

    // (23:16) <Slide>
    function create_default_slot_6(ctx) {
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			img = element("img");
    			attr_dev(img, "class", "h-64");
    			if (!src_url_equal(img.src, img_src_value = "/images/photo_professional.jpg")) attr_dev(img, "src", img_src_value);
    			add_location(img, file$1, 23, 20, 665);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		p: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6.name,
    		type: "slot",
    		source: "(23:16) <Slide>",
    		ctx
    	});

    	return block;
    }

    // (27:16) <Slide>
    function create_default_slot_5(ctx) {
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			img = element("img");
    			attr_dev(img, "class", "h-64");
    			if (!src_url_equal(img.src, img_src_value = "/images/photo_propedeuse.jpeg")) attr_dev(img, "src", img_src_value);
    			add_location(img, file$1, 27, 20, 796);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		p: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5.name,
    		type: "slot",
    		source: "(27:16) <Slide>",
    		ctx
    	});

    	return block;
    }

    // (31:16) <Slide>
    function create_default_slot_4(ctx) {
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			img = element("img");
    			attr_dev(img, "class", "h-64");
    			if (!src_url_equal(img.src, img_src_value = "/images/photo_moped.jpeg")) attr_dev(img, "src", img_src_value);
    			add_location(img, file$1, 31, 20, 926);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		p: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4.name,
    		type: "slot",
    		source: "(31:16) <Slide>",
    		ctx
    	});

    	return block;
    }

    // (35:16) <Slide>
    function create_default_slot_3(ctx) {
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			img = element("img");
    			attr_dev(img, "class", "h-64");
    			if (!src_url_equal(img.src, img_src_value = "/images/photo_push.jpeg")) attr_dev(img, "src", img_src_value);
    			add_location(img, file$1, 35, 20, 1051);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		p: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3.name,
    		type: "slot",
    		source: "(35:16) <Slide>",
    		ctx
    	});

    	return block;
    }

    // (39:16) <Slide>
    function create_default_slot_2(ctx) {
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			img = element("img");
    			attr_dev(img, "class", "h-64");
    			if (!src_url_equal(img.src, img_src_value = "/images/photo_brother.jpeg")) attr_dev(img, "src", img_src_value);
    			add_location(img, file$1, 39, 20, 1175);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		p: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2.name,
    		type: "slot",
    		source: "(39:16) <Slide>",
    		ctx
    	});

    	return block;
    }

    // (43:16) <Slide>
    function create_default_slot_1(ctx) {
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			img = element("img");
    			attr_dev(img, "class", "h-64");
    			if (!src_url_equal(img.src, img_src_value = "/images/photo_water.jpeg")) attr_dev(img, "src", img_src_value);
    			add_location(img, file$1, 43, 20, 1302);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		p: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1.name,
    		type: "slot",
    		source: "(43:16) <Slide>",
    		ctx
    	});

    	return block;
    }

    // (17:12) <GlideShow>
    function create_default_slot(ctx) {
    	let slide0;
    	let t0;
    	let slide1;
    	let t1;
    	let slide2;
    	let t2;
    	let slide3;
    	let t3;
    	let slide4;
    	let t4;
    	let slide5;
    	let t5;
    	let slide6;
    	let current;

    	slide0 = new Slide({
    			props: {
    				$$slots: { default: [create_default_slot_7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	slide1 = new Slide({
    			props: {
    				$$slots: { default: [create_default_slot_6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	slide2 = new Slide({
    			props: {
    				$$slots: { default: [create_default_slot_5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	slide3 = new Slide({
    			props: {
    				$$slots: { default: [create_default_slot_4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	slide4 = new Slide({
    			props: {
    				$$slots: { default: [create_default_slot_3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	slide5 = new Slide({
    			props: {
    				$$slots: { default: [create_default_slot_2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	slide6 = new Slide({
    			props: {
    				$$slots: { default: [create_default_slot_1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(slide0.$$.fragment);
    			t0 = space();
    			create_component(slide1.$$.fragment);
    			t1 = space();
    			create_component(slide2.$$.fragment);
    			t2 = space();
    			create_component(slide3.$$.fragment);
    			t3 = space();
    			create_component(slide4.$$.fragment);
    			t4 = space();
    			create_component(slide5.$$.fragment);
    			t5 = space();
    			create_component(slide6.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(slide0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(slide1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(slide2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(slide3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(slide4, target, anchor);
    			insert_dev(target, t4, anchor);
    			mount_component(slide5, target, anchor);
    			insert_dev(target, t5, anchor);
    			mount_component(slide6, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const slide0_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				slide0_changes.$$scope = { dirty, ctx };
    			}

    			slide0.$set(slide0_changes);
    			const slide1_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				slide1_changes.$$scope = { dirty, ctx };
    			}

    			slide1.$set(slide1_changes);
    			const slide2_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				slide2_changes.$$scope = { dirty, ctx };
    			}

    			slide2.$set(slide2_changes);
    			const slide3_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				slide3_changes.$$scope = { dirty, ctx };
    			}

    			slide3.$set(slide3_changes);
    			const slide4_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				slide4_changes.$$scope = { dirty, ctx };
    			}

    			slide4.$set(slide4_changes);
    			const slide5_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				slide5_changes.$$scope = { dirty, ctx };
    			}

    			slide5.$set(slide5_changes);
    			const slide6_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				slide6_changes.$$scope = { dirty, ctx };
    			}

    			slide6.$set(slide6_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(slide0.$$.fragment, local);
    			transition_in(slide1.$$.fragment, local);
    			transition_in(slide2.$$.fragment, local);
    			transition_in(slide3.$$.fragment, local);
    			transition_in(slide4.$$.fragment, local);
    			transition_in(slide5.$$.fragment, local);
    			transition_in(slide6.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(slide0.$$.fragment, local);
    			transition_out(slide1.$$.fragment, local);
    			transition_out(slide2.$$.fragment, local);
    			transition_out(slide3.$$.fragment, local);
    			transition_out(slide4.$$.fragment, local);
    			transition_out(slide5.$$.fragment, local);
    			transition_out(slide6.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(slide0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(slide1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(slide2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(slide3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(slide4, detaching);
    			if (detaching) detach_dev(t4);
    			destroy_component(slide5, detaching);
    			if (detaching) detach_dev(t5);
    			destroy_component(slide6, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot.name,
    		type: "slot",
    		source: "(17:12) <GlideShow>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2(ctx) {
    	let div3;
    	let div1;
    	let h1;
    	let t1;
    	let hr0;
    	let t2;
    	let div0;
    	let glideshow;
    	let t3;
    	let div2;
    	let h2;
    	let t5;
    	let hr1;
    	let t6;
    	let whoami;
    	let t7;
    	let hr2;
    	let t8;
    	let skills;
    	let current;

    	glideshow = new SlideShow({
    			props: {
    				$$slots: { default: [create_default_slot] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	whoami = new WhoAmI({ $$inline: true });
    	skills = new Skills({ $$inline: true });

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div1 = element("div");
    			h1 = element("h1");
    			h1.textContent = "Sil Gosker";
    			t1 = space();
    			hr0 = element("hr");
    			t2 = space();
    			div0 = element("div");
    			create_component(glideshow.$$.fragment);
    			t3 = space();
    			div2 = element("div");
    			h2 = element("h2");
    			h2.textContent = "Wie ben ik?";
    			t5 = space();
    			hr1 = element("hr");
    			t6 = space();
    			create_component(whoami.$$.fragment);
    			t7 = space();
    			hr2 = element("hr");
    			t8 = space();
    			create_component(skills.$$.fragment);
    			attr_dev(h1, "class", "text-center text-3xl w-full text-gray-900");
    			add_location(h1, file$1, 11, 8, 312);
    			attr_dev(hr0, "class", "h-px my-8 bg-gray-200 border-0");
    			add_location(hr0, file$1, 13, 8, 393);
    			attr_dev(div0, "class", "p-4");
    			add_location(div0, file$1, 15, 8, 448);
    			attr_dev(div1, "class", "w-full sm:w-1/2");
    			add_location(div1, file$1, 9, 4, 271);
    			attr_dev(h2, "class", "text-center text-3xl w-full text-gray-900");
    			add_location(h2, file$1, 51, 8, 1481);
    			attr_dev(hr1, "class", "h-px my-8 bg-gray-200 border-0");
    			add_location(hr1, file$1, 53, 8, 1563);
    			attr_dev(div2, "class", "w-full sm:w-1/2");
    			add_location(div2, file$1, 50, 4, 1442);
    			attr_dev(hr2, "class", "h-px my-8 bg-gray-200 border-0");
    			add_location(hr2, file$1, 57, 4, 1646);
    			attr_dev(div3, "class", "flex flex-wrap");
    			add_location(div3, file$1, 7, 0, 235);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div1);
    			append_dev(div1, h1);
    			append_dev(div1, t1);
    			append_dev(div1, hr0);
    			append_dev(div1, t2);
    			append_dev(div1, div0);
    			mount_component(glideshow, div0, null);
    			append_dev(div3, t3);
    			append_dev(div3, div2);
    			append_dev(div2, h2);
    			append_dev(div2, t5);
    			append_dev(div2, hr1);
    			append_dev(div2, t6);
    			mount_component(whoami, div2, null);
    			append_dev(div3, t7);
    			append_dev(div3, hr2);
    			append_dev(div3, t8);
    			mount_component(skills, div3, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const glideshow_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				glideshow_changes.$$scope = { dirty, ctx };
    			}

    			glideshow.$set(glideshow_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(glideshow.$$.fragment, local);
    			transition_in(whoami.$$.fragment, local);
    			transition_in(skills.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(glideshow.$$.fragment, local);
    			transition_out(whoami.$$.fragment, local);
    			transition_out(skills.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			destroy_component(glideshow);
    			destroy_component(whoami);
    			destroy_component(skills);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('HomePage', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<HomePage> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ GlideShow: SlideShow, Slide, WhoAmI, Skills });
    	return [];
    }

    class HomePage extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2, create_fragment$2, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "HomePage",
    			options,
    			id: create_fragment$2.name
    		});
    	}
    }

    var HomeRoutes = {
        "/": HomePage,
        "/contact": ContactPage
    };

    const map = new Map();
    const routes = Object.assign(Object.assign(Object.assign(Object.assign({}, AccountRoutes), PlantRoutes), HomeRoutes), { "*": NotFound });
    for (const key in maps) {
        const route = maps[key];
        map.set(route.key, route.value);
    }
    for (const key in routes) {
        map.set(key, routes[key]);
    }

    /* src\Components\Gdpr\GdprPopup.svelte generated by Svelte v3.59.2 */

    const file = "src\\Components\\Gdpr\\GdprPopup.svelte";

    // (22:0) {#if showGdpr}
    function create_if_block(ctx) {
    	let div1;
    	let div0;
    	let button0;
    	let t1;
    	let p;
    	let t3;
    	let button1;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			button0 = element("button");
    			button0.textContent = "Accepteer";
    			t1 = space();
    			p = element("p");
    			p.textContent = "Deze website gebruikt cookies.\r\n                We gebruiken cookies om content te personaliseren, voor social media en het analyseren\r\n                van verkeer op de website, advertenties.";
    			t3 = space();
    			button1 = element("button");
    			button1.textContent = "Negeren";
    			attr_dev(button0, "class", "py-2 px-4 border-sky-600 bg-sky-400 text-white rounded-lg");
    			add_location(button0, file, 24, 12, 753);
    			attr_dev(p, "class", "px-4");
    			add_location(p, file, 27, 12, 916);
    			attr_dev(button1, "class", "py-2 px-4 border-gray-600 bg-gray-400 text-white rounded-lg");
    			add_location(button1, file, 32, 12, 1174);
    			attr_dev(div0, "class", "bg-white p-4 w-full rounded shadow-lg border flex flex-col md:flex-row content-center justify-between");
    			add_location(div0, file, 23, 8, 624);
    			attr_dev(div1, "class", "fixed bottom-0 w-full p-4");
    			add_location(div1, file, 22, 4, 575);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, button0);
    			append_dev(div0, t1);
    			append_dev(div0, p);
    			append_dev(div0, t3);
    			append_dev(div0, button1);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*acceptCookies*/ ctx[1], false, false, false, false),
    					listen_dev(button1, "click", /*declineCookies*/ ctx[2], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block.name,
    		type: "if",
    		source: "(22:0) {#if showGdpr}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1(ctx) {
    	let if_block_anchor;
    	let if_block = /*showGdpr*/ ctx[0] && create_if_block(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*showGdpr*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: noop$1,
    		o: noop$1,
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function setCookie(accepted) {
    	const object = {
    		// formats to yyyy-MM-dd
    		date: new Date().toISOString().split('T')[0],
    		// formats to hh:mm:ss
    		time: new Date().toTimeString().split(' ')[0],
    		accepted
    	};

    	localStorage.setItem("cookie", JSON.stringify(object));
    }

    function instance$1($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('GdprPopup', slots, []);
    	let showGdpr = !localStorage.getItem("cookie");

    	function acceptCookies() {
    		setCookie(true);
    		$$invalidate(0, showGdpr = false);
    	}

    	function declineCookies() {
    		setCookie(false);
    		$$invalidate(0, showGdpr = false);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<GdprPopup> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		showGdpr,
    		setCookie,
    		acceptCookies,
    		declineCookies
    	});

    	$$self.$inject_state = $$props => {
    		if ('showGdpr' in $$props) $$invalidate(0, showGdpr = $$props.showGdpr);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [showGdpr, acceptCookies, declineCookies];
    }

    class GdprPopup extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1, create_fragment$1, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GdprPopup",
    			options,
    			id: create_fragment$1.name
    		});
    	}
    }

    /* src\App.svelte generated by Svelte v3.59.2 */

    function create_fragment(ctx) {
    	let navigation;
    	let t0;
    	let router;
    	let t1;
    	let gdprpopup;
    	let current;
    	navigation = new Navigation({ $$inline: true });

    	router = new Router({
    			props: { routes: map },
    			$$inline: true
    		});

    	gdprpopup = new GdprPopup({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(navigation.$$.fragment);
    			t0 = space();
    			create_component(router.$$.fragment);
    			t1 = space();
    			create_component(gdprpopup.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(navigation, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(router, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(gdprpopup, target, anchor);
    			current = true;
    		},
    		p: noop$1,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navigation.$$.fragment, local);
    			transition_in(router.$$.fragment, local);
    			transition_in(gdprpopup.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navigation.$$.fragment, local);
    			transition_out(router.$$.fragment, local);
    			transition_out(gdprpopup.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navigation, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(router, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(gdprpopup, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('App', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<App> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ Navigation, Router, Routes: map, GdprPopup });
    	return [];
    }

    class App extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance, create_fragment, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "App",
    			options,
    			id: create_fragment.name
    		});
    	}
    }

    const app = new App({
        target: document.body
    });

    return app;

})();
//# sourceMappingURL=bundle.js.map
